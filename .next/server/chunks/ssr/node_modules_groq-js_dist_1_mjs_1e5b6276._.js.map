{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"1.mjs","sources":["file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/values/Path.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/values/StreamValue.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/values/dateHelpers.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/values/utils.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/evaluator/equality.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/evaluator/matching.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/evaluator/ordering.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/evaluator/operators.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/evaluator/scope.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/evaluator/evaluate.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/evaluator/constantEvaluate.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/evaluator/pt.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/evaluator/scoring.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/evaluator/functions.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/markProcessor.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/rawParser.js","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/traversal.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/parser.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/typeEvaluator/optimizations.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/typeEvaluator/typeHelpers.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/typeEvaluator/booleans.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/typeEvaluator/scope.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/typeEvaluator/functions.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/typeEvaluator/matching.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/groq-js/src/typeEvaluator/typeEvaluate.ts"],"sourcesContent":["function escapeRegExp(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction pathRegExp(pattern: string) {\n  const re = []\n  for (const part of pattern.split('.')) {\n    if (part === '*') {\n      re.push('[^.]+')\n    } else if (part === '**') {\n      re.push('.*')\n    } else {\n      re.push(escapeRegExp(part))\n    }\n  }\n\n  return new RegExp(`^${re.join('.')}$`)\n}\n\nexport class Path {\n  private pattern: string\n  private patternRe: RegExp\n\n  constructor(pattern: string) {\n    this.pattern = pattern\n    this.patternRe = pathRegExp(pattern)\n  }\n\n  matches(str: string): boolean {\n    return this.patternRe.test(str)\n  }\n\n  toJSON(): string {\n    return this.pattern\n  }\n}\n","import type {Value} from './types'\n\nexport class StreamValue {\n  type: 'stream' = 'stream'\n  private generator: () => AsyncGenerator<Value, void, unknown>\n  private ticker: Promise<void> | null\n  private isDone: boolean\n  private data: Value[]\n\n  constructor(generator: () => AsyncGenerator<Value, void, unknown>) {\n    this.generator = generator\n    this.ticker = null\n    this.isDone = false\n    this.data = []\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  isArray(): boolean {\n    return true\n  }\n\n  async get(): Promise<any> {\n    const result = []\n    for await (const value of this) {\n      result.push(await value.get())\n    }\n    return result\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<Value, void, unknown> {\n    let i = 0\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i]\n      }\n\n      if (this.isDone) {\n        return\n      }\n\n      await this._nextTick()\n    }\n  }\n\n  _nextTick(): Promise<void> {\n    if (this.ticker) {\n      return this.ticker\n    }\n\n    let currentResolver: (value?: void | PromiseLike<void> | undefined) => void\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve\n      })\n    }\n\n    const tick = () => {\n      currentResolver()\n      setupTicker()\n    }\n\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value)\n        tick()\n      }\n\n      this.isDone = true\n      tick()\n    }\n\n    setupTicker()\n    fetch()\n    return this.ticker!\n  }\n}\n","const RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/\n\nexport function parseRFC3339(str: string): Date | null {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str)\n  }\n  return null\n}\n\nexport function formatRFC3339(d: Date): string {\n  const year = addLeadingZero(d.getUTCFullYear(), 4)\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2)\n  const day = addLeadingZero(d.getUTCDate(), 2)\n  const hour = addLeadingZero(d.getUTCHours(), 2)\n  const minute = addLeadingZero(d.getUTCMinutes(), 2)\n  const second = addLeadingZero(d.getUTCSeconds(), 2)\n\n  let fractionalSecond = ''\n  const millis = d.getMilliseconds()\n  if (millis != 0) {\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`\n  }\n\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`\n}\n\ntype Stringer = {\n  toString(): string\n}\n\nfunction addLeadingZero(num: Stringer, targetLength: number) {\n  let str = num.toString()\n  while (str.length < targetLength) {\n    str = `0${str}`\n  }\n  return str\n}\n","import {formatRFC3339, parseRFC3339} from './dateHelpers'\nimport {Path} from './Path'\nimport {StreamValue} from './StreamValue'\nimport type {BooleanValue, GroqType, NullValue, Value} from './types'\n\nexport class StaticValue<P, T extends GroqType> {\n  data: P\n  type: T\n\n  constructor(data: P, type: T) {\n    this.data = data\n    this.type = type\n  }\n\n  isArray(): boolean {\n    return this.type === 'array'\n  }\n\n  // eslint-disable-next-line require-await\n  async get(): Promise<any> {\n    return this.data\n  }\n\n  [Symbol.asyncIterator](): Generator<Value, void, unknown> {\n    if (Array.isArray(this.data)) {\n      return (function* (data) {\n        for (const element of data) {\n          yield fromJS(element)\n        }\n      })(this.data)\n    }\n    throw new Error(`Cannot iterate over: ${this.type}`)\n  }\n}\n\nexport const NULL_VALUE: NullValue = new StaticValue(null, 'null')\nexport const TRUE_VALUE: BooleanValue = new StaticValue(true, 'boolean')\nexport const FALSE_VALUE: BooleanValue = new StaticValue(false, 'boolean')\n\nexport class DateTime {\n  date: Date\n\n  constructor(date: Date) {\n    this.date = date\n  }\n\n  static parseToValue(str: string): Value {\n    const date = parseRFC3339(str)\n    if (date) {\n      return new StaticValue(new DateTime(date), 'datetime')\n    }\n    return NULL_VALUE\n  }\n\n  equals(other: DateTime): boolean {\n    return this.date.getTime() == other.date.getTime()\n  }\n\n  add(secs: number): DateTime {\n    const copy = new Date(this.date.getTime())\n    copy.setTime(copy.getTime() + secs * 1000)\n    return new DateTime(copy)\n  }\n\n  difference(other: DateTime): number {\n    return (this.date.getTime() - other.date.getTime()) / 1000\n  }\n\n  compareTo(other: DateTime): number {\n    return this.date.getTime() - other.date.getTime()\n  }\n\n  toString(): string {\n    return formatRFC3339(this.date)\n  }\n\n  toJSON(): string {\n    return this.toString()\n  }\n}\n\nexport function fromNumber(num: number): Value {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, 'number')\n  }\n  return NULL_VALUE\n}\n\nexport function fromString(str: string): Value {\n  return new StaticValue(str, 'string')\n}\n\nexport function fromDateTime(dt: DateTime): Value {\n  return new StaticValue(dt, 'datetime')\n}\n\nexport function fromPath(path: Path): Value {\n  return new StaticValue(path, 'path')\n}\n\nfunction isIterator(obj?: Iterator<any>) {\n  return obj && typeof obj.next === 'function'\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function fromJS(val: any): Value {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value)\n      }\n    })\n  } else if (val === null || val === undefined) {\n    return NULL_VALUE\n  }\n  return new StaticValue(val, getType(val)) as any\n}\n\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getType(data: any): GroqType {\n  if (data === null || typeof data === 'undefined') {\n    return 'null'\n  }\n  if (Array.isArray(data)) {\n    return 'array'\n  }\n  if (data instanceof Path) {\n    return 'path'\n  }\n  if (data instanceof DateTime) {\n    return 'datetime'\n  }\n  return typeof data as GroqType\n}\n","import type {Value} from '../values'\n\nexport function isEqual(a: Value, b: Value): boolean {\n  if (\n    (a.type === 'string' && b.type === 'string') ||\n    (a.type === 'boolean' && b.type === 'boolean') ||\n    (a.type === 'null' && b.type === 'null') ||\n    (a.type === 'number' && b.type === 'number')\n  ) {\n    return a.data === b.data\n  }\n\n  if (a.type === 'datetime' && b.type === 'datetime') {\n    return a.data.equals(b.data)\n  }\n\n  return false\n}\n","import type {Value} from '../values'\n\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g\nconst MAX_TERM_LENGTH = 1024\n\nexport type Token = string\n\nexport type Pattern = (tokens: Token[]) => boolean\n\nexport function matchText(tokens: Token[], patterns: Pattern[]): boolean {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false\n  }\n\n  return patterns.every((pattern) => pattern(tokens))\n}\n\nexport function matchTokenize(text: string): Token[] {\n  return text.replace(EDGE_CHARS, '').match(CHARS) || []\n}\n\nexport function matchAnalyzePattern(text: string): Pattern[] {\n  const termsRe = matchPatternRegex(text)\n  return termsRe.map((re) => (tokens: Token[]) => tokens.some((token) => re.test(token)))\n}\n\nexport function matchPatternRegex(text: string): RegExp[] {\n  const terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || []\n  return terms.map(\n    (term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*')}$`, 'i'),\n  )\n}\n\nexport async function gatherText(value: Value, cb: (str: string) => void): Promise<boolean> {\n  if (value.type === 'string') {\n    cb(value.data)\n    return true\n  }\n\n  if (value.isArray()) {\n    let success = true\n    for await (const part of value) {\n      if (part.type === 'string') {\n        cb(part.data)\n      } else {\n        success = false\n      }\n    }\n    return success\n  }\n\n  return false\n}\n","import {getType, type GroqType} from '../values'\n\nconst TYPE_ORDER: {[key in GroqType]?: number} = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4,\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function partialCompare(a: any, b: any): null | number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  if (aType !== bType) {\n    return null\n  }\n\n  switch (aType) {\n    case 'number':\n    case 'boolean':\n      return a - b\n    case 'string':\n      if (a < b) return -1\n      if (a > b) return 1\n      return 0\n    case 'datetime':\n      return a.compareTo(b)\n    default:\n      return null\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function totalCompare(a: any, b: any): number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  const aTypeOrder = TYPE_ORDER[aType] || 100\n  const bTypeOrder = TYPE_ORDER[bType] || 100\n\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder\n  }\n\n  let result = partialCompare(a, b)\n  if (result === null) {\n    result = 0\n  }\n  return result\n}\n","import type {OpCall} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromDateTime,\n  fromJS,\n  fromNumber,\n  fromString,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  type Value,\n} from '../values'\nimport {isEqual} from './equality'\nimport {\n  gatherText,\n  matchAnalyzePattern,\n  matchText,\n  matchTokenize,\n  type Pattern,\n  type Token,\n} from './matching'\nimport {partialCompare} from './ordering'\n\ntype GroqOperatorFn = (left: Value, right: Value) => Value | PromiseLike<Value>\n\nexport const operators: {[key in OpCall]: GroqOperatorFn} = {\n  '==': function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '!=': function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  '>': function gt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '>=': function gte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<': function lt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<=': function lte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  // eslint-disable-next-line func-name-matching\n  'in': async function inop(left, right) {\n    if (right.type === 'path') {\n      if (left.type !== 'string') {\n        return NULL_VALUE\n      }\n\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE\n        }\n      }\n\n      return FALSE_VALUE\n    }\n\n    return NULL_VALUE\n  },\n\n  'match': async function match(left, right) {\n    let tokens: Token[] = []\n    let patterns: Pattern[] = []\n\n    await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part))\n    })\n\n    const didSucceed = await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part))\n    })\n    if (!didSucceed) {\n      return FALSE_VALUE\n    }\n\n    const matched = matchText(tokens, patterns)\n\n    return matched ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '+': function plus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data + right.data)\n    }\n\n    if (left.type === 'string' && right.type === 'string') {\n      return fromString(left.data + right.data)\n    }\n\n    if (left.type === 'object' && right.type === 'object') {\n      return fromJS({...left.data, ...right.data})\n    }\n\n    if (left.type === 'array' && right.type === 'array') {\n      return fromJS(left.data.concat(right.data))\n    }\n\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val\n        }\n\n        for await (const val of right) {\n          yield val\n        }\n      })\n    }\n\n    return NULL_VALUE\n  },\n\n  '-': function minus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(-right.data))\n    }\n\n    if (left.type === 'datetime' && right.type === 'datetime') {\n      return fromNumber(left.data.difference(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data - right.data)\n    }\n\n    return NULL_VALUE\n  },\n\n  '*': numericOperator((a, b) => a * b),\n  '/': numericOperator((a, b) => a / b),\n  '%': numericOperator((a, b) => a % b),\n  '**': numericOperator((a, b) => Math.pow(a, b)),\n}\n\nfunction numericOperator(impl: (a: number, b: number) => number): GroqOperatorFn {\n  return function (left, right) {\n    if (left.type === 'number' && right.type === 'number') {\n      const result = impl(left.data, right.data)\n      return fromNumber(result)\n    }\n\n    return NULL_VALUE\n  }\n}\n","import type {Value} from '../values'\nimport type {Context} from './types'\n\nexport class Scope {\n  public params: Record<string, unknown>\n  public source: Value\n  public value: Value\n  public parent: Scope | null\n  public context: Context\n  public isHidden = false\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(\n    params: Record<string, unknown>,\n    source: Value,\n    value: Value,\n    context: Context,\n    parent: Scope | null,\n  ) {\n    this.params = params\n    this.source = source\n    this.value = value\n    this.context = context\n    this.parent = parent\n  }\n\n  createNested(value: Value): Scope {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent)\n    }\n    return new Scope(this.params, this.source, value, this.context, this)\n  }\n\n  createHidden(value: Value): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n","import type {ExprNode, FuncCallNode, PipeFuncCallNode} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  type Value,\n} from '../values'\nimport {operators} from './operators'\nimport {partialCompare} from './ordering'\nimport {Scope} from './scope'\nimport type {EvaluateOptions, Executor} from './types'\n\nexport function evaluate(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor = evaluate,\n): Value | PromiseLike<Value> {\n  const func = EXECUTORS[node.type]\n  return func(node as any, scope, execute)\n}\n\ntype NarrowNode<T, N> = T extends {type: N} ? T : never\n\ntype ExecutorMap = {\n  [key in ExprNode['type']]: (\n    node: NarrowNode<ExprNode, key>,\n    scope: Scope,\n    exec: Executor,\n  ) => Value | PromiseLike<Value>\n}\n\n/**\n * Applies the function to a value, but tries to avoid creating unnecessary promises.\n */\nfunction promiselessApply(\n  value: Value | PromiseLike<Value>,\n  cb: (val: Value) => Value,\n): Value | PromiseLike<Value> {\n  if ('then' in value) {\n    return value.then(cb)\n  }\n\n  return cb(value)\n}\n\nconst EXECUTORS: ExecutorMap = {\n  This(_, scope) {\n    return scope.value\n  },\n\n  Selector() {\n    // These should be evaluated separely using a different evaluator.\n    // At the mooment we haven't implemented this.\n    throw new Error('Selectors can not be evaluated')\n  },\n\n  Everything(_, scope) {\n    return scope.source\n  },\n\n  Parameter({name}, scope) {\n    return fromJS(scope.params[name])\n  },\n\n  Context({key}, scope) {\n    if (key === 'before' || key === 'after') {\n      const value = scope.context[key]\n      return value || NULL_VALUE\n    }\n    throw new Error(`unknown context key: ${key}`)\n  },\n\n  Parent({n}, scope) {\n    let current = scope\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE\n      }\n\n      current = current.parent\n    }\n    return current.value\n  },\n\n  OpCall({op, left, right}, scope, execute) {\n    const func = operators[op]\n    if (!func) {\n      throw new Error(`Unknown operator: ${op}`)\n    }\n    const leftValue = execute(left, scope)\n    const rightValue = execute(right, scope)\n\n    // Avoid uneccesary promises\n    // This is required for constant evaluation to work correctly.\n    if ('then' in leftValue || 'then' in rightValue) {\n      return (async () => func(await leftValue, await rightValue))()\n    }\n\n    return func(leftValue, rightValue)\n  },\n\n  async Select({alternatives, fallback}, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope)\n      if (altCond.type === 'boolean' && altCond.data === true) {\n        return execute(alt.value, scope)\n      }\n    }\n\n    if (fallback) {\n      return execute(fallback, scope)\n    }\n\n    return NULL_VALUE\n  },\n\n  async InRange({base, left, right, isInclusive}, scope, execute) {\n    const value = await execute(base, scope)\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    const leftCmp = partialCompare(await value.get(), await leftValue.get())\n    if (leftCmp === null) {\n      return NULL_VALUE\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get())\n    if (rightCmp === null) {\n      return NULL_VALUE\n    }\n\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  async Filter({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem)\n        const exprValue = await execute(expr, newScope)\n        if (exprValue.type === 'boolean' && exprValue.data === true) {\n          yield elem\n        }\n      }\n    })\n  },\n\n  async Projection({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (baseValue.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const newScope = scope.createNested(baseValue)\n    return execute(expr, newScope)\n  },\n\n  FuncCall({func, args}: FuncCallNode, scope: Scope, execute) {\n    return func(args, scope, execute)\n  },\n\n  async PipeFuncCall({func, base, args}: PipeFuncCallNode, scope: Scope, execute) {\n    const baseValue = await execute(base, scope)\n    return func(baseValue, args, scope, execute)\n  },\n\n  async AccessAttribute({base, name}, scope, execute) {\n    let value = scope.value\n    if (base) {\n      value = await execute(base, scope)\n    }\n    if (value.type === 'object') {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name])\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  async AccessElement({base, index}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    const data = await baseValue.get()\n    const finalIndex = index < 0 ? index + data.length : index\n    return fromJS(data[finalIndex])\n  },\n\n  async Slice({base, left, right, isInclusive}, scope, execute) {\n    const baseValue = await execute(base, scope)\n\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    // OPT: Here we can optimize when either indices are >= 0\n    const array = (await baseValue.get()) as any[]\n\n    let leftIdx = left\n    let rightIdx = right\n\n    // Handle negative index\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx\n    }\n\n    // Convert from inclusive to exclusive index\n    if (isInclusive) {\n      rightIdx++\n    }\n\n    if (leftIdx < 0) {\n      leftIdx = 0\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0\n    }\n\n    // Note: At this point the indices might point out-of-bound, but\n    // .slice handles this correctly.\n\n    return fromJS(array.slice(leftIdx, rightIdx))\n  },\n\n  async Deref({base}, scope, execute) {\n    const value = await execute(base, scope)\n\n    if (!scope.source.isArray()) {\n      return NULL_VALUE\n    }\n\n    if (value.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const id = value.data['_ref']\n    if (typeof id !== 'string') {\n      return NULL_VALUE\n    }\n\n    if (scope.context.dereference) {\n      return fromJS(await scope.context.dereference({_ref: id}))\n    }\n\n    for await (const doc of scope.source) {\n      if (doc.type === 'object' && id === doc.data['_id']) {\n        return doc\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  Value({value}) {\n    return fromJS(value)\n  },\n\n  Group({base}, scope, execute) {\n    return execute(base, scope)\n  },\n\n  async Object({attributes}, scope, execute) {\n    const result: {[key: string]: any} = {}\n    for (const attr of attributes) {\n      const attrType = attr.type\n      switch (attr.type) {\n        case 'ObjectAttributeValue': {\n          const value = await execute(attr.value, scope)\n          result[attr.name] = await value.get()\n          break\n        }\n\n        case 'ObjectConditionalSplat': {\n          const cond = await execute(attr.condition, scope)\n          if (cond.type !== 'boolean' || cond.data === false) {\n            continue\n          }\n\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        case 'ObjectSplat': {\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        default:\n          throw new Error(`Unknown node type: ${attrType}`)\n      }\n    }\n    return fromJS(result)\n  },\n\n  Array({elements}, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope)\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v\n            }\n          }\n        } else {\n          yield value\n        }\n      }\n    })\n  },\n\n  Tuple() {\n    throw new Error('tuples can not be evaluated')\n  },\n\n  async Or({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return FALSE_VALUE\n  },\n\n  async And({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return TRUE_VALUE\n  },\n\n  async Not({base}, scope, execute) {\n    const value = await execute(base, scope)\n    if (value.type !== 'boolean') {\n      return NULL_VALUE\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  Neg({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(-value.data)\n    })\n  },\n\n  Pos({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(value.data)\n    })\n  },\n\n  Asc() {\n    return NULL_VALUE\n  },\n\n  Desc() {\n    return NULL_VALUE\n  },\n\n  async ArrayCoerce({base}, scope, execute) {\n    const value = await execute(base, scope)\n    return value.isArray() ? value : NULL_VALUE\n  },\n\n  async Map({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        yield await execute(expr, newScope)\n      }\n    })\n  },\n\n  async FlatMap({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        const innerValue = await execute(expr, newScope)\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner\n          }\n        } else {\n          yield innerValue\n        }\n      }\n    })\n  },\n}\n\n/**\n * Evaluates a query.\n * @internal\n */\nexport function evaluateQuery(\n  tree: ExprNode,\n  options: EvaluateOptions = {},\n): Value | PromiseLike<Value> {\n  const root = fromJS(options.root)\n  const dataset = fromJS(options.dataset)\n  const params: {[key: string]: any} = {...options.params}\n\n  const scope = new Scope(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || new Date(),\n      identity: options.identity === undefined ? 'me' : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n      dereference: options.dereference,\n    },\n    null,\n  )\n  return evaluate(tree, scope)\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {NULL_VALUE, type Value} from '../values'\nimport {evaluate} from './evaluate'\nimport {Scope} from './scope'\n\nfunction canConstantEvaluate(node: ExprNode): boolean {\n  switch (node.type) {\n    case 'Group':\n      return canConstantEvaluate(node.base)\n    case 'Value':\n    case 'Parameter':\n      return true\n    case 'Pos':\n    case 'Neg':\n      return canConstantEvaluate(node.base)\n    case 'OpCall':\n      switch (node.op) {\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case '**':\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right)\n        default:\n          return false\n      }\n    default:\n      return false\n  }\n}\n\nconst DUMMY_SCOPE = new Scope(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  {timestamp: new Date(0), identity: 'me', before: null, after: null},\n  null,\n)\n\nexport function tryConstantEvaluate(node: ExprNode): Value | null {\n  if (!canConstantEvaluate(node)) {\n    return null\n  }\n\n  return constantEvaluate(node)\n}\n\nfunction constantEvaluate(node: ExprNode): Value {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate)\n  if ('then' in value) {\n    throw new Error('BUG: constant evaluate should never return a promise')\n  }\n  return value\n}\n","import type {Value} from '../values'\n\nexport async function portableTextContent(value: Value): Promise<string | null> {\n  if (value.type === 'object') {\n    return blockText(value.data)\n  } else if (value.isArray()) {\n    const texts = await arrayText(value)\n    if (texts.length > 0) {\n      return texts.join('\\n\\n')\n    }\n  }\n\n  return null\n}\n\nasync function arrayText(value: Value, result: string[] = []): Promise<string[]> {\n  for await (const block of value) {\n    if (block.type === 'object') {\n      const text = blockText(block.data)\n      if (text !== null) result.push(text)\n    } else if (block.isArray()) {\n      await arrayText(block, result)\n    }\n  }\n\n  return result\n}\n\nfunction blockText(obj: Record<string, unknown>): string | null {\n  if (typeof obj['_type'] !== 'string') return null\n  const children = obj['children']\n  if (!Array.isArray(children)) return null\n\n  let result = ''\n  for (const child of children) {\n    if (\n      child &&\n      typeof child === 'object' &&\n      typeof child._type === 'string' &&\n      child._type === 'span' &&\n      typeof child.text === 'string'\n    ) {\n      result += child.text\n    }\n  }\n  return result\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {gatherText, matchPatternRegex, matchTokenize, type Token} from './matching'\nimport {Scope} from './scope'\nimport type {Executor} from './types'\n\n// BM25 similarity constants\nconst BM25k = 1.2\n\nexport async function evaluateScore(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor,\n): Promise<number> {\n  if (node.type === 'OpCall' && node.op === 'match') {\n    return evaluateMatchScore(node.left, node.right, scope, execute)\n  }\n\n  if (node.type === 'FuncCall' && node.name === 'boost') {\n    const innerScore = await evaluateScore(node.args[0], scope, execute)\n    const boost = await execute(node.args[1], scope)\n    if (boost.type === 'number' && innerScore > 0) {\n      return innerScore + boost.data\n    }\n\n    return 0\n  }\n\n  switch (node.type) {\n    case 'Or': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      return leftScore + rightScore\n    }\n    case 'And': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      if (leftScore === 0 || rightScore === 0) return 0\n      return leftScore + rightScore\n    }\n    default: {\n      const res = await execute(node, scope)\n      return res.type === 'boolean' && res.data === true ? 1 : 0\n    }\n  }\n}\n\nasync function evaluateMatchScore(\n  left: ExprNode,\n  right: ExprNode,\n  scope: Scope,\n  execute: Executor,\n): Promise<number> {\n  const text = await execute(left, scope)\n  const pattern = await execute(right, scope)\n\n  let tokens: Token[] = []\n  let terms: RegExp[] = []\n\n  await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part))\n  })\n\n  const didSucceed = await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part))\n  })\n\n  if (!didSucceed) {\n    return 0\n  }\n\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0\n  }\n\n  let score = 0\n\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0)\n    score += (freq * (BM25k + 1)) / (freq + BM25k)\n  }\n\n  return score\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {\n  DateTime,\n  FALSE_VALUE,\n  fromDateTime,\n  fromJS,\n  fromNumber,\n  fromPath,\n  fromString,\n  getType,\n  NULL_VALUE,\n  Path,\n  StreamValue,\n  TRUE_VALUE,\n  type Value,\n} from '../values'\nimport {totalCompare} from './ordering'\nimport {portableTextContent} from './pt'\nimport {Scope} from './scope'\nimport {evaluateScore} from './scoring'\nimport type {Executor} from './types'\nimport {isEqual} from './equality'\n\nfunction hasReference(value: any, pathSet: Set<string>): boolean {\n  switch (getType(value)) {\n    case 'array':\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    case 'object':\n      if (value._ref) {\n        return pathSet.has(value._ref)\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    default:\n  }\n  return false\n}\n\nfunction countUTF8(str: string): number {\n  let count = 0\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i)\n    if (code >= 0xd800 && code <= 0xdbff) {\n      // High surrogate. Don't count this.\n      // By only counting the low surrogate we will correctly\n      // count the number of UTF-8 code points.\n      continue\n    }\n    count++\n  }\n  return count\n}\n\n/** @public */\nexport type GroqFunctionArg = ExprNode\ntype WithOptions<T> = T & {\n  arity?: GroqFunctionArity\n  mode?: 'normal' | 'delta'\n}\n\nexport type GroqFunctionArity = number | ((count: number) => boolean)\n\n/** @public */\nexport type GroqFunction = (\n  args: GroqFunctionArg[],\n  scope: Scope,\n  execute: Executor,\n) => PromiseLike<Value>\n\nexport type FunctionSet = Record<string, WithOptions<GroqFunction> | undefined>\n\nexport type NamespaceSet = Record<string, FunctionSet | undefined>\n\n// underscored to not collide with environments like jest that give variables named `global` special treatment\nconst _global: FunctionSet = {}\n\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\n_global['anywhere'] = async function anywhere() {\n  throw new Error('not implemented')\n}\n\n_global['anywhere'].arity = 1\n\n_global['coalesce'] = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope)\n    if (value.type !== 'null') {\n      return value\n    }\n  }\n  return NULL_VALUE\n}\n\n_global['count'] = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (!inner.isArray()) {\n    return NULL_VALUE\n  }\n\n  let num = 0\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _ of inner) {\n    num++\n  }\n  return fromNumber(num)\n}\n_global['count'].arity = 1\n\n_global['dateTime'] = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope)\n  if (val.type === 'datetime') {\n    return val\n  }\n  if (val.type !== 'string') {\n    return NULL_VALUE\n  }\n  return DateTime.parseToValue(val.data)\n}\n_global['dateTime'].arity = 1\n\n_global['defined'] = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  return inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE\n}\n_global['defined'].arity = 1\n\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\n_global['identity'] = async function identity(_args, scope) {\n  return fromString(scope.context.identity)\n}\n_global['identity'].arity = 0\n\n_global['length'] = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n\n  if (inner.type === 'string') {\n    return fromNumber(countUTF8(inner.data))\n  }\n\n  if (inner.isArray()) {\n    let num = 0\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for await (const _ of inner) {\n      num++\n    }\n    return fromNumber(num)\n  }\n\n  return NULL_VALUE\n}\n_global['length'].arity = 1\n\n_global['path'] = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (inner.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromPath(new Path(inner.data))\n}\n_global['path'].arity = 1\n\n_global['string'] = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  switch (value.type) {\n    case 'number':\n    case 'string':\n    case 'boolean':\n    case 'datetime':\n      return fromString(`${value.data}`)\n    default:\n      return NULL_VALUE\n  }\n}\n_global['string'].arity = 1\n\n_global['references'] = async function references(args, scope, execute) {\n  const pathSet = new Set<string>()\n  for (const arg of args) {\n    const path = await execute(arg, scope)\n    if (path.type === 'string') {\n      pathSet.add(path.data)\n    } else if (path.isArray()) {\n      for await (const elem of path) {\n        if (elem.type === 'string') {\n          pathSet.add(elem.data)\n        }\n      }\n    }\n  }\n\n  if (pathSet.size === 0) {\n    return FALSE_VALUE\n  }\n\n  const scopeValue = await scope.value.get()\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE\n}\n_global['references'].arity = (c) => c >= 1\n\n_global['round'] = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (value.type !== 'number') {\n    return NULL_VALUE\n  }\n\n  const num = value.data\n  let prec = 0\n\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope)\n    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE\n    }\n    prec = precValue.data\n  }\n\n  if (prec === 0) {\n    if (num < 0) {\n      // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n      // The behavior we're interested in is to \"round half away from zero\".\n      return fromNumber(-Math.round(-num))\n    }\n    return fromNumber(Math.round(num))\n  }\n  return fromNumber(Number(num.toFixed(prec)))\n}\n_global['round'].arity = (count) => count >= 1 && count <= 2\n\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\n_global['now'] = async function now(_args, scope) {\n  return fromString(scope.context.timestamp.toISOString())\n}\n_global['now'].arity = 0\n\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\n_global['boost'] = async function boost() {\n  // This should be handled by the scoring function.\n  throw new Error('unexpected boost call')\n}\n\n_global['boost'].arity = 2\n\nconst string: FunctionSet = {}\n\nstring['lower'] = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toLowerCase())\n}\nstring['lower'].arity = 1\n\nstring['upper'] = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toUpperCase())\n}\nstring['upper'].arity = 1\n\nstring['split'] = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  if (str.data.length === 0) {\n    return fromJS([])\n  }\n  if (sep.data.length === 0) {\n    // This uses a Unicode codepoint splitting algorithm\n    return fromJS(Array.from(str.data))\n  }\n  return fromJS(str.data.split(sep.data))\n}\nstring['split'].arity = 2\n\n_global['lower'] = string['lower']\n_global['upper'] = string['upper']\n\nstring['startsWith'] = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  const prefix = await execute(args[1], scope)\n  if (prefix.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n}\nstring['startsWith'].arity = 2\n\nconst array: FunctionSet = {}\n\narray['join'] = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n  let buf = ''\n  let needSep = false\n  for await (const elem of arr) {\n    if (needSep) {\n      buf += sep.data\n    }\n    switch (elem.type) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n      case 'datetime':\n        buf += `${elem.data}`\n        break\n      default:\n        return NULL_VALUE\n    }\n    needSep = true\n  }\n  return fromJS(buf)\n}\narray['join'].arity = 2\n\narray['compact'] = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    for await (const elem of arr) {\n      if (elem.type !== 'null') {\n        yield elem\n      }\n    }\n  })\n}\narray['compact'].arity = 1\n\narray['unique'] = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (!value.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    const added = new Set()\n    for await (const iter of value) {\n      switch (iter.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'datetime':\n          if (!added.has(iter.data)) {\n            added.add(iter.data)\n            yield iter\n          }\n          break\n        default:\n          yield iter\n      }\n    }\n  })\n}\narray['unique'].arity = 1\n\narray['intersects'] = async function (args, scope, execute) {\n  // Intersects returns true if the two arrays have at least one element in common. Only\n  // primitives are supported; non-primitives are ignored.\n  const arr1 = await execute(args[0], scope)\n  if (!arr1.isArray()) {\n    return NULL_VALUE\n  }\n\n  const arr2 = await execute(args[1], scope)\n  if (!arr2.isArray()) {\n    return NULL_VALUE\n  }\n\n  for await (const v1 of arr1) {\n    for await (const v2 of arr2) {\n      if (isEqual(v1, v2)) {\n        return TRUE_VALUE\n      }\n    }\n  }\n\n  return FALSE_VALUE\n}\narray['intersects'].arity = 2\n\nconst pt: FunctionSet = {}\npt['text'] = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  const text = await portableTextContent(value)\n\n  if (text === null) {\n    return NULL_VALUE\n  }\n\n  return fromString(text)\n}\n\npt['text'].arity = 1\n\nconst sanity: FunctionSet = {}\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\nsanity['projectId'] = async function (_args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId)\n  }\n\n  return NULL_VALUE\n}\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\nsanity['dataset'] = async function (_args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset)\n  }\n\n  return NULL_VALUE\n}\n\n// eslint-disable-next-line require-await\nsanity['versionOf'] = async function (args, scope, execute) {\n  if (!scope.source.isArray()) return NULL_VALUE\n\n  const value = await execute(args[0], scope)\n  if (value.type !== 'string') return NULL_VALUE\n  const baseId = value.data\n\n  // All the documents are a version of document 'bar' if its document ID is of\n  // the form versions.releaseId.bar\n  const versionIds: string[] = []\n  for await (const value of scope.source) {\n    if (getType(value) === 'object') {\n      const val = await value.get()\n      if (val && typeof val._id === 'string') {\n        const components = val._id.split('.')\n        if (\n          val._id === baseId ||\n          (components.length >= 3 &&\n            components[0] === 'versions' &&\n            components.slice(2).join('.') === baseId) ||\n          (components.length >= 2 &&\n            components[0] === 'drafts' &&\n            components.slice(1).join('.') === baseId)\n        ) {\n          versionIds.push(val._id)\n        }\n      }\n    }\n  }\n\n  return fromJS(versionIds)\n}\nsanity['versionOf'].arity = 1\n\n// eslint-disable-next-line require-await\nsanity['partOfRelease'] = async function (args, scope, execute) {\n  if (!scope.source.isArray()) return NULL_VALUE\n\n  const value = await execute(args[0], scope)\n  if (value.type !== 'string') return NULL_VALUE\n  const baseId = value.data\n\n  // A document is part of a release 'foo' if its document ID is of the form\n  // versions.foo.documentGroupId\n  const documentIdsInRelease: string[] = []\n  for await (const value of scope.source) {\n    if (getType(value) === 'object') {\n      const val = await value.get()\n      if (val && typeof val._id === 'string') {\n        const components = val._id.split('.')\n        if (components.length >= 3 && components[0] === 'versions' && components[1] === baseId) {\n          documentIdsInRelease.push(val._id)\n        }\n      }\n    }\n  }\n\n  return fromJS(documentIdsInRelease)\n}\nsanity['partOfRelease'].arity = 1\n\nconst releases: FunctionSet = {}\n\n// eslint-disable-next-line require-await\nreleases['all'] = async function (_args, scope) {\n  const allReleases: string[] = []\n  for await (const value of scope.source) {\n    if (getType(value) === 'object') {\n      const val = await value.get()\n      if (val && '_type' in val && val._type === 'system.release') {\n        allReleases.push(val)\n      }\n    }\n  }\n\n  return fromJS(allReleases)\n}\nreleases['all'].arity = 0\n\nexport type GroqPipeFunction = (\n  base: Value,\n  args: ExprNode[],\n  scope: Scope,\n  execute: Executor,\n) => PromiseLike<Value>\n\nexport const pipeFunctions: {[key: string]: WithOptions<GroqPipeFunction>} = {}\n\npipeFunctions['order'] = async function order(base, args, scope, execute) {\n  // eslint-disable-next-line max-len\n  // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n  await true\n\n  if (!base.isArray()) {\n    return NULL_VALUE\n  }\n\n  const mappers = []\n  const directions: string[] = []\n  let n = 0\n\n  for (let mapper of args) {\n    let direction = 'asc'\n\n    if (mapper.type === 'Desc') {\n      direction = 'desc'\n      mapper = mapper.base\n    } else if (mapper.type === 'Asc') {\n      mapper = mapper.base\n    }\n\n    mappers.push(mapper)\n    directions.push(direction)\n    n++\n  }\n\n  const aux = []\n  let idx = 0\n\n  for await (const value of base) {\n    const newScope = scope.createNested(value)\n    const tuple = [await value.get(), idx]\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope)\n      tuple.push(await result.get())\n    }\n    aux.push(tuple)\n    idx++\n  }\n\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2])\n      if (directions[i] === 'desc') {\n        c = -c\n      }\n      if (c !== 0) {\n        return c\n      }\n    }\n    // Fallback to sorting on the original index for stable sorting.\n    return aTuple[1] - bTuple[1]\n  })\n\n  return fromJS(aux.map((v) => v[0]))\n}\npipeFunctions['order'].arity = (count) => count >= 1\n\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\npipeFunctions['score'] = async function score(base, args, scope, execute) {\n  if (!base.isArray()) return NULL_VALUE\n\n  // Anything that isn't an object should be sorted first.\n  const unknown: Array<any> = []\n  const scored: Array<ObjectWithScore> = []\n\n  for await (const value of base) {\n    if (value.type !== 'object') {\n      unknown.push(await value.get())\n      continue\n    }\n\n    const newScope = scope.createNested(value)\n    let valueScore = typeof value.data['_score'] === 'number' ? value.data['_score'] : 0\n\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute)\n    }\n\n    const newObject = Object.assign({}, value.data, {_score: valueScore})\n    scored.push(newObject)\n  }\n\n  scored.sort((a, b) => b._score - a._score)\n  return fromJS(scored)\n}\n\npipeFunctions['score'].arity = (count) => count >= 1\n\ntype ObjectWithScore = Record<string, unknown> & {_score: number}\n\nconst delta: FunctionSet = {}\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\ndelta['operation'] = async function (_args, scope) {\n  const hasBefore = scope.context.before !== null\n  const hasAfter = scope.context.after !== null\n\n  if (hasBefore && hasAfter) {\n    return fromString('update')\n  }\n\n  if (hasAfter) {\n    return fromString('create')\n  }\n\n  if (hasBefore) {\n    return fromString('delete')\n  }\n\n  return NULL_VALUE\n}\n\ndelta['changedAny'] = () => {\n  throw new Error('not implemented')\n}\ndelta['changedAny'].arity = 1\ndelta['changedAny'].mode = 'delta'\n\ndelta['changedOnly'] = () => {\n  throw new Error('not implemented')\n}\ndelta['changedOnly'].arity = 1\ndelta['changedOnly'].mode = 'delta'\n\nconst diff: FunctionSet = {}\ndiff['changedAny'] = () => {\n  throw new Error('not implemented')\n}\ndiff['changedAny'].arity = 3\n\ndiff['changedOnly'] = () => {\n  throw new Error('not implemented')\n}\ndiff['changedOnly'].arity = 3\n\nconst math: FunctionSet = {}\nmath['min'] = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data < n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath['min'].arity = 1\n\nmath['max'] = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data > n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath['max'].arity = 1\n\nmath['sum'] = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n  }\n  return fromJS(n)\n}\nmath['sum'].arity = 1\n\nmath['avg'] = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  let c = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n    c++\n  }\n  if (c === 0) {\n    return NULL_VALUE\n  }\n  return fromJS(n / c)\n}\nmath['avg'].arity = 1\n\nconst dateTime: FunctionSet = {}\ndateTime['now'] = async function now(_args, scope) {\n  return fromDateTime(new DateTime(scope.context.timestamp))\n}\ndateTime['now'].arity = 0\n\nexport const namespaces: NamespaceSet = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n  dateTime,\n  releases,\n}\n","import type {ParseOptions} from './types'\n\nexport type MarkName =\n  | 'add'\n  | 'and'\n  | 'arr_expr'\n  | 'array_end'\n  | 'array_splat'\n  | 'array'\n  | 'asc'\n  | 'attr_ident'\n  | 'comp'\n  | 'dblparent'\n  | 'deref_field'\n  | 'deref'\n  | 'desc'\n  | 'div'\n  | 'exc_range'\n  | 'filter'\n  | 'float'\n  | 'func_args_end'\n  | 'func_call'\n  | 'ident'\n  | 'inc_range'\n  | 'integer'\n  | 'mod'\n  | 'mul'\n  | 'neg'\n  | 'not'\n  | 'object_end'\n  | 'object_expr'\n  | 'object_pair'\n  | 'object_splat_this'\n  | 'object_splat'\n  | 'object'\n  | 'or'\n  | 'pair'\n  | 'param'\n  | 'paren'\n  | 'parent'\n  | 'pipecall'\n  | 'pos'\n  | 'pow'\n  | 'project'\n  | 'sci'\n  | 'star'\n  | 'str_begin'\n  | 'sub'\n  | 'this'\n\nexport interface Mark {\n  name: string\n  position: number\n}\n\nexport type MarkVisitor<T> = Record<string, MarkVisitorFunc<T>>\nexport type MarkVisitorFunc<T> = (p: MarkProcessor, mark: Mark) => T\n\nexport class MarkProcessor {\n  private string: string\n  private marks: Mark[]\n  private index: number\n  parseOptions: ParseOptions\n  allowBoost = false\n\n  constructor(string: string, marks: Mark[], parseOptions: ParseOptions) {\n    this.string = string\n    this.marks = marks\n    this.index = 0\n    this.parseOptions = parseOptions\n  }\n\n  hasMark(pos = 0): boolean {\n    return this.index + pos < this.marks.length\n  }\n\n  getMark(pos = 0): Mark {\n    return this.marks[this.index + pos]\n  }\n\n  shift(): void {\n    this.index += 1\n  }\n\n  process<T>(visitor: MarkVisitor<T>): T {\n    const mark = this.marks[this.index]\n    this.shift()\n    const func = visitor[mark.name]\n    if (!func) {\n      throw new Error(`Unknown handler: ${mark.name}`)\n    }\n    return func.call(visitor, this, mark)\n  }\n\n  processString(): string {\n    this.shift()\n    return this.processStringEnd()\n  }\n\n  processStringEnd(): string {\n    const prev = this.marks[this.index - 1]\n    const curr = this.marks[this.index]\n    this.shift()\n    return this.string.slice(prev.position, curr.position)\n  }\n\n  slice(len: number): string {\n    const pos = this.marks[this.index].position\n    return this.string.slice(pos, pos + len)\n  }\n}\n","'use strict'\n\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/\nconst NUM = /^\\d+/\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1\nconst PREC_OR = 2\nconst PREC_AND = 3\nconst PREC_COMP = 4\nconst PREC_ORDER = 4\nconst PREC_ADD = 6\nconst PREC_SUB = 6\nconst PREC_MUL = 7\nconst PREC_DIV = 7\nconst PREC_MOD = 7\nconst PREC_POW = 8\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10\nconst PREC_NOT = 10\nconst PREC_NEG = 8\n\nfunction parse(str) {\n  let pos = 0\n  pos = skipWS(str, pos)\n  let result = parseExpr(str, pos, 0)\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position)\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1\n    }\n    return {type: 'error', position: pos}\n  }\n  delete result.position\n  delete result.failPosition\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associcativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos\n  let token = str[pos]\n  let marks\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '(': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0)\n      if (rhs.type === 'error') return rhs\n      pos = skipWS(str, rhs.position)\n      switch (str[pos]) {\n        case ',': {\n          // Tuples\n          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks)\n          pos = skipWS(str, pos + 1)\n          while (true) {\n            rhs = parseExpr(str, pos, 0)\n            if (rhs.type === 'error') return rhs\n            pos = skipWS(str, rhs.position)\n            if (str[pos] !== ',') break\n            pos = skipWS(str, pos + 1)\n          }\n          if (str[pos] !== ')') return {type: 'error', position: pos}\n          pos++\n          marks.push({name: 'tuple_end', position: pos})\n          break\n        }\n        case ')': {\n          pos++\n          marks = [{name: 'group', position: startPos}].concat(rhs.marks)\n          break\n        }\n        default:\n          return {type: 'error', position: pos}\n      }\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}]\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos})\n            pos = skipWS(str, pos + 3)\n          }\n\n          let res = parseExpr(str, pos, 0)\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks)\n          pos = res.position\n          pos = skipWS(str, pos)\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1)\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++\n        marks.push({name: 'array_end', position: pos})\n      } else {\n        return {type: 'error', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '^': {\n      pos++\n      marks = []\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos})\n        pos += 2\n      }\n      marks.push({name: 'parent', position: startPos})\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}]\n      pos++\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}]\n      pos++\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT)\n      if (identLen) {\n        pos += 1 + identLen\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ]\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM)\n      if (numLen) {\n        pos += numLen\n        let name = 'integer'\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM)\n          if (fracLen) {\n            name = 'float'\n            pos += 1 + fracLen\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci'\n          pos++\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++\n          }\n          let expLen = parseRegex(str, pos, NUM)\n          if (!expLen) return {type: 'error', position: pos}\n          pos += expLen\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ]\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT)\n      if (identLen) {\n        pos += identLen\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos)\n            if (result.type === 'error') return result\n            marks = result.marks\n            pos = result.position\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ]\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', position: pos}\n  }\n\n  let lhsLevel = 12\n  let trav\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos)\n    if (innerPos === str.length) {\n      pos = innerPos\n      break\n    }\n\n    trav = parseTraversal(str, innerPos)\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos})\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks)\n        pos = trav.position\n        trav = parseTraversal(str, skipWS(str, pos))\n      }\n      marks.push({name: 'traversal_end', position: pos})\n      continue\n    }\n\n    let token = str[innerPos]\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1]\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR)\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks)\n            marks.unshift({name: 'pair', position: startPos})\n            pos = rhs.position\n            lhsLevel = PREC_PAIR\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = PREC_COMP\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'add', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_ADD\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'sub', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_SUB\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'pow', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_POW\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mul', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MUL\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'div', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_DIV\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mod', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MOD\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1\n        if (str[nextPos] === '=') {\n          nextPos++\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'or', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_OR\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1)\n          let identLen = parseRegex(str, identPos, IDENT)\n          if (!identLen) return {type: 'error', position: identPos}\n          pos = identPos + identLen\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos)\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks)\n            marks.unshift({name: 'pipecall', position: startPos})\n            pos = result.position\n            lhsLevel = 11\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'and', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_AND\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case 'd': {\n        // asc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos})\n        pos = innerPos + 4\n        lhsLevel = PREC_ORDER\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos})\n        pos = innerPos + 3\n        lhsLevel = PREC_ORDER\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT)\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2)\n\n            let isGroup = false\n\n            if (str[pos] === '(') {\n              isGroup = true\n              pos = skipWS(str, pos + 1)\n            }\n\n            let rangePos = pos\n            let result = parseExpr(str, pos, PREC_COMP + 1)\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position)\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range'\n              if (str[pos + 2] === '.') {\n                type = 'exc_range'\n                pos = skipWS(str, pos + 3)\n              } else {\n                pos = skipWS(str, pos + 2)\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1)\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos})\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks)\n              pos = rhs.position\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos})\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n              marks = marks.concat(result.marks)\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos)\n              if (str[pos] !== ')') return {type: 'error', position: pos}\n              pos++\n            }\n\n            lhsLevel = PREC_COMP\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = 4\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1)\n      let identStart = pos\n      let identLen = parseRegex(str, pos, IDENT)\n      if (!identLen) return {type: 'error', position: pos}\n      pos += identLen\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>') return {type: 'error', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}]\n      pos += 2\n\n      let identPos = skipWS(str, pos)\n      let identLen = parseRegex(str, identPos, IDENT)\n      if (identLen) {\n        pos = identPos + identLen\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos},\n        )\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position)\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range'\n        if (str[pos + 2] === '.') {\n          type = 'exc_range'\n          pos += 3\n        } else {\n          pos += 2\n        }\n\n        pos = skipWS(str, pos)\n        let rhs = parseExpr(str, pos, 0)\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position)\n        if (str[pos] !== ']') return {type: 'error', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']') return {type: 'error', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1)\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos)\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos})\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos})\n      return result\n    }\n  }\n\n  return {type: 'error', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = []\n\n  marks.push({name: 'func_call', position: startPos})\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos})\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 2)\n    let nameLen = parseRegex(str, pos, IDENT)\n    if (!nameLen) return {type: 'error', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen})\n    pos = skipWS(str, pos + nameLen)\n    if (str[pos] !== '(') return {type: 'error', position: pos}\n    pos++\n    // Consume any whitespace in front of the function argument.\n    pos = skipWS(str, pos)\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 1)\n  }\n\n  let lastPos = pos\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks)\n      lastPos = result.position\n      pos = skipWS(str, result.position)\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1)\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos})\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}]\n  pos = skipWS(str, pos + 1)\n\n  loop: while (str[pos] !== '}') {\n    let pairPos = pos\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3)\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0)\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos})\n        marks = marks.concat(expr.marks)\n        pos = expr.position\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos})\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0)\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position)\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0)\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos})\n        marks = marks.concat(expr.marks, value.marks)\n        pos = value.position\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks)\n        pos = expr.position\n      }\n    }\n    pos = skipWS(str, pos)\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1)\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', position: pos}\n  }\n\n  pos++\n  marks.push({name: 'object_end', position: pos})\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos]\n  pos = pos + 1\n  const marks = [{name: 'str', position: pos}]\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos})\n        pos++\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos})\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3})\n            pos = str.indexOf('}', pos + 3)\n            marks.push({name: 'unicode_hex_end', position: pos})\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2})\n            marks.push({name: 'unicode_hex_end', position: pos + 6})\n            pos += 5\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1})\n          pos += 1\n        }\n        marks.push({name: 'str_start', position: pos + 1})\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0] : null\n}\n\nexport {parse}\n","/* eslint-disable camelcase */\nimport type {ExprNode} from './nodeTypes'\n\nexport type Traversal = (base: ExprNode) => ExprNode\n\n/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a: Traversal, b: Traversal): Traversal {\n  return (base: ExprNode) => b(a(base))\n}\n\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'Map', base, expr: inner({type: 'This'})})\n}\n\nfunction flatMap(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'FlatMap', base, expr: inner({type: 'This'})})\n}\n\nexport type TraversalResult = {\n  type: 'a-a' | 'a-b' | 'b-a' | 'b-b'\n  build: Traversal\n}\n\nexport function traverseArray(build: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-a',\n      build: build,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(build, right.build),\n      }\n\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(build, right.build),\n      }\n\n    case 'b-b':\n      return {\n        type: 'a-a',\n        build: join(build, map(right.build)),\n      }\n\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(build, flatMap(right.build)),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traversePlain(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseElement(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'a-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseProjection(\n  mapper: Traversal,\n  right: TraversalResult | null,\n): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(map(mapper), right.build),\n      }\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(map(mapper), right.build),\n      }\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n","/* eslint-disable camelcase */\nimport {tryConstantEvaluate} from './evaluator'\nimport {type GroqFunctionArity, namespaces, pipeFunctions} from './evaluator/functions'\nimport {type Mark, MarkProcessor, type MarkVisitor} from './markProcessor'\nimport type {\n  ArrayElementNode,\n  ExprNode,\n  FuncCallNode,\n  ObjectAttributeNode,\n  ObjectSplatNode,\n  OpCall,\n  ParentNode,\n  SelectNode,\n} from './nodeTypes'\nimport {parse as rawParse} from './rawParser'\nimport {\n  type TraversalResult,\n  traverseArray,\n  traverseElement,\n  traversePlain,\n  traverseProjection,\n} from './traversal'\nimport type {ParseOptions} from './types'\n\ntype EscapeSequences = \"'\" | '\"' | '\\\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't'\n\nconst ESCAPE_SEQUENCE: {[key in EscapeSequences]: string} = {\n  \"'\": \"'\",\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n}\n\nfunction expandHex(str: string): string {\n  const charCode = parseInt(str, 16)\n  return String.fromCharCode(charCode)\n}\n\nclass GroqQueryError extends Error {\n  public override name = 'GroqQueryError'\n}\n\nconst EXPR_BUILDER: MarkVisitor<ExprNode> = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER)\n    return {\n      type: 'Group',\n      base: inner,\n    }\n  },\n\n  everything() {\n    return {type: 'Everything'}\n  },\n\n  this() {\n    return {type: 'This'}\n  },\n\n  parent() {\n    return {\n      type: 'Parent',\n      n: 1,\n    }\n  },\n\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER) as ParentNode\n    return {\n      type: 'Parent',\n      n: next.n + 1,\n    }\n  },\n\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER)\n    const traversalList: Array<(right: TraversalResult | null) => TraversalResult> = []\n    while (p.getMark().name !== 'traversal_end') {\n      traversalList.push(p.process(TRAVERSE_BUILDER))\n    }\n    p.shift()\n    let traversal: TraversalResult | null = null\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal)\n    }\n    if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n      traversal = traverseArray((val) => val, traversal)\n    }\n    if (traversal === null) throw new Error('BUG: unexpected empty traversal')\n    return traversal.build(base)\n  },\n\n  this_attr(p) {\n    const name = p.processString()\n\n    if (name === 'null') {\n      return {type: 'Value', value: null}\n    }\n    if (name === 'true') {\n      return {type: 'Value', value: true}\n    }\n    if (name === 'false') {\n      return {type: 'Value', value: false}\n    }\n\n    return {\n      type: 'AccessAttribute',\n      name,\n    }\n  },\n\n  neg(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Neg',\n      base,\n    }\n  },\n\n  pos(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Pos',\n      base,\n    }\n  },\n\n  add(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '+',\n      left,\n      right,\n    }\n  },\n\n  sub(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '-',\n      left,\n      right,\n    }\n  },\n\n  mul(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '*',\n      left,\n      right,\n    }\n  },\n\n  div(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '/',\n      left,\n      right,\n    }\n  },\n\n  mod(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '%',\n      left,\n      right,\n    }\n  },\n\n  pow(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '**',\n      left,\n      right,\n    }\n  },\n\n  comp(p) {\n    const left = p.process(EXPR_BUILDER)\n    const op = p.processString() as OpCall\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: op,\n      left: left,\n      right: right,\n    }\n  },\n\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER)\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'InRange',\n      base,\n      left,\n      right,\n      isInclusive,\n    }\n  },\n\n  str(p) {\n    let value = ''\n    // eslint-disable-next-line no-labels\n    loop: while (p.hasMark()) {\n      const mark = p.getMark()\n      switch (mark.name) {\n        case 'str_end':\n          value += p.processStringEnd()\n          // eslint-disable-next-line no-labels\n          break loop\n        case 'str_pause':\n          value += p.processStringEnd()\n          break\n        case 'str_start':\n          p.shift()\n          break\n        case 'single_escape': {\n          const char = p.slice(1)\n          p.shift()\n          value += ESCAPE_SEQUENCE[char as EscapeSequences]\n          break\n        }\n        case 'unicode_hex':\n          p.shift()\n          value += expandHex(p.processStringEnd())\n          break\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`)\n      }\n    }\n    return {type: 'Value', value}\n  },\n\n  integer(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  float(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  sci(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  object(p) {\n    const attributes: ObjectAttributeNode[] = []\n    while (p.getMark().name !== 'object_end') {\n      attributes.push(p.process(OBJECT_BUILDER))\n    }\n    p.shift()\n\n    return {\n      type: 'Object',\n      attributes,\n    }\n  },\n\n  array(p) {\n    const elements: ArrayElementNode[] = []\n    while (p.getMark().name !== 'array_end') {\n      let isSplat = false\n      if (p.getMark().name === 'array_splat') {\n        isSplat = true\n        p.shift()\n      }\n      const value = p.process(EXPR_BUILDER)\n      elements.push({\n        type: 'ArrayElement',\n        value,\n        isSplat,\n      })\n    }\n    p.shift()\n    return {\n      type: 'Array',\n      elements: elements,\n    }\n  },\n\n  tuple(p) {\n    const members: ExprNode[] = []\n    while (p.getMark().name !== 'tuple_end') {\n      members.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n    return {\n      type: 'Tuple',\n      members,\n    }\n  },\n\n  func_call(p) {\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n\n    const name = p.processString()\n    if (namespace === 'global' && name === 'select') {\n      const result: SelectNode = {\n        type: 'Select',\n        alternatives: [],\n      }\n\n      while (p.getMark().name !== 'func_args_end') {\n        if (p.getMark().name === 'pair') {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          p.shift()\n          const condition = p.process(EXPR_BUILDER)\n          const value = p.process(EXPR_BUILDER)\n          result.alternatives.push({\n            type: 'SelectAlternative',\n            condition,\n            value,\n          })\n        } else {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          const value = p.process(EXPR_BUILDER)\n          result.fallback = value\n        }\n      }\n      p.shift()\n      return result\n    }\n\n    const args: ExprNode[] = []\n\n    while (p.getMark().name !== 'func_args_end') {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        // Since the diff/delta functions aren't validated yet we only want to validate the selector\n        // being used. We expect the null valued arg to throw an error at evaluation time.\n        p.process(SELECTOR_BUILDER)\n        args.push({type: 'Selector'})\n      } else {\n        args.push(p.process(EXPR_BUILDER))\n      }\n    }\n\n    p.shift()\n\n    if (namespace === 'global' && (name === 'before' || name === 'after')) {\n      if (p.parseOptions.mode === 'delta') {\n        return {\n          type: 'Context',\n          key: name,\n        }\n      }\n    }\n\n    if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n      throw new GroqQueryError('unexpected boost')\n\n    const funcs = namespaces[namespace]\n    if (!funcs) {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const func = funcs[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n    if (func.arity !== undefined) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n\n    return {\n      type: 'FuncCall',\n      func,\n      namespace,\n      name,\n      args,\n    }\n  },\n\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER)\n    p.shift() // Remove the func_call\n\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n    if (namespace !== 'global') {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const name = p.processString()\n    const args: ExprNode[] = []\n\n    const oldAllowBoost = p.allowBoost\n    if (name === 'score') {\n      // Only allow boost inside a score expression\n      p.allowBoost = true\n    }\n\n    for (;;) {\n      const markName = p.getMark().name\n      if (markName === 'func_args_end') {\n        break\n      }\n\n      if (name === 'order') {\n        if (markName === 'asc') {\n          p.shift()\n          args.push({type: 'Asc', base: p.process(EXPR_BUILDER)})\n          continue\n        } else if (markName === 'desc') {\n          p.shift()\n          args.push({type: 'Desc', base: p.process(EXPR_BUILDER)})\n          continue\n        }\n      }\n\n      args.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n\n    p.allowBoost = oldAllowBoost\n\n    const func = pipeFunctions[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined pipe function: ${name}`)\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    return {\n      type: 'PipeFuncCall',\n      func,\n      base,\n      name,\n      args,\n    }\n  },\n\n  pair() {\n    throw new GroqQueryError(`unexpected =>`)\n  },\n\n  and(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'And',\n      left,\n      right,\n    }\n  },\n\n  or(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'Or',\n      left,\n      right,\n    }\n  },\n\n  not(p) {\n    const base = p.process(EXPR_BUILDER)\n    return {\n      type: 'Not',\n      base,\n    }\n  },\n\n  asc() {\n    throw new GroqQueryError('unexpected asc')\n  },\n\n  desc() {\n    throw new GroqQueryError('unexpected desc')\n  },\n\n  param(p) {\n    const name = p.processString()\n\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: 'Value',\n        value: p.parseOptions.params[name],\n      }\n    }\n\n    return {\n      type: 'Parameter',\n      name,\n    }\n  },\n}\n\nconst OBJECT_BUILDER: MarkVisitor<ObjectAttributeNode> = {\n  object_expr(p) {\n    if (p.getMark().name === 'pair') {\n      p.shift()\n      const condition = p.process(EXPR_BUILDER)\n      const value = p.process(EXPR_BUILDER)\n\n      return {\n        type: 'ObjectConditionalSplat',\n        condition,\n        value,\n      }\n    }\n\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectAttributeValue',\n      name: extractPropertyKey(value),\n      value,\n    }\n  },\n\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER)\n    if (name.type !== 'Value') throw new Error('name must be string')\n\n    const value = p.process(EXPR_BUILDER)\n    return {\n      type: 'ObjectAttributeValue',\n      name: name.value,\n      value: value,\n    }\n  },\n\n  object_splat(p): ObjectSplatNode {\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectSplat',\n      value,\n    }\n  },\n\n  object_splat_this(): ObjectSplatNode {\n    return {\n      type: 'ObjectSplat',\n      value: {type: 'This'},\n    }\n  },\n}\n\nconst TRAVERSE_BUILDER: MarkVisitor<(rhs: TraversalResult | null) => TraversalResult> = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER)\n\n    const value = tryConstantEvaluate(expr)\n    if (value && value.type === 'number') {\n      return (right) =>\n        traverseElement((base) => ({type: 'AccessElement', base, index: value.data}), right)\n    }\n\n    if (value && value.type === 'string') {\n      return (right) =>\n        traversePlain((base) => ({type: 'AccessAttribute', base, name: value.data}), right)\n    }\n\n    return (right) =>\n      traverseArray(\n        (base) => ({\n          type: 'Filter',\n          base,\n          expr,\n        }),\n        right,\n      )\n  },\n\n  slice(p) {\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n\n    const leftValue = tryConstantEvaluate(left)\n    const rightValue = tryConstantEvaluate(right)\n\n    if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n      throw new GroqQueryError('slicing must use constant numbers')\n    }\n\n    return (rhs) =>\n      traverseArray(\n        (base) => ({\n          type: 'Slice',\n          base,\n          left: leftValue.data,\n          right: rightValue.data,\n          isInclusive,\n        }),\n        rhs,\n      )\n  },\n\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER)\n    return (right) =>\n      traverseProjection((base) => ({type: 'Projection', base: base, expr: obj}), right)\n  },\n\n  attr_access(p) {\n    const name = p.processString()\n\n    return (right) => traversePlain((base) => ({type: 'AccessAttribute', base, name}), right)\n  },\n\n  deref(p) {\n    let attr: string | null = null\n\n    if (p.getMark().name === 'deref_attr') {\n      p.shift()\n      attr = p.processString()\n    }\n\n    const wrap = (base: ExprNode): ExprNode =>\n      attr ? {type: 'AccessAttribute', base, name: attr} : base\n\n    return (right) =>\n      traversePlain(\n        (base) =>\n          wrap({\n            type: 'Deref',\n            base,\n          }),\n        right,\n      )\n  },\n\n  array_postfix() {\n    return (right) => traverseArray((base) => ({type: 'ArrayCoerce', base}), right)\n  },\n}\n\nconst SELECTOR_BUILDER: MarkVisitor<null> = {\n  group(p) {\n    p.process(SELECTOR_BUILDER)\n    return null\n  },\n\n  everything() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  this() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  parent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  dblparent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  traverse(p) {\n    p.process(SELECTOR_BUILDER)\n    while (p.getMark().name !== 'traversal_end') {\n      p.process(TRAVERSE_BUILDER)\n    }\n\n    p.shift()\n    return null\n  },\n\n  this_attr(p) {\n    p.processString()\n    return null\n  },\n\n  neg() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pos() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  add() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sub() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mul() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  div() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mod() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pow() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  comp() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  in_range() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  str() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  integer() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  float() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sci() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  object() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  array() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  tuple() {\n    // This should only throw an error until we add support for tuples in selectors.\n    throw new Error('Invalid selector syntax')\n  },\n\n  func_call(p, mark) {\n    const func = EXPR_BUILDER['func_call'](p, mark) as FuncCallNode\n    if (func.name === 'anywhere' && func.args.length === 1) return null\n\n    throw new Error('Invalid selector syntax')\n  },\n\n  pipecall() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pair() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  and() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  or() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  not() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  asc() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  desc() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  param() {\n    throw new Error('Invalid selector syntax')\n  },\n}\n\nfunction extractPropertyKey(node: ExprNode): string {\n  if (node.type === 'AccessAttribute' && !node.base) {\n    return node.name\n  }\n\n  if (\n    node.type === 'PipeFuncCall' ||\n    node.type === 'Deref' ||\n    node.type === 'Map' ||\n    node.type === 'Projection' ||\n    node.type === 'Slice' ||\n    node.type === 'Filter' ||\n    node.type === 'AccessElement' ||\n    node.type === 'ArrayCoerce' ||\n    node.type === 'Group'\n  ) {\n    return extractPropertyKey(node.base)\n  }\n\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`)\n}\n\nfunction validateArity(name: string, arity: GroqFunctionArity, count: number) {\n  if (typeof arity === 'number') {\n    if (count !== arity) {\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`,\n      )\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`)\n    }\n  }\n}\n\nfunction argumentShouldBeSelector(namespace: string, functionName: string, argCount: number) {\n  const functionsRequiringSelectors = ['changedAny', 'changedOnly']\n\n  return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName)\n}\n\nclass GroqSyntaxError extends Error {\n  public position: number\n  public override name = 'GroqSyntaxError'\n\n  constructor(position: number) {\n    super(`Syntax error in GROQ query at position ${position}`)\n    this.position = position\n  }\n}\n\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nexport function parse(input: string, options: ParseOptions = {}): ExprNode {\n  const result = rawParse(input)\n  if (result.type === 'error') {\n    throw new GroqSyntaxError(result.position)\n  }\n  const processor = new MarkProcessor(input, result.marks as Mark[], options)\n  return processor.process(EXPR_BUILDER)\n}\n","import type {TypeNode} from './types'\n\nconst {compare} = new Intl.Collator('en')\nfunction typeNodesSorter(a: TypeNode, b: TypeNode): number {\n  if (a.type === 'null') {\n    return 1\n  }\n  return compare(hashField(a), hashField(b))\n}\n\nconst hashCache = new WeakMap<TypeNode, string>()\n\nexport function hashField(field: TypeNode): string {\n  if (hashCache.has(field)) {\n    return hashCache.get(field)!\n  }\n  const hash = calculateFieldHash(field)\n  hashCache.set(field, hash)\n  return hash\n}\n\nfunction calculateFieldHash(field: TypeNode): string {\n  switch (field.type) {\n    case 'string':\n    case 'number':\n    case 'boolean': {\n      if (field.value !== undefined) {\n        return `${field.type}(${field.value})`\n      }\n\n      return `${field.type}`\n    }\n\n    case 'null':\n    case 'unknown': {\n      return field.type\n    }\n\n    case 'array': {\n      return `${field.type}(${hashField(field.of)})`\n    }\n\n    case 'object': {\n      const attributes = Object.entries(field.attributes)\n      attributes.sort(([a], [b]) => compare(a, b)) // sort them by name\n      return `${field.type}:(${attributes\n        .map(\n          ([key, value]) =>\n            `${key}:${hashField(value.value)}(${value.optional ? 'optional' : 'non-optional'})`,\n        )\n        .join(',')}):ref-${field.dereferencesTo}:${field.rest ? hashField(field.rest) : 'no-rest'}`\n    }\n\n    case 'union': {\n      const sorted = [...field.of]\n      sorted.sort(typeNodesSorter)\n      return `${field.type}(${sorted.map(hashField).join(',')})`\n    }\n\n    case 'inline': {\n      return `${field.type}(${field.name})`\n    }\n\n    default: {\n      // @ts-expect-error - we should never reach this, make sure we cover all type cases\n      return field.type\n    }\n  }\n}\n\nexport function removeDuplicateTypeNodes(typeNodes: TypeNode[]): TypeNode[] {\n  const seenTypes = new Set<string>()\n  const newTypeNodes = []\n\n  const sortedTypeNodes = [...typeNodes]\n  sortedTypeNodes.sort(typeNodesSorter)\n\n  for (const typeNode of sortedTypeNodes) {\n    const hash = hashField(typeNode)\n    if (hash === null) {\n      newTypeNodes.push(typeNode)\n      continue\n    }\n    if (seenTypes.has(hash)) {\n      continue\n    }\n\n    seenTypes.add(hash)\n    newTypeNodes.push(typeNode)\n  }\n\n  return newTypeNodes\n}\n\nexport function optimizeUnions(field: TypeNode): TypeNode {\n  if (field.type === 'union') {\n    if (field.of.length === 0) {\n      return field\n    }\n\n    field.of = removeDuplicateTypeNodes(field.of)\n\n    if (field.of.length === 1) {\n      return optimizeUnions(field.of[0])\n    }\n\n    // flatten union\n    for (let idx = 0; field.of.length > idx; idx++) {\n      const subField = field.of[idx]\n      if (subField.type === 'union') {\n        field.of.splice(idx, 1, ...subField.of)\n        idx--\n        continue\n      }\n\n      field.of[idx] = optimizeUnions(subField)\n    }\n\n    field.of.sort((a, b) => {\n      if (a.type === 'null') {\n        return 1\n      }\n      return compare(hashField(a), hashField(b))\n    })\n\n    return field\n  }\n\n  if (field.type === 'array') {\n    field.of = optimizeUnions(field.of)\n    return field\n  }\n\n  if (field.type === 'object') {\n    for (const idx in field.attributes) {\n      if (!Object.hasOwn(field.attributes, idx)) {\n        continue\n      }\n\n      field.attributes[idx].value = optimizeUnions(field.attributes[idx].value)\n    }\n    return field\n  }\n\n  return field\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {optimizeUnions} from './optimizations'\nimport type {Scope} from './scope'\nimport type {\n  ArrayTypeNode,\n  BooleanTypeNode,\n  InlineTypeNode,\n  NullTypeNode,\n  NumberTypeNode,\n  ObjectAttribute,\n  ObjectTypeNode,\n  StringTypeNode,\n  TypeNode,\n  UnionTypeNode,\n  UnknownTypeNode,\n} from './types'\n\n/**\n * createReferenceTypeNode creates a ObjectTypeNode representing a reference type\n * it adds required attributes for a reference type.\n * @param name - The name of the reference type\n * @param inArray - Whether the reference is in an array\n * @returns A ObjectTypeNode representing a reference type\n * @internal\n */\nexport function createReferenceTypeNode(name: string, inArray: boolean = false): ObjectTypeNode {\n  const attributes: Record<string, ObjectAttribute> = {\n    _ref: {\n      type: 'objectAttribute',\n      value: {\n        type: 'string',\n      },\n    },\n    _type: {\n      type: 'objectAttribute',\n      value: {\n        type: 'string',\n        value: 'reference',\n      },\n    },\n    _weak: {\n      type: 'objectAttribute',\n      value: {\n        type: 'boolean',\n      },\n      optional: true,\n    },\n  }\n\n  if (inArray) {\n    attributes['_key'] = {\n      type: 'objectAttribute',\n      value: {\n        type: 'string',\n      },\n    } satisfies ObjectAttribute\n  }\n\n  return {\n    type: 'object',\n    attributes,\n    dereferencesTo: name,\n  } satisfies ObjectTypeNode\n}\n\nexport function nullUnion(node: TypeNode): UnionTypeNode {\n  if (node.type === 'union') {\n    return unionOf(...node.of, {type: 'null'})\n  }\n\n  return unionOf(node, {type: 'null'})\n}\n\nexport function unionOf(...nodes: TypeNode[]): UnionTypeNode {\n  return {\n    type: 'union',\n    of: nodes,\n  } satisfies UnionTypeNode\n}\n\nexport type ConcreteTypeNode =\n  | BooleanTypeNode\n  | NullTypeNode\n  | NumberTypeNode\n  | StringTypeNode\n  | ArrayTypeNode\n  | ObjectTypeNode\n\nexport function resolveInline(node: TypeNode, scope: Scope): Exclude<TypeNode, InlineTypeNode> {\n  if (node.type === 'inline') {\n    const resolvedInline = scope.context.lookupTypeDeclaration(node)\n    return resolveInline(resolvedInline, scope)\n  }\n\n  return node\n}\n\n/**\n * mapNode extracts either a _concrete type_ OR an _unknown type_ from a type node, applies the mapping\n * function to it and returns. Most notably, this will work through unions\n * (applying the mapping function for each variant) and inline (resolving the\n * reference).\n **/\nexport function mapNode<T extends TypeNode = TypeNode>(\n  node: TypeNode,\n  scope: Scope,\n  mapper: (node: ConcreteTypeNode | UnknownTypeNode) => T,\n  mergeUnions: (nodes: TypeNode[]) => TypeNode = (nodes) =>\n    optimizeUnions({type: 'union', of: nodes}),\n): TypeNode {\n  switch (node.type) {\n    case 'boolean':\n    case 'array':\n    case 'null':\n    case 'object':\n    case 'string':\n    case 'number':\n    case 'unknown':\n      return mapper(node)\n    case 'union':\n      return mergeUnions(node.of.map((inner) => mapNode(inner, scope, mapper), mergeUnions))\n    case 'inline': {\n      const resolvedInline = resolveInline(node, scope)\n      return mapNode(resolvedInline, scope, mapper, mergeUnions)\n    }\n    default:\n      // @ts-expect-error - all types should be handled\n      throw new Error(`Unknown type: ${node.type}`)\n  }\n}\n\nexport function isFuncCall(node: ExprNode, name: string): boolean {\n  if (node.type === 'Group') {\n    return isFuncCall(node.base, name)\n  }\n\n  return node.type === 'FuncCall' && `${node.namespace}::${node.name}` === name\n}\n","import type {Scope} from './scope'\nimport {nullUnion, resolveInline} from './typeHelpers'\nimport type {TypeNode} from './types'\n\ntype BooleanInterpretation = {\n  canBeTrue: boolean\n  canBeFalse: boolean\n  canBeNull: boolean\n}\n\n/**\n * booleanValue takes a TypeNode and returns a BooleanInterpretation.\n * BooleanInterpretation is a matrix of three booleans:\n * - canBeTrue: whether the TypeNode can resolve to true\n * - canBeFalse: whether the TypeNode can resolve to false\n * - canBeNull: whether the TypeNode can resolve to null\n * This is a helper method intended to determine the possible values of a boolean expression.\n * When resolving a boolean expression, we might not be able to determine the exact value of the expression,\n * but we can determine the possible values of the expression, Multiple values can be true at the same time.\n *\n * @param node - The TypeNode to evaluate\n * @returns BooleanInterpretation\n * @internal\n */\nexport function booleanValue(node: TypeNode, scope: Scope): BooleanInterpretation {\n  switch (node.type) {\n    case 'unknown': {\n      return {canBeTrue: true, canBeFalse: true, canBeNull: true}\n    }\n    case 'boolean': {\n      if (node.value === true) {\n        return {canBeTrue: true, canBeFalse: false, canBeNull: false}\n      }\n      if (node.value === false) {\n        return {canBeTrue: false, canBeFalse: true, canBeNull: false}\n      }\n\n      return {canBeTrue: true, canBeFalse: true, canBeNull: false}\n    }\n    case 'union': {\n      const value = {canBeTrue: false, canBeFalse: false, canBeNull: false}\n      for (const sub of node.of) {\n        const match = booleanValue(sub, scope)\n        if (match.canBeNull) {\n          value.canBeNull = true\n        }\n        if (match.canBeTrue) {\n          value.canBeTrue = true\n        }\n        if (match.canBeFalse) {\n          value.canBeFalse = true\n        }\n      }\n      return value\n    }\n    case 'inline': {\n      const resolved = resolveInline(node, scope)\n      return booleanValue(resolved, scope)\n    }\n    case 'null':\n    case 'string':\n    case 'number':\n    case 'object':\n    case 'array': {\n      return {canBeTrue: false, canBeFalse: false, canBeNull: true}\n    }\n    default: {\n      // @ts-expect-error - we should have handled all cases\n      throw new Error(`unknown node type ${node.type}`)\n    }\n  }\n}\n\nexport function booleanOr(\n  left: BooleanInterpretation,\n  right: BooleanInterpretation,\n): BooleanInterpretation {\n  // If either side can only be true, the expression can only be true, so we short-circuit\n  if (left.canBeTrue && !left.canBeFalse && !left.canBeNull) return left\n  if (right.canBeTrue && !right.canBeFalse && !right.canBeNull) return right\n\n  return {\n    // Either side can be true for the expression to be true\n    canBeTrue: left.canBeTrue || right.canBeTrue,\n    // Both sides must be false for the expression to be false\n    canBeFalse: left.canBeFalse && right.canBeFalse,\n    // if either side can be null, the expression can be null if the other side can't only be true\n    canBeNull: left.canBeNull || right.canBeNull,\n  }\n}\n\nexport function booleanAnd(\n  left: BooleanInterpretation,\n  right: BooleanInterpretation,\n): BooleanInterpretation {\n  // If either side can only be fales, the expression can only be false, so we short-circuit\n  if (left.canBeFalse && !left.canBeTrue && !left.canBeNull) return left\n  if (right.canBeFalse && !right.canBeTrue && !right.canBeNull) return right\n\n  return {\n    // Both sides must be true for the expression to be true\n    canBeTrue: left.canBeTrue && right.canBeTrue,\n    // if either side can be false, the expression can be false\n    canBeFalse: left.canBeFalse || right.canBeFalse,\n    // if either side can be null, the expression can be null\n    canBeNull: left.canBeNull || right.canBeNull,\n  }\n}\n\nexport function booleanInterpretationToTypeNode(bool: BooleanInterpretation): TypeNode {\n  if (bool.canBeTrue) {\n    if (bool.canBeFalse) {\n      if (bool.canBeNull) {\n        return nullUnion({type: 'boolean'})\n      }\n      return {type: 'boolean'}\n    }\n    if (bool.canBeNull) {\n      return nullUnion({type: 'boolean', value: true})\n    }\n    return {type: 'boolean', value: true}\n  }\n\n  if (bool.canBeFalse) {\n    if (bool.canBeNull) {\n      return nullUnion({type: 'boolean', value: false})\n    }\n    return {type: 'boolean', value: false}\n  }\n  return {type: 'null'}\n}\n","import debug from 'debug'\n\nimport type {InlineTypeNode, NullTypeNode, Schema, TypeNode, UnionTypeNode} from './types'\n\nconst $trace = debug('typeEvaluator:scope:trace')\n$trace.log = console.log.bind(console) // eslint-disable-line no-console\n\nexport class Context {\n  readonly schema: Schema\n\n  constructor(schema: Schema) {\n    this.schema = schema\n  }\n\n  lookupRef(refTo: string): TypeNode {\n    for (const val of this.schema) {\n      if (val.type === 'document') {\n        if (val.name === refTo) {\n          return {\n            type: 'object',\n            attributes: val.attributes,\n          }\n        }\n      }\n    }\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  lookupTypeDeclaration(alias: InlineTypeNode): TypeNode {\n    for (const val of this.schema) {\n      if (val.type === 'type') {\n        if (val.name === alias.name) {\n          return val.value\n        }\n      }\n    }\n    return {type: 'null'} satisfies NullTypeNode\n  }\n}\n\nexport class Scope {\n  public value: UnionTypeNode\n  public parent: Scope | undefined\n  public context: Context\n  public isHidden: boolean\n\n  constructor(value: TypeNode[], parent?: Scope, context?: Context) {\n    this.value = {type: 'union', of: value} satisfies UnionTypeNode\n    this.parent = parent\n    this.context = context || parent?.context || new Context([])\n    this.isHidden = false\n  }\n\n  createNested(value: TypeNode[]): Scope {\n    if (this.isHidden) {\n      return new Scope(value, this.parent, this.context)\n    }\n    return new Scope(value, this, this.context)\n  }\n\n  createHidden(value: TypeNode[]): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n","/* eslint-disable max-statements */\nimport type {FuncCallNode} from '../nodeTypes'\nimport {optimizeUnions} from './optimizations'\nimport {Scope} from './scope'\nimport {walk} from './typeEvaluate'\nimport {mapNode, nullUnion} from './typeHelpers'\nimport type {NullTypeNode, TypeNode} from './types'\n\nfunction unionWithoutNull(unionTypeNode: TypeNode): TypeNode {\n  if (unionTypeNode.type === 'union') {\n    return {\n      type: 'union',\n      of: unionTypeNode.of.filter((type) => type.type !== 'null'),\n    }\n  }\n  return unionTypeNode\n}\n\n// eslint-disable-next-line complexity\nexport function handleFuncCallNode(node: FuncCallNode, scope: Scope): TypeNode {\n  switch (`${node.namespace}.${node.name}`) {\n    case 'array.compact': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'array', of: {type: 'unknown'}})\n        }\n        if (arg.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        const of = mapNode(arg.of, scope, (of) => of)\n        return {\n          type: 'array',\n          of: unionWithoutNull(of),\n        }\n      })\n    }\n\n    case 'array.join': {\n      const arrayArg = walk({node: node.args[0], scope})\n      const sepArg = walk({node: node.args[1], scope})\n\n      return mapNode(arrayArg, scope, (arrayArg) =>\n        mapNode(sepArg, scope, (sepArg) => {\n          if (arrayArg.type === 'unknown' || sepArg.type === 'unknown') {\n            return nullUnion({type: 'string'})\n          }\n          if (arrayArg.type !== 'array' || sepArg.type !== 'string') {\n            return {type: 'null'}\n          }\n\n          return mapNode(arrayArg.of, scope, (of) => {\n            if (of.type === 'unknown') {\n              return nullUnion({type: 'string'})\n            }\n            // we can only join strings, numbers, and booleans\n            if (of.type !== 'string' && of.type !== 'number' && of.type !== 'boolean') {\n              return {type: 'null'}\n            }\n\n            return {type: 'string'}\n          })\n        }),\n      )\n    }\n\n    case 'array.unique': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'array', of: {type: 'unknown'}})\n        }\n        if (arg.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        return arg\n      })\n    }\n\n    case 'array.intersects': {\n      const arg1 = walk({node: node.args[0], scope})\n      const arg2 = walk({node: node.args[1], scope})\n\n      return mapNode(arg1, scope, (arg1) =>\n        mapNode(arg2, scope, (arg2) => {\n          if (arg1.type !== 'array') {\n            return {type: 'null'}\n          }\n\n          if (arg2.type !== 'array') {\n            return {type: 'null'}\n          }\n\n          return {type: 'boolean'}\n        }),\n      )\n    }\n\n    case 'global.lower': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type !== 'string') {\n          return {type: 'null'}\n        }\n        if (arg.value !== undefined) {\n          return {\n            type: 'string',\n            value: arg.value.toLowerCase(),\n          }\n        }\n        return {type: 'string'}\n      })\n    }\n    case 'global.upper': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n        if (arg.type !== 'string') {\n          return {type: 'null'}\n        }\n        if (arg.value !== undefined) {\n          return {\n            type: 'string',\n            value: arg.value.toUpperCase(),\n          }\n        }\n        return {type: 'string'}\n      })\n    }\n    case 'dateTime.now': {\n      return {type: 'string'}\n    }\n    case 'global.now': {\n      return {type: 'string'}\n    }\n    case 'global.defined': {\n      const arg = walk({node: node.args[0], scope})\n      return mapNode(arg, scope, (node) => {\n        if (node.type === 'unknown') {\n          return {type: 'boolean'}\n        }\n\n        return {type: 'boolean', value: node.type !== 'null'}\n      })\n    }\n    case 'global.path': {\n      const arg = walk({node: node.args[0], scope})\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type === 'string') {\n          return {type: 'string'}\n        }\n\n        return {type: 'null'}\n      })\n    }\n    case 'global.coalesce': {\n      if (node.args.length === 0) {\n        return {type: 'null'} satisfies NullTypeNode\n      }\n      const typeNodes: TypeNode[] = []\n      let canBeNull = true\n      for (const arg of node.args) {\n        const argNode = optimizeUnions(walk({node: arg, scope}))\n\n        // Check if all types are null\n        const allNull =\n          argNode.type === 'null' ||\n          (argNode.type === 'union' && argNode.of.every((t) => t.type === 'null'))\n\n        // Can the argument be null, if all is null, unknown, or if its a union with at least one null or unknown\n        canBeNull =\n          allNull ||\n          argNode.type === 'unknown' ||\n          (argNode.type === 'union' &&\n            argNode.of.some((t) => t.type === 'null' || t.type === 'unknown'))\n\n        // As long as some type is not null or unknown, we add it to the union, but skip nulls\n        if (!allNull) {\n          typeNodes.push(unionWithoutNull(argNode))\n        }\n\n        // If we have a type that can't be null, we can break.\n        if (!canBeNull) {\n          break\n        }\n      }\n\n      // If the last argument can be null, we add null to the union\n      if (canBeNull) {\n        typeNodes.push({type: 'null'} satisfies NullTypeNode)\n      }\n\n      return {\n        type: 'union',\n        of: typeNodes,\n      }\n    }\n\n    case 'global.count': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type === 'array') {\n          return {type: 'number'}\n        }\n\n        return {type: 'null'} satisfies NullTypeNode\n      })\n    }\n\n    case 'global.dateTime': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type === 'string') {\n          return nullUnion({type: 'string'}) // we don't know wether the string is a valid date or not, so we return a [null, string]-union\n        }\n\n        return {type: 'null'} satisfies NullTypeNode\n      })\n    }\n\n    case 'global.length': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n        if (arg.type === 'array' || arg.type === 'string') {\n          return {type: 'number'}\n        }\n\n        return {type: 'null'}\n      })\n    }\n\n    case 'global.references': {\n      return {type: 'boolean'}\n    }\n\n    case 'global.round': {\n      const numNode = walk({node: node.args[0], scope})\n\n      return mapNode(numNode, scope, (num) => {\n        if (num.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        if (num.type !== 'number') {\n          return {type: 'null'}\n        }\n        if (node.args.length === 2) {\n          const precisionNode = walk({node: node.args[1], scope})\n          return mapNode(precisionNode, scope, (precision) => {\n            if (precision.type === 'unknown') {\n              return nullUnion({type: 'number'})\n            }\n\n            if (precision.type !== 'number') {\n              return {type: 'null'}\n            }\n\n            return {type: 'number'}\n          })\n        }\n\n        return {type: 'number'}\n      })\n    }\n\n    case 'global.string': {\n      const arg = walk({node: node.args[0], scope})\n      return mapNode(arg, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (node.type === 'string' || node.type === 'number' || node.type === 'boolean') {\n          if (node.value) {\n            return {\n              type: 'string',\n              value: node.value.toString(),\n            }\n          }\n\n          return {\n            type: 'string',\n          }\n        }\n\n        return {type: 'null'}\n      })\n    }\n\n    case 'math.sum': {\n      const values = walk({node: node.args[0], scope})\n      // use mapNode to get concrete resolved value, it will also handle cases where the value is a union\n      return mapNode(values, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        // Aggregate functions can only be applied to arrays\n        if (node.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        // Resolve the concrete type of the array elements\n        return mapNode(node.of, scope, (node) => {\n          if (node.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n\n          // Math functions can only be applied to numbers, but we should also ignore nulls\n          if (node.type === 'number' || node.type === 'null') {\n            return {type: 'number'}\n          }\n          return {type: 'null'}\n        })\n      })\n    }\n\n    case 'math.avg': {\n      const values = walk({node: node.args[0], scope})\n      // use mapNode to get concrete resolved value, it will also handle cases where the value is a union\n      return mapNode(values, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        // Aggregate functions can only be applied to arrays\n        if (node.type !== 'array') {\n          return {type: 'null'}\n        }\n        // Resolve the concrete type of the array elements\n        return mapNode(node.of, scope, (node) => {\n          if (node.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n\n          // Math functions can only be applied to numbers\n          if (node.type === 'number') {\n            return {type: 'number'}\n          }\n          return {type: 'null'}\n        })\n      })\n    }\n\n    case 'math.max':\n    case 'math.min': {\n      const values = walk({node: node.args[0], scope})\n      // use mapNode to get concrete resolved value, it will also handle cases where the value is a union\n      return mapNode(values, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        // Aggregate functions can only be applied to arrays\n        if (node.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        // Resolve the concrete type of the array elements\n        return mapNode(node.of, scope, (node) => {\n          if (node.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n\n          // Math functions can only be applied to numbers\n          if (node.type === 'number') {\n            return node\n          }\n          return {type: 'null'}\n        })\n      })\n    }\n\n    case 'pt.text': {\n      if (node.args.length === 0) {\n        return {type: 'null'} satisfies NullTypeNode\n      }\n      return {\n        type: 'string',\n      }\n    }\n\n    case 'string.startsWith': {\n      const strTypeNode = walk({node: node.args[0], scope})\n      const prefixTypeNode = walk({node: node.args[1], scope})\n      return mapNode(strTypeNode, scope, (strNode) => {\n        return mapNode(prefixTypeNode, scope, (prefixNode) => {\n          if (strNode.type === 'unknown' || prefixNode.type === 'unknown') {\n            return nullUnion({type: 'boolean'})\n          }\n\n          if (strNode.type !== 'string' || prefixNode.type !== 'string') {\n            return {type: 'null'}\n          }\n\n          return {type: 'boolean'}\n        })\n      })\n    }\n    case 'string.split': {\n      const strTypeNode = walk({node: node.args[0], scope})\n      const sepTypeNode = walk({node: node.args[1], scope})\n      return mapNode(strTypeNode, scope, (strNode) => {\n        return mapNode(sepTypeNode, scope, (sepNode) => {\n          if (strNode.type === 'unknown' || sepNode.type === 'unknown') {\n            return nullUnion({type: 'array', of: {type: 'string'}})\n          }\n\n          if (strNode.type !== 'string' || sepNode.type !== 'string') {\n            return {type: 'null'}\n          }\n\n          return {type: 'array', of: {type: 'string'}}\n        })\n      })\n    }\n    case 'sanity.versionOf': {\n      const typeNode = walk({node: node.args[0], scope})\n      return mapNode(typeNode, scope, (typeNode) => {\n        if (typeNode.type === 'unknown') {\n          return nullUnion({type: 'array', of: {type: 'string'}})\n        }\n        if (typeNode.type !== 'string') {\n          return {type: 'null'}\n        }\n        return {type: 'array', of: {type: 'string'}}\n      })\n    }\n    case 'sanity.partOfRelease': {\n      const typeNode = walk({node: node.args[0], scope})\n      return mapNode(typeNode, scope, (typeNode) => {\n        if (typeNode.type === 'unknown') {\n          return nullUnion({type: 'array', of: {type: 'string'}})\n        }\n\n        if (typeNode.type !== 'string') {\n          return {type: 'null'}\n        }\n        return {type: 'array', of: {type: 'string'}}\n      })\n    }\n    default: {\n      return {type: 'unknown'}\n    }\n  }\n}\n","import {\n  matchAnalyzePattern,\n  matchText,\n  matchTokenize,\n  type Pattern,\n  type Token,\n} from '../evaluator/matching'\nimport type {ConcreteTypeNode} from './typeHelpers'\n\nexport function match(left: ConcreteTypeNode, right: ConcreteTypeNode): boolean | undefined {\n  let tokens: Token[] = []\n  let patterns: Pattern[] = []\n  if (left.type === 'string') {\n    if (left.value === undefined) {\n      return undefined\n    }\n    tokens = tokens.concat(matchTokenize(left.value))\n  }\n  if (left.type === 'array') {\n    if (left.of.type === 'unknown') {\n      return undefined\n    }\n    if (left.of.type === 'string') {\n      // eslint-disable-next-line max-depth\n      if (left.of.value === undefined) {\n        return undefined\n      }\n\n      tokens = tokens.concat(matchTokenize(left.of.value))\n    }\n    if (left.of.type === 'union') {\n      // eslint-disable-next-line max-depth\n      for (const node of left.of.of) {\n        // eslint-disable-next-line max-depth\n        if (node.type === 'string' && node.value !== undefined) {\n          tokens = tokens.concat(matchTokenize(node.value))\n        }\n      }\n    }\n  }\n\n  if (right.type === 'string') {\n    if (right.value === undefined) {\n      return undefined\n    }\n    patterns = patterns.concat(matchAnalyzePattern(right.value))\n  }\n  if (right.type === 'array') {\n    if (right.of.type === 'unknown') {\n      return undefined\n    }\n    if (right.of.type === 'string') {\n      // eslint-disable-next-line max-depth\n      if (right.of.value === undefined) {\n        return undefined\n      }\n      patterns = patterns.concat(matchAnalyzePattern(right.of.value))\n    }\n    if (right.of.type === 'union') {\n      // eslint-disable-next-line max-depth\n      for (const node of right.of.of) {\n        // eslint-disable-next-line max-depth\n        if (node.type === 'string') {\n          // eslint-disable-next-line max-depth\n          if (node.value === undefined) {\n            return undefined\n          }\n          patterns = patterns.concat(matchAnalyzePattern(node.value))\n        }\n\n        // eslint-disable-next-line max-depth\n        if (node.type !== 'string') {\n          return false\n        }\n      }\n    }\n  }\n  return matchText(tokens, patterns)\n}\n","import debug from 'debug'\n\nimport type {\n  AccessAttributeNode,\n  AccessElementNode,\n  AndNode,\n  ArrayCoerceNode,\n  ArrayNode,\n  DerefNode,\n  EverythingNode,\n  ExprNode,\n  FilterNode,\n  FlatMapNode,\n  MapNode,\n  NegNode,\n  NotNode,\n  ObjectConditionalSplatNode,\n  ObjectNode,\n  ObjectSplatNode,\n  OpCall,\n  OpCallNode,\n  OrNode,\n  ParentNode,\n  PosNode,\n  ProjectionNode,\n  SelectNode,\n  SliceNode,\n  ValueNode,\n} from '../nodeTypes'\nimport {booleanAnd, booleanInterpretationToTypeNode, booleanOr, booleanValue} from './booleans'\nimport {handleFuncCallNode} from './functions'\nimport {match} from './matching'\nimport {optimizeUnions} from './optimizations'\nimport {Context, Scope} from './scope'\nimport {isFuncCall, mapNode, nullUnion, resolveInline} from './typeHelpers'\nimport type {\n  ArrayTypeNode,\n  BooleanTypeNode,\n  Document,\n  NullTypeNode,\n  NumberTypeNode,\n  ObjectAttribute,\n  ObjectTypeNode,\n  PrimitiveTypeNode,\n  Schema,\n  StringTypeNode,\n  TypeNode,\n  UnionTypeNode,\n  UnknownTypeNode,\n} from './types'\n\nconst $trace = debug('typeEvaluator:evaluate:trace')\n$trace.log = console.log.bind(console) // eslint-disable-line no-console\n// log to stdout\nconst $debug = debug('typeEvaluator:evaluate:debug')\n// log to stdout\n$debug.log = console.log.bind(console) // eslint-disable-line no-console\nconst $warn = debug('typeEvaluator:evaluate:warn')\n\n/**\n * Evaluates the type of a query and schema.\n *\n * @param ast - The query ast to evaluate.\n * @param schema - The schemas to use for type evaluation.\n * @returns The type of the query.\n * @beta\n */\nexport function typeEvaluate(ast: ExprNode, schema: Schema): TypeNode {\n  $debug('evaluateQueryType.ast %O', ast)\n  $debug('evaluateQueryType.schema %O', schema)\n  const parsed = walk({\n    node: ast,\n    scope: new Scope([], undefined, new Context(schema)),\n  })\n\n  $trace('evaluateQueryType.parsed %O', parsed)\n  const optimized = optimizeUnions(parsed)\n  $debug('evaluateQueryType.optimized %O', optimized)\n\n  return optimized\n}\n\nfunction mapDeref(base: TypeNode, scope: Scope): TypeNode {\n  if (base.type === 'union') {\n    return {\n      type: 'union',\n      of: base.of.map((node) => mapDeref(node, scope)),\n    }\n  }\n\n  if (base.type === 'array') {\n    return {\n      type: 'array',\n      of: mapDeref(base.of, scope),\n    }\n  }\n\n  if (base.type === 'object' && base.dereferencesTo !== undefined) {\n    return scope.context.lookupRef(base.dereferencesTo)\n  }\n\n  return {type: 'null'}\n}\n\nfunction handleDerefNode(node: DerefNode, scope: Scope): TypeNode {\n  $trace('deref.node %O', node)\n  const base = walk({node: node.base, scope})\n  $trace('deref.base %O', base)\n\n  if (base.type === 'null' || base.type === 'unknown') {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  const derefedNode = mapDeref(base, scope)\n  $trace('deref.derefedNode %O', derefedNode)\n\n  return derefedNode\n}\n\nfunction handleObjectSplatNode(\n  attr: ObjectSplatNode | ObjectConditionalSplatNode,\n  scope: Scope,\n): TypeNode {\n  const value = walk({node: attr.value, scope})\n  $trace('object.splat.value %O', value)\n  return mapNode(value, scope, (node) => {\n    // splatting over unknown is unknown, we can't know what the attributes are\n    if (node.type === 'unknown') {\n      return {type: 'unknown'}\n    }\n    // splatting over a non-object is a no-op\n    if (node.type !== 'object') {\n      return {type: 'object', attributes: {}}\n    }\n\n    const attributes: Record<string, ObjectAttribute> = {}\n    for (const name in node.attributes) {\n      if (!node.attributes.hasOwnProperty(name)) {\n        continue\n      }\n      attributes[name] = node.attributes[name]\n    }\n\n    if (node.rest !== undefined) {\n      // Rest is either an object, inline, or unknown - we need to resolve it if it's an inline\n      const resolvedRest = resolveInline(node.rest, scope)\n\n      // if the rest is unknown the entire object is unknown\n      if (resolvedRest.type === 'unknown') {\n        return {type: 'unknown'}\n      }\n      if (resolvedRest.type !== 'object') {\n        return {type: 'null'}\n      }\n      for (const name in resolvedRest.attributes) {\n        // eslint-disable-next-line\n        if (!resolvedRest.attributes.hasOwnProperty(name)) {\n          continue\n        }\n        attributes[name] = resolvedRest.attributes[name]\n      }\n    }\n    return {type: 'object', attributes}\n  })\n}\n\n// eslint-disable-next-line max-statements, complexity\nfunction handleObjectNode(node: ObjectNode, scope: Scope): TypeNode {\n  $trace('object.node %O', node)\n\n  if (node.attributes.length === 0) {\n    return {\n      type: 'object',\n      attributes: {},\n    } satisfies ObjectTypeNode\n  }\n\n  // let attributes we a entry of [name, value] or null. We need to keep track of nulls to handle conditional splats\n  // since we care about the order of the attributes. Later attribute keys will overwrite earlier ones.\n  const objectAttributes: [number, string, ObjectAttribute][] = []\n\n  const splatVariants: [number, ObjectTypeNode | UnionTypeNode<ObjectTypeNode>][] = []\n\n  // We keep track of conditional splats separately, since we need to merge them into an object or an union of objects at the end.\n  // keep track of the index of the conditional splat to be able to merge the attributes correctly.\n  const conditionalVariants: [number, UnionTypeNode<ObjectTypeNode>][] = []\n\n  for (const [idx, attr] of node.attributes.entries()) {\n    if (attr.type === 'ObjectAttributeValue') {\n      const attributeNode = walk({node: attr.value, scope})\n      objectAttributes.push([\n        idx,\n        attr.name,\n        {\n          type: 'objectAttribute',\n          value: attributeNode,\n        },\n      ])\n      continue\n    }\n\n    if (attr.type === 'ObjectSplat') {\n      const attributeNode = handleObjectSplatNode(attr, scope)\n      $trace('object.splat.result %O', attributeNode)\n      switch (attributeNode.type) {\n        case 'object': {\n          splatVariants.push([idx, attributeNode])\n          continue\n        }\n        case 'union': {\n          for (const node of attributeNode.of) {\n            // if one of the nodes is unknown we mark the entire object as unknown as we can't infer the type of the object\n            // eslint-disable-next-line max-depth\n            if (node.type === 'unknown') {\n              return node\n            }\n          }\n          splatVariants.push([idx, attributeNode as UnionTypeNode<ObjectTypeNode>])\n          continue\n        }\n        default: {\n          return {type: 'unknown'}\n        }\n      }\n    }\n\n    if (attr.type === 'ObjectConditionalSplat') {\n      const condition = booleanValue(walk({node: attr.condition, scope}), scope)\n      $trace('object.conditional.splat.condition %O', condition)\n      // condition is never met, skip this attribute\n      if (condition.canBeTrue === false) {\n        continue\n      }\n\n      const attributeNode = handleObjectSplatNode(attr, scope)\n      $trace('object.conditional.splat.result %O', attributeNode)\n      // condition is always met, we can treat this as a normal splat\n      if (condition.canBeFalse === false && condition.canBeNull === false) {\n        switch (attributeNode.type) {\n          case 'object': {\n            splatVariants.push([idx, attributeNode])\n            continue\n          }\n          case 'union': {\n            // eslint-disable-next-line max-depth\n            for (const node of attributeNode.of) {\n              // eslint-disable-next-line max-depth\n              if (node.type !== 'object') {\n                return {type: 'unknown'}\n              }\n            }\n            splatVariants.push([idx, attributeNode as UnionTypeNode<ObjectTypeNode>])\n            continue\n          }\n          default: {\n            return {type: 'unknown'}\n          }\n        }\n      }\n\n      const variant = mapNode(attributeNode, scope, (attributeNode) => {\n        $trace('object.conditional.splat.result.concrete %O', attributeNode)\n        if (attributeNode.type !== 'object') {\n          return {type: 'unknown'}\n        }\n\n        return {\n          type: 'object',\n          attributes: attributeNode.attributes,\n        } satisfies ObjectTypeNode\n      })\n\n      if (variant.type === 'union') {\n        for (const node of variant.of) {\n          // We can only splat objects, so we bail out if we encounter a non-object node.\n          // eslint-disable-next-line max-depth\n          if (node.type !== 'object') {\n            return {type: 'unknown'}\n          }\n        }\n        variant.of.push({type: 'object', attributes: {}} as ObjectTypeNode) // add an empty object to the union, since it's conditional\n        conditionalVariants.push([idx, variant as UnionTypeNode<ObjectTypeNode>])\n        continue\n      }\n      // If the variant is not an object or a union of objects, we bail out early.\n      if (variant.type !== 'object') {\n        return {type: 'unknown'}\n      }\n\n      conditionalVariants.push([\n        idx,\n        {\n          type: 'union',\n          of: [{type: 'object', attributes: {}}, variant],\n        },\n      ])\n      continue\n    }\n\n    // @ts-expect-error - we should have handled all cases of ObjectAttributeNode\n    throw new Error(`Unknown object attribute type: ${attr.type}`)\n  }\n\n  const guaranteedAttributes: [number, string, ObjectAttribute<TypeNode>][] = []\n  guaranteedAttributes.push(...objectAttributes)\n\n  for (const [idx, splatNode] of splatVariants) {\n    if (splatNode.type === 'object') {\n      for (const name in splatNode.attributes) {\n        if (!splatNode.attributes.hasOwnProperty(name)) {\n          continue\n        }\n        const attribute = splatNode.attributes[name]\n        guaranteedAttributes.push([idx, name, attribute])\n      }\n      continue\n    }\n\n    // it's a union of objects, so we keep this as a conditional variant\n    conditionalVariants.push([idx, splatNode])\n  }\n\n  // make sure they are sorted from lowest index to highest, this ensures that\n  // attributes with a higher index overwrite attributes with a lower index.\n  guaranteedAttributes.sort(([a], [b]) => a - b)\n\n  // If we have no conditional variants, we can just return the object with the guaranteed attributes.\n  if (conditionalVariants.length === 0) {\n    return {\n      type: 'object',\n      attributes: Object.fromEntries(\n        guaranteedAttributes.map(([, name, attribute]) => [name, attribute]),\n      ),\n    } satisfies ObjectTypeNode\n  }\n\n  // matrix should be a result of if given we have variants [a,b,c] this would lead to a union of [a, a|b, a|c, a|b|c, b|c, c, {EMPTY}]\n  // if it's given we have variants A + [a|b|c] this would lead to a union of [Aa, Aa|Ab, Aa|Ac, Aa|Ab|Ac, Ab|Ac, Ac, A]\n  const matrix: (ObjectTypeNode | UnionTypeNode<ObjectTypeNode>)[] = []\n\n  for (const [unionIdx, union] of conditionalVariants) {\n    const unionGuaranteedBefore: [number, string, ObjectAttribute][] = []\n    const unionGuaranteedAfter: [number, string, ObjectAttribute][] = []\n\n    // Collect all guaranteed attributes before and after the conditional variant.\n    for (const [guaranteedIndex, name, attribute] of guaranteedAttributes) {\n      if (guaranteedIndex < unionIdx) {\n        unionGuaranteedBefore.push([guaranteedIndex, name, attribute])\n      }\n      if (guaranteedIndex > unionIdx) {\n        unionGuaranteedAfter.push([guaranteedIndex, name, attribute])\n      }\n    }\n\n    // build a map of variants from other conditions.\n    const allVariantsAttributes: [number, Record<string, ObjectAttribute>[]][] = []\n    for (const [conditionalVariantIdx, otherUnion] of conditionalVariants) {\n      // We need to build a matrix of all possible combinations of the attributes of the other variants.\n      // start with an empty object, since it's condtional.\n      const variantAttributes: Record<string, ObjectAttribute>[] = []\n      for (const node of otherUnion.of) {\n        variantAttributes.push(node.attributes)\n      }\n      allVariantsAttributes.push([conditionalVariantIdx, variantAttributes])\n    }\n\n    /* eslint-disable max-depth */\n    for (const node of union.of) {\n      matrix.push({\n        type: 'object',\n        attributes: {\n          ...Object.fromEntries(\n            unionGuaranteedBefore.map(([, name, attribute]) => [name, attribute]),\n          ),\n          ...node.attributes,\n          ...Object.fromEntries(\n            unionGuaranteedAfter.map(([, name, attribute]) => [name, attribute]),\n          ),\n        },\n      } satisfies ObjectTypeNode)\n\n      for (const [outerIdx, outerAttributes] of allVariantsAttributes) {\n        for (const outer of outerAttributes) {\n          for (const [innerIdx, innerAttributes] of allVariantsAttributes) {\n            if (outerIdx === innerIdx) {\n              continue\n            }\n\n            for (const inner of innerAttributes) {\n              const _before = [...unionGuaranteedBefore]\n              const _after = [...unionGuaranteedAfter]\n\n              for (const name in outer) {\n                if (!outer.hasOwnProperty(name)) {\n                  continue\n                }\n\n                if (outerIdx === unionIdx) {\n                  continue\n                }\n\n                if (outerIdx < unionIdx) {\n                  _before.push([outerIdx, name, outer[name]])\n                }\n\n                if (outerIdx > unionIdx) {\n                  _after.push([outerIdx, name, outer[name]])\n                }\n              }\n\n              for (const name in inner) {\n                if (!inner.hasOwnProperty(name)) {\n                  continue\n                }\n                if (outerIdx === unionIdx) {\n                  continue\n                }\n\n                if (innerIdx < unionIdx) {\n                  _before.push([innerIdx, name, inner[name]])\n                }\n\n                if (innerIdx > unionIdx) {\n                  _after.push([innerIdx, name, inner[name]])\n                }\n              }\n              _before.sort(([a], [b]) => a - b)\n              _after.sort(([a], [b]) => a - b)\n\n              const before: Record<string, ObjectAttribute> = Object.fromEntries(\n                _before.map(([, name, attribute]) => [name, attribute]),\n              )\n\n              const after: Record<string, ObjectAttribute> = Object.fromEntries(\n                _after.map(([, name, attribute]) => [name, attribute]),\n              )\n\n              matrix.push({\n                type: 'object',\n                attributes: {\n                  ...before,\n                  ...node.attributes,\n                  ...after,\n                },\n              })\n            }\n          }\n        }\n      }\n    }\n    /* eslint-disable max-depth */\n  }\n\n  return optimizeUnions({\n    type: 'union',\n    of: matrix,\n  })\n}\n\n// eslint-disable-next-line max-statements\nfunction handleOpCallNode(node: OpCallNode, scope: Scope): TypeNode {\n  $trace('opcall.node %O', node)\n  const lhs = walk({node: node.left, scope})\n  const rhs = walk({node: node.right, scope})\n  return mapNode(lhs, scope, (left) =>\n    // eslint-disable-next-line complexity, max-statements\n    mapNode(rhs, scope, (right) => {\n      $trace('opcall.node.concrete \"%s\" %O', node.op, {left, right})\n\n      switch (node.op) {\n        case '==': {\n          // == always returns a boolean, no matter the compared types.\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return {type: 'boolean'}\n          }\n          if (left.type !== right.type) {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          if (left.type === 'null') {\n            return {\n              type: 'boolean',\n              value: true,\n            } satisfies BooleanTypeNode\n          }\n          if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right)) {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          return {\n            type: 'boolean',\n            value: evaluateComparison(node.op, left, right),\n          } satisfies BooleanTypeNode\n        }\n        case '!=': {\n          // != always returns a boolean, no matter the compared types.\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return {type: 'boolean'}\n          }\n          if (left.type !== right.type) {\n            return {\n              type: 'boolean',\n              value: true,\n            } satisfies BooleanTypeNode\n          }\n          if (left.type === 'null') {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right)) {\n            return {\n              type: 'boolean',\n              value: true,\n            } satisfies BooleanTypeNode\n          }\n\n          let value = evaluateComparison('==', left, right)\n          if (value !== undefined) value = !value\n          return {\n            type: 'boolean',\n            value,\n          } satisfies BooleanTypeNode\n        }\n        case '>':\n        case '>=':\n        case '<':\n        case '<=': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'boolean'})\n          }\n          if (left.type !== right.type) {\n            return {type: 'null'} satisfies NullTypeNode\n          }\n          if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right)) {\n            return {type: 'null'} satisfies NullTypeNode\n          }\n          return {\n            type: 'boolean',\n            value: evaluateComparison(node.op, left, right),\n          } satisfies BooleanTypeNode\n        }\n        case 'in': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'boolean'})\n          }\n          if (right.type !== 'array') {\n            // Special case for global::path, since it can be used with in operator, but the type returned otherwise is a string\n            if (isFuncCall(node.right, 'global::path')) {\n              return {type: 'boolean'}\n            }\n            return {type: 'null'}\n          }\n          if (!isPrimitiveTypeNode(left) && left.type !== 'null') {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          return mapNode(right.of, scope, (arrayTypeNode) => {\n            if (arrayTypeNode.type === 'unknown') {\n              return nullUnion({type: 'boolean'})\n            }\n\n            if (left.type === 'null') {\n              return {\n                type: 'boolean',\n                value: arrayTypeNode.type === 'null',\n              } satisfies BooleanTypeNode\n            }\n\n            if (left.value === undefined) {\n              return {\n                type: 'boolean',\n              } satisfies BooleanTypeNode\n            }\n            if (isPrimitiveTypeNode(arrayTypeNode)) {\n              if (arrayTypeNode.value === undefined) {\n                return {\n                  type: 'boolean',\n                } satisfies BooleanTypeNode\n              }\n\n              return {\n                type: 'boolean',\n                value: left.value === arrayTypeNode.value,\n              } satisfies BooleanTypeNode\n            }\n\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          })\n        }\n        case 'match': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            // match always returns a boolean, no matter the compared types.\n            return {type: 'boolean'}\n          }\n          return {\n            type: 'boolean',\n            value: match(left, right),\n          } satisfies BooleanTypeNode\n        }\n        case '+': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            // + is ambiguous without the concrete types of the operands, so we return unknown and leave the excersise to the caller\n            return {type: 'unknown'}\n          }\n          if (left.type === 'string' && right.type === 'string') {\n            return {\n              type: 'string',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value + right.value\n                  : undefined,\n            }\n          }\n\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value + right.value\n                  : undefined,\n            }\n          }\n          if (left.type === 'array' && right.type === 'array') {\n            return {\n              type: 'array',\n              of: {\n                type: 'union',\n                of: [left.of, right.of],\n              },\n            } satisfies ArrayTypeNode\n          }\n          if (left.type === 'object' && right.type === 'object') {\n            return {\n              type: 'object',\n              attributes: {...left.attributes, ...right.attributes},\n            } satisfies ObjectTypeNode\n          }\n          return {type: 'null'}\n        }\n        case '-': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value - right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '*': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value * right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '/': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value / right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '**': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value ** right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '%': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value % right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        default: {\n          // TS only: make sure we handle all cases\n          node.op satisfies never\n\n          return {\n            type: 'unknown',\n          } satisfies UnknownTypeNode\n        }\n      }\n    }),\n  )\n}\n\nfunction handleSelectNode(node: SelectNode, scope: Scope): TypeNode {\n  const values: TypeNode[] = []\n  let guaranteed = false\n  for (const alternative of node.alternatives) {\n    const conditionValue = walk({node: alternative.condition, scope})\n    const conditionScope = resolveFilter(alternative.condition, scope)\n    if (conditionScope.type === 'union' && conditionScope.of.length > 0) {\n      values.push(walk({node: alternative.value, scope: scope.createHidden(conditionScope.of)}))\n    }\n    if (conditionValue.type === 'boolean' && conditionValue.value === true) {\n      guaranteed = true\n    }\n  }\n  if (node.fallback && !guaranteed) {\n    values.push(walk({node: node.fallback, scope}))\n  }\n  if (values.length === 0) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  return {\n    type: 'union',\n    of: values,\n  } satisfies UnionTypeNode\n}\n\nfunction handleArrayCoerceNode(node: ArrayCoerceNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('arrayCoerce.base %O', base)\n  return mapArray(base, scope, (base) => base)\n}\nfunction handleFlatMap(node: FlatMapNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapArray(base, scope, (base) => {\n    const inner = walk({node: node.expr, scope: scope.createHidden([base.of])})\n\n    return mapNode(\n      inner,\n      scope,\n      (inner) => {\n        if (inner.type === 'array') {\n          return inner\n        }\n\n        return {type: 'array', of: inner}\n      },\n      (nodes) => {\n        const inner: TypeNode[] = []\n        for (const node of nodes) {\n          // Bail out early if we've detected an unknown.\n          if (node.type === 'unknown') return {type: 'array', of: node}\n          // The mapper above ensures that all types returned are arrays.\n          if (node.type !== 'array') throw new Error(`Unexpected type: ${node.type}`)\n          inner.push(node.of)\n        }\n        return {\n          type: 'array',\n          of: optimizeUnions({type: 'union', of: inner}),\n        }\n      },\n    )\n  })\n}\nfunction handleMap(node: MapNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('map.base %O', base)\n\n  return mapArray(base, scope, (base) => {\n    return {\n      type: 'array',\n      of: walk({node: node.expr, scope: scope.createHidden([base.of])}),\n    }\n  })\n}\n\nfunction handleProjectionNode(node: ProjectionNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('projection.base %O', base)\n\n  return mapObject(base, scope, (base) =>\n    walk({node: node.expr, scope: scope.createNested([base])}),\n  )\n}\n\nfunction createFilterScope(base: TypeNode, scope: Scope): Scope {\n  if (base.type === 'array') {\n    if (base.of.type === 'union') {\n      return scope.createNested(base.of.of)\n    }\n    return scope.createNested([base.of])\n  }\n\n  return scope.createNested([base])\n}\nfunction handleFilterNode(node: FilterNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('filter.base %O', base)\n\n  return mapNode(base, scope, (base) => {\n    $trace('filter.resolving %O', base)\n    if (base.type === 'null') {\n      return base\n    }\n\n    const resolved = resolveFilter(node.expr, createFilterScope(base, scope))\n    $trace('filter.resolved %O', resolved)\n\n    return {\n      type: 'array',\n      of: resolved,\n    }\n  })\n}\n\nexport function handleAccessAttributeNode(node: AccessAttributeNode, scope: Scope): TypeNode {\n  let attributeBase: TypeNode = scope.value\n  if (node.base) {\n    attributeBase = walk({node: node.base, scope})\n  }\n\n  $trace('accessAttribute.base %s %O', node.name, attributeBase)\n  return handleAccessAttributeBase(attributeBase, node.name, scope)\n}\n\nfunction handleAccessAttributeBase(base: TypeNode, name: string, scope: Scope): TypeNode {\n  return mapObject(base, scope, (base) => {\n    $trace(`Looking for attribute \"%s\" in object %O`, name, base)\n\n    const attribute = base.attributes[name]\n    if (attribute !== undefined) {\n      $debug(`accessAttribute.attribute found ${name} %O`, attribute)\n      if (attribute.optional) {\n        return nullUnion(attribute.value)\n      }\n\n      return attribute.value\n    }\n\n    if (base.rest) {\n      return handleAccessAttributeBase(base.rest, name, scope)\n    }\n    $warn(`attribute \"${name}\" not found in object`)\n    return {type: 'null'}\n  })\n}\n\nfunction handleAccessElementNode(node: AccessElementNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('accessElement.base %O', base)\n  return mapArray(base, scope, (base) => nullUnion(base.of))\n}\n\nfunction handleArrayNode(node: ArrayNode, scope: Scope): TypeNode {\n  const of: TypeNode[] = []\n  for (const el of node.elements) {\n    const node = walk({node: el.value, scope})\n    if (node !== null) {\n      of.push(node)\n    }\n  }\n  return {\n    type: 'array',\n    of: {\n      type: 'union',\n      of,\n    } satisfies UnionTypeNode,\n  } satisfies ArrayTypeNode\n}\n\nfunction handleValueNode(node: ValueNode, scope: Scope): TypeNode {\n  if (node.value === null) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n  switch (typeof node.value) {\n    case 'string':\n      return {\n        type: 'string',\n        value: node.value,\n      } satisfies StringTypeNode\n    case 'number':\n      return {\n        type: 'number',\n        value: node.value,\n      } satisfies NumberTypeNode\n    case 'boolean':\n      return {\n        type: 'boolean',\n        value: node.value,\n      } satisfies BooleanTypeNode\n    case 'object':\n      if (node.value === null) {\n        return {type: 'null'} satisfies NullTypeNode\n      }\n      if (Array.isArray(node.value)) {\n        return {\n          type: 'array',\n          of: {\n            type: 'union',\n            of: node.value.map((value) => walk({node: {type: 'Value', value}, scope})),\n          },\n        } satisfies ArrayTypeNode\n      }\n      return {\n        type: 'object',\n        attributes: Object.fromEntries(\n          Object.entries(node.value).map(([key, value]) => [\n            key,\n            {\n              type: 'objectAttribute',\n              value: walk({node: {type: 'Value', value}, scope}),\n            },\n          ]),\n        ),\n      } satisfies ObjectTypeNode\n    default:\n      return {type: 'unknown'} satisfies UnknownTypeNode\n  }\n}\n\nfunction handleSlice(node: SliceNode, scope: Scope): TypeNode {\n  $trace('slice.node %O', node)\n  const base = walk({node: node.base, scope})\n  return mapArray(base, scope, (base) => base)\n}\n\nfunction handleParentNode({n}: ParentNode, scope: Scope): TypeNode {\n  $trace('handle.parent.currentScope %d %O', n, scope)\n\n  let current: Scope | undefined = scope\n  for (let i = 0; i < n; i++) {\n    // make sure we are not in a hidden scope\n    while (current?.isHidden) {\n      current = current.parent\n    }\n    current = current?.parent\n  }\n  $trace('handle.parent.newScope %d %O', n, current)\n\n  if (!current) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  if (current.value.of.length === 0) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  return current.value\n}\n\nfunction handleNotNode(node: NotNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapNode(base, scope, (base) => {\n    if (base.type === 'unknown') {\n      return nullUnion({type: 'boolean'})\n    }\n\n    if (base.type === 'boolean') {\n      if (base.value !== undefined) {\n        return {type: 'boolean', value: base.value === false}\n      }\n      return {type: 'boolean'}\n    }\n\n    return {type: 'null'}\n  })\n}\n\nfunction handleNegNode(node: NegNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapNode(base, scope, (base) => {\n    if (base.type === 'unknown') {\n      return nullUnion({type: 'number'})\n    }\n\n    if (base.type !== 'number') {\n      return {type: 'null'}\n    }\n    if (base.value !== undefined) {\n      return {type: 'number', value: -base.value}\n    }\n    return base\n  })\n}\nfunction handlePosNode(node: PosNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapNode(base, scope, (base) => {\n    if (base.type === 'unknown') {\n      return nullUnion({type: 'number'})\n    }\n    if (base.type !== 'number') {\n      return {type: 'null'}\n    }\n    return base\n  })\n}\n\nfunction handleEverythingNode(_: EverythingNode, scope: Scope): TypeNode {\n  return {\n    type: 'array',\n    of: {\n      type: 'union',\n      of: scope.context.schema\n        .filter((obj): obj is Document => obj.type === 'document')\n        .map((doc) => ({\n          type: 'object',\n          attributes: doc.attributes,\n        })),\n    },\n  } satisfies ArrayTypeNode<UnionTypeNode<ObjectTypeNode>>\n}\n\nfunction handleAndNode(node: AndNode, scope: Scope): TypeNode {\n  const left = walk({node: node.left, scope})\n  const right = walk({node: node.right, scope})\n  return mapNode(left, scope, (lhs) =>\n    mapNode(right, scope, (rhs) => {\n      const value = booleanAnd(booleanValue(lhs, scope), booleanValue(rhs, scope))\n\n      return booleanInterpretationToTypeNode(value)\n    }),\n  )\n}\n\nfunction handleOrNode(node: OrNode, scope: Scope): TypeNode {\n  const left = walk({node: node.left, scope})\n  const right = walk({node: node.right, scope})\n  return mapNode(left, scope, (lhs) =>\n    mapNode(right, scope, (rhs) => {\n      const value = booleanOr(booleanValue(lhs, scope), booleanValue(rhs, scope))\n\n      return booleanInterpretationToTypeNode(value)\n    }),\n  )\n}\n\nconst OVERRIDE_TYPE_SYMBOL = Symbol('groq-js.type')\n\n/**\n * `overrideTypeForNode` overrides the inferred type for a specific node: The\n * type evaluator will ignore its built-in logic and instead _always_ return\n * this type. This is intended to be used for testing.\n * @internal - This is only exported for testing purposes.\n */\nexport function overrideTypeForNode(node: ExprNode, type: TypeNode): void {\n  ;(node as any)[OVERRIDE_TYPE_SYMBOL] = type\n}\n\n/**\n * Walks through the AST and evaluates the type of each node.\n *\n * @param node - The AST node to evaluate.\n * @param scope - The current scope.\n * @returns The evaluated type of the node.\n * @internal\n */\n// eslint-disable-next-line complexity\nexport function walk({node, scope}: {node: ExprNode; scope: Scope}): TypeNode {\n  if (OVERRIDE_TYPE_SYMBOL in node) {\n    return node[OVERRIDE_TYPE_SYMBOL] as TypeNode\n  }\n\n  switch (node.type) {\n    // Filtering, traversal & projections\n    case 'Map': {\n      return handleMap(node, scope)\n    }\n    case 'Projection': {\n      return handleProjectionNode(node, scope)\n    }\n    case 'Filter': {\n      return handleFilterNode(node, scope)\n    }\n    case 'AccessAttribute': {\n      return optimizeUnions(handleAccessAttributeNode(node, scope))\n    }\n    case 'AccessElement': {\n      return handleAccessElementNode(node, scope)\n    }\n    case 'ArrayCoerce': {\n      return handleArrayCoerceNode(node, scope)\n    }\n    case 'FlatMap': {\n      return handleFlatMap(node, scope)\n    }\n\n    // Operations\n    case 'OpCall': {\n      return handleOpCallNode(node, scope)\n    }\n\n    case 'And': {\n      return handleAndNode(node, scope)\n    }\n\n    case 'Or': {\n      return handleOrNode(node, scope)\n    }\n\n    case 'Select': {\n      return handleSelectNode(node, scope)\n    }\n    case 'PipeFuncCall': {\n      return walk({node: node.base, scope})\n    }\n\n    // Values\n    case 'Deref': {\n      return handleDerefNode(node, scope)\n    }\n    case 'Object': {\n      return handleObjectNode(node, scope)\n    }\n    case 'Value': {\n      return handleValueNode(node, scope)\n    }\n    case 'Array': {\n      return handleArrayNode(node, scope)\n    }\n\n    // Special cases\n    case 'Everything': {\n      return handleEverythingNode(node, scope)\n    }\n\n    case 'This': {\n      $trace('this %O', scope.value)\n      return scope.value\n    }\n\n    case 'Parent': {\n      return handleParentNode(node, scope)\n    }\n    case 'FuncCall': {\n      return handleFuncCallNode(node, scope)\n    }\n    case 'Group': {\n      return walk({node: node.base, scope})\n    }\n    case 'Not': {\n      return handleNotNode(node, scope)\n    }\n    case 'Parameter': {\n      return {\n        type: 'unknown',\n      }\n    }\n\n    case 'Slice': {\n      return handleSlice(node, scope)\n    }\n    case 'Neg': {\n      return handleNegNode(node, scope)\n    }\n    case 'Pos': {\n      return handlePosNode(node, scope)\n    }\n    // everything else\n    case 'Asc':\n    case 'Desc':\n    case 'Context':\n    case 'Tuple':\n    case 'Selector':\n    case 'InRange': {\n      return {type: 'unknown'}\n    }\n\n    default: {\n      // @ts-expect-error - we should have handled all cases\n      throw new Error(`unknown node type ${node.type}`)\n    }\n  }\n}\n\nfunction isPrimitiveTypeNode(node: TypeNode): node is PrimitiveTypeNode {\n  return node.type === 'string' || node.type === 'number' || node.type === 'boolean'\n}\n\nfunction evaluateComparison(\n  opcall: OpCall,\n  left: PrimitiveTypeNode,\n  right: PrimitiveTypeNode,\n): boolean | undefined {\n  if (left.value === undefined || right.value === undefined) {\n    return undefined\n  }\n  switch (opcall) {\n    case '==': {\n      return left.value === right.value\n    }\n    case '<': {\n      return left.value < right.value\n    }\n    case '<=': {\n      return left.value <= right.value\n    }\n    case '>': {\n      return left.value > right.value\n    }\n    case '>=': {\n      return left.value >= right.value\n    }\n    default: {\n      throw new Error(`unknown comparison operator ${opcall}`)\n    }\n  }\n}\n\n// eslint-disable-next-line complexity, max-statements\nfunction resolveFilter(expr: ExprNode, scope: Scope): UnionTypeNode {\n  $trace('resolveFilter.expr %O', expr)\n  const filtered = scope.value.of.filter((node) => {\n    // create a new scope with the current scopes parent as the parent. It's only a temporary scope since we only want to resolve the condition\n    // and check if the result can be true.\n    const subScope = scope.createHidden([node])\n    const cond = walk({node: expr, scope: subScope})\n    return booleanValue(cond, subScope).canBeTrue\n  })\n  $trace(\n    `resolveFilter ${expr.type === 'OpCall' ? `${expr.type}/${expr.op}` : expr.type} %O`,\n    filtered,\n  )\n  return {type: 'union', of: filtered}\n}\n\nfunction mapArray(\n  node: TypeNode,\n  scope: Scope,\n  mapper: (node: ArrayTypeNode) => TypeNode,\n): TypeNode {\n  return mapNode(node, scope, (base) => {\n    if (base.type === 'unknown') {\n      return base\n    }\n    if (base.type === 'array') {\n      return mapper(base)\n    }\n    return {type: 'null'}\n  })\n}\n\nfunction mapObject(\n  node: TypeNode,\n  scope: Scope,\n  mapper: (node: ObjectTypeNode) => TypeNode,\n): TypeNode {\n  return mapNode(node, scope, (base) => {\n    if (base.type === 'unknown') {\n      return base\n    }\n    if (base.type === 'object') {\n      return mapper(base)\n    }\n    return {type: 'null'}\n  })\n}\n"],"names":["array","Scope","count","path","string","value","dateTime","parse","rhs","identLen","rawParse","match","$trace","arg","of","arrayArg","sepArg","arg1","arg2","node","typeNode","attributeNode","base","inner"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],"debugId":null}}]
}