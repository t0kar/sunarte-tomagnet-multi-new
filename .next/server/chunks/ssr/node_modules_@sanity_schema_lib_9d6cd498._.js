module.exports = {

"[project]/node_modules/@sanity/schema/lib/_chunks-es/resolve.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DEFAULT_MAX_FIELD_DEPTH": (()=>DEFAULT_MAX_FIELD_DEPTH),
    "resolveSearchConfig": (()=>resolveSearchConfig),
    "resolveSearchConfigForBaseFieldPaths": (()=>resolveSearchConfigForBaseFieldPaths)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isFinite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isFinite.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniqBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/uniqBy.js [app-ssr] (ecmascript)");
;
;
const DEFAULT_MAX_FIELD_DEPTH = 5, stringFieldsSymbols = {}, getStringFieldSymbol = (maxDepth)=>(stringFieldsSymbols[maxDepth] || (stringFieldsSymbols[maxDepth] = Symbol(`__cachedStringFields_${maxDepth}`)), stringFieldsSymbols[maxDepth]), isReference = (type)=>type.type && type.type.name === "reference", portableTextFields = [
    "style",
    "list"
], isPortableTextBlock = (type)=>type.name === "block" || type.type && isPortableTextBlock(type.type), isPortableTextArray = (type)=>type.jsonType === "array" && Array.isArray(type.of) && type.of.some(isPortableTextBlock);
function reduceType(type, reducer, acc, path = [], maxDepth) {
    if (maxDepth < 0) return acc;
    const accumulator = reducer(acc, type, path);
    return type.jsonType === "array" && Array.isArray(type.of) ? reduceArray(type, reducer, accumulator, path, maxDepth) : type.jsonType === "object" && Array.isArray(type.fields) && !isReference(type) ? reduceObject(type, reducer, accumulator, path, maxDepth) : accumulator;
}
function reduceArray(arrayType, reducer, accumulator, path, maxDepth) {
    return arrayType.of.reduce((acc, ofType)=>reduceType(ofType, reducer, acc, path, maxDepth - 1), accumulator);
}
function reduceObject(objectType, reducer, accumulator, path, maxDepth) {
    const isPtBlock = isPortableTextBlock(objectType);
    return objectType.fields.reduce((acc, field)=>{
        if (isPtBlock && portableTextFields.includes(field.name)) return acc;
        const segment = [
            field.name
        ].concat(field.type.jsonType === "array" ? [
            []
        ] : []);
        return reduceType(field.type, reducer, acc, path.concat(segment), maxDepth - 1);
    }, accumulator);
}
const BASE_WEIGHTS = [
    {
        weight: 1,
        path: [
            "_id"
        ]
    },
    {
        weight: 1,
        path: [
            "_type"
        ]
    }
], PREVIEW_FIELD_WEIGHT_MAP = {
    title: 10,
    subtitle: 5,
    description: 1.5
};
function deriveFromPreview(type, maxDepth) {
    const select = type?.preview?.select;
    if (!select) return [];
    const fields = [];
    for (const fieldName of Object.keys(select)){
        if (!(fieldName in PREVIEW_FIELD_WEIGHT_MAP)) continue;
        const path = select[fieldName].split(".");
        maxDepth > -1 && path.length - 1 > maxDepth || fields.push({
            weight: PREVIEW_FIELD_WEIGHT_MAP[fieldName],
            path
        });
    }
    return fields;
}
function getCachedStringFieldPaths(type, maxDepth) {
    const symbol = getStringFieldSymbol(maxDepth);
    return type[symbol] || (type[symbol] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniqBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])([
        ...BASE_WEIGHTS,
        ...deriveFromPreview(type, maxDepth),
        ...getStringFieldPaths(type, maxDepth).map((path)=>({
                weight: 1,
                path
            })),
        ...getPortableTextFieldPaths(type, maxDepth).map((path)=>({
                weight: 1,
                path,
                mapWith: "pt::text"
            }))
    ], (spec)=>spec.path.join("."))), type[symbol];
}
function getCachedBaseFieldPaths(type, maxDepth) {
    const symbol = getStringFieldSymbol(maxDepth);
    return type[symbol] || (type[symbol] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniqBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])([
        ...BASE_WEIGHTS,
        ...deriveFromPreview(type, maxDepth)
    ], (spec)=>spec.path.join("."))), type[symbol];
}
function getStringFieldPaths(type, maxDepth) {
    return reduceType(type, (accumulator, childType, path)=>childType.jsonType === "string" ? [
            ...accumulator,
            path
        ] : accumulator, [], [], maxDepth);
}
function getPortableTextFieldPaths(type, maxDepth) {
    return reduceType(type, (accumulator, childType, path)=>isPortableTextArray(childType) ? [
            ...accumulator,
            path
        ] : accumulator, [], [], maxDepth);
}
function resolveSearchConfigForBaseFieldPaths(type, maxDepth) {
    return getCachedBaseFieldPaths(type, normalizeMaxDepth(maxDepth));
}
function resolveSearchConfig(type, maxDepth) {
    return getCachedStringFieldPaths(type, normalizeMaxDepth(maxDepth));
}
function normalizeMaxDepth(maxDepth) {
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isFinite$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(maxDepth) || maxDepth < 1 || maxDepth > DEFAULT_MAX_FIELD_DEPTH ? DEFAULT_MAX_FIELD_DEPTH - 1 : maxDepth - 1;
}
;
 //# sourceMappingURL=resolve.mjs.map
}}),
"[project]/node_modules/@sanity/schema/lib/_internal.mjs [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "extractSchema": (()=>extractSchema),
    "groupProblems": (()=>groupProblems),
    "isActionEnabled": (()=>isActionEnabled),
    "validateSchema": (()=>validateSchema)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$difference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/difference.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$groq$2d$js$2f$dist$2f$1$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/groq-js/dist/1.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/flatten.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/get.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniq$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/uniq.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/humanize-list/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$partition$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/partition.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isPlainObject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/omit.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leven$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/leven/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$object$2d$inspect$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/object-inspect/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
const ACTIONS_FLAG = "__experimental_actions", DEFAULT_ACTIONS = [
    "create",
    "update",
    "delete",
    "publish"
], VALID_ACTIONS = DEFAULT_ACTIONS, readActions = (schemaType)=>ACTIONS_FLAG in schemaType ? schemaType[ACTIONS_FLAG] : DEFAULT_ACTIONS, validateActions = (typeName, actions)=>{
    if (!Array.isArray(actions)) throw new Error(`The value of <type>.${ACTIONS_FLAG} should be an array with any of the actions ${VALID_ACTIONS.join(", ")}`);
    const invalid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$difference$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(actions, VALID_ACTIONS);
    if (invalid.length > 0) throw new Error(`Invalid action${invalid.length > 1 ? "s" : ""} configured for schema type "${typeName}": ${invalid.join(", ")}. Valid actions are: ${VALID_ACTIONS.join(", ")}`);
    return actions;
}, resolveEnabledActions = (schemaType)=>validateActions(schemaType.name, readActions(schemaType)), isActionEnabled = (schemaType, action)=>resolveEnabledActions(schemaType).includes(action), documentDefaultFields = (typeName)=>({
        _id: {
            type: "objectAttribute",
            value: {
                type: "string"
            }
        },
        _type: {
            type: "objectAttribute",
            value: {
                type: "string",
                value: typeName
            }
        },
        _createdAt: {
            type: "objectAttribute",
            value: {
                type: "string"
            }
        },
        _updatedAt: {
            type: "objectAttribute",
            value: {
                type: "string"
            }
        },
        _rev: {
            type: "objectAttribute",
            value: {
                type: "string"
            }
        }
    }), typesMap = /* @__PURE__ */ new Map([
    [
        "text",
        {
            type: "string"
        }
    ],
    [
        "url",
        {
            type: "string"
        }
    ],
    [
        "datetime",
        {
            type: "string"
        }
    ],
    [
        "date",
        {
            type: "string"
        }
    ],
    [
        "boolean",
        {
            type: "boolean"
        }
    ],
    [
        "email",
        {
            type: "string"
        }
    ]
]);
function extractSchema(schemaDef, extractOptions = {}) {
    const inlineFields = /* @__PURE__ */ new Set(), documentTypes = /* @__PURE__ */ new Map(), schema = [];
    sortByDependencies(schemaDef).forEach((typeName)=>{
        const schemaType = schemaDef.get(typeName);
        if (schemaType === void 0) return;
        const base = convertBaseType(schemaType);
        base !== null && (base.type === "type" && inlineFields.add(schemaType), base.type === "document" && documentTypes.set(typeName, base), schema.push(base));
    });
    function convertBaseType(schemaType) {
        let typeName;
        if (schemaType.type ? typeName = schemaType.type.name : "jsonType" in schemaType && (typeName = schemaType.jsonType), typeName === "document" && isObjectType(schemaType)) {
            const defaultAttributes = documentDefaultFields(schemaType.name), object2 = createObject(schemaType);
            return object2.type === "unknown" ? null : {
                name: schemaType.name,
                type: "document",
                attributes: {
                    ...defaultAttributes,
                    ...object2.attributes
                }
            };
        }
        const value = convertSchemaType(schemaType);
        return value.type === "unknown" ? null : value.type === "object" ? {
            name: schemaType.name,
            type: "type",
            value: {
                type: "object",
                attributes: {
                    _type: {
                        type: "objectAttribute",
                        value: {
                            type: "string",
                            value: schemaType.name
                        }
                    },
                    ...value.attributes
                }
            }
        } : {
            name: schemaType.name,
            type: "type",
            value
        };
    }
    function convertSchemaType(schemaType) {
        if (inlineFields.has(schemaType.type)) return {
            type: "inline",
            name: schemaType.type.name
        };
        if (schemaType.type?.type?.name === "object") return {
            type: "inline",
            name: schemaType.type.name
        };
        if (isStringType(schemaType)) return createStringTypeNodeDefintion(schemaType);
        if (isNumberType(schemaType)) return createNumberTypeNodeDefintion(schemaType);
        if (schemaType.type && typesMap.has(schemaType.type.name)) return typesMap.get(schemaType.type.name);
        if (isCrossDatasetReferenceType(schemaType)) return {
            type: "unknown"
        };
        if (isGlobalDocumentReferenceType(schemaType)) return {
            type: "unknown"
        };
        if (isReferenceType(schemaType)) return createReferenceTypeNodeDefintion(schemaType);
        if (isArrayType(schemaType)) return createArray(schemaType);
        if (isObjectType(schemaType)) return createObject(schemaType);
        if (lastType(schemaType)?.name === "document") {
            const doc = documentTypes.get(schemaType.name);
            return doc === void 0 ? {
                type: "unknown"
            } : {
                type: "object",
                attributes: doc?.attributes
            };
        }
        throw new Error(`Type "${schemaType.name}" not found`);
    }
    function createObject(schemaType) {
        const attributes = {}, fields = gatherFields(schemaType);
        for (const field of fields){
            const fieldIsRequired = isFieldRequired(field), value = convertSchemaType(field.type);
            if (value === null) continue;
            hasAssetRequired(field) && value.type === "object" && (value.attributes.asset.optional = !1);
            const optional = extractOptions.enforceRequiredFields ? fieldIsRequired === !1 : !0;
            attributes[field.name] = {
                type: "objectAttribute",
                value,
                optional
            };
        }
        return Object.keys(attributes).length === 0 ? {
            type: "unknown"
        } : (schemaType.type?.name !== "document" && schemaType.name !== "object" && (attributes._type = {
            type: "objectAttribute",
            value: {
                type: "string",
                value: schemaType.name
            }
        }), {
            type: "object",
            attributes
        });
    }
    function createArray(arraySchemaType) {
        const of = [];
        for (const item of arraySchemaType.of){
            const field = convertSchemaType(item);
            field.type === "inline" ? of.push({
                type: "object",
                attributes: {
                    _key: createKeyField()
                },
                rest: field
            }) : (field.type === "object" && (field.rest = {
                type: "object",
                attributes: {
                    _key: createKeyField()
                }
            }), of.push(field));
        }
        return of.length === 0 ? {
            type: "null"
        } : {
            type: "array",
            of: of.length > 1 ? {
                type: "union",
                of
            } : of[0]
        };
    }
    return schema;
}
function createKeyField() {
    return {
        type: "objectAttribute",
        value: {
            type: "string"
        }
    };
}
function isFieldRequired(field) {
    const { validation } = field.type;
    if (!validation) return !1;
    const rules = Array.isArray(validation) ? validation : [
        validation
    ];
    for (const rule of rules){
        let required = !1;
        const proxy = new Proxy({}, {
            get: (target, methodName)=>()=>(methodName === "required" && (required = !0), proxy)
        });
        if (typeof rule == "function" && (rule(proxy), required) || typeof rule == "object" && rule !== null && "_required" in rule && rule._required === "required") return !0;
    }
    return !1;
}
function hasAssetRequired(field) {
    const { validation } = field.type;
    if (!validation) return !1;
    const rules = Array.isArray(validation) ? validation : [
        validation
    ];
    for (const rule of rules){
        let assetRequired = !1;
        const proxy = new Proxy({}, {
            get: (target, methodName)=>()=>(methodName === "assetRequired" && (assetRequired = !0), proxy)
        });
        if (typeof rule == "function" && (rule(proxy), assetRequired) || typeof rule == "object" && rule !== null && "_rules" in rule && Array.isArray(rule._rules) && rule._rules.some((r)=>r.flag === "assetRequired")) return !0;
    }
    return !1;
}
function isObjectType(typeDef) {
    return isType(typeDef, "object") || typeDef.jsonType === "object" || "fields" in typeDef;
}
function isArrayType(typeDef) {
    return isType(typeDef, "array");
}
function isReferenceType(typeDef) {
    return isType(typeDef, "reference");
}
function isCrossDatasetReferenceType(typeDef) {
    return isType(typeDef, "crossDatasetReference");
}
function isGlobalDocumentReferenceType(typeDef) {
    return isType(typeDef, "globalDocumentReference");
}
function isStringType(typeDef) {
    return isType(typeDef, "string");
}
function isNumberType(typeDef) {
    return isType(typeDef, "number");
}
function createStringTypeNodeDefintion(stringSchemaType) {
    const listOptions = stringSchemaType.options?.list;
    return listOptions && Array.isArray(listOptions) ? {
        type: "union",
        of: listOptions.map((v)=>({
                type: "string",
                value: typeof v == "string" ? v : v.value
            }))
    } : {
        type: "string"
    };
}
function createNumberTypeNodeDefintion(numberSchemaType) {
    const listOptions = numberSchemaType.options?.list;
    return listOptions && Array.isArray(listOptions) ? {
        type: "union",
        of: listOptions.map((v)=>({
                type: "number",
                value: typeof v == "number" ? v : v.value
            }))
    } : {
        type: "number"
    };
}
function createReferenceTypeNodeDefintion(reference2) {
    const references = gatherReferenceNames(reference2);
    return references.length === 1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$groq$2d$js$2f$dist$2f$1$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createReferenceTypeNode"])(references[0]) : {
        type: "union",
        of: references.map((name)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$groq$2d$js$2f$dist$2f$1$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createReferenceTypeNode"])(name))
    };
}
function gatherReferenceNames(type) {
    const allReferences = gatherReferenceTypes(type);
    return [
        .../* @__PURE__ */ new Set([
            ...allReferences.map((ref)=>ref.name)
        ])
    ];
}
function gatherReferenceTypes(type) {
    const refTo = "to" in type ? type.to : [];
    return "type" in type && isReferenceType(type.type) ? [
        ...gatherReferenceTypes(type.type),
        ...refTo
    ] : refTo;
}
function gatherFields(type) {
    return "fields" in type ? type.type ? gatherFields(type.type).concat(type.fields) : type.fields : [];
}
function isType(typeDef, typeName) {
    let type = typeDef;
    for(; type;){
        if (type.name === typeName || type.type && type.type.name === typeName) return !0;
        type = type.type;
    }
    return !1;
}
function lastType(typeDef) {
    let type = typeDef;
    for(; type;){
        if (!type.type) return type;
        type = type.type;
    }
}
function sortByDependencies(compiledSchema) {
    const seen = /* @__PURE__ */ new Set();
    function walkDependencies(schemaType, dependencies) {
        if (!seen.has(schemaType)) {
            if (seen.add(schemaType), "fields" in schemaType) for (const field of gatherFields(schemaType)){
                const last = lastType(field.type);
                if (last.name === "document") {
                    dependencies.add(last);
                    continue;
                }
                let schemaTypeName;
                schemaType.type.type ? schemaTypeName = field.type.type.name : "jsonType" in schemaType.type && (schemaTypeName = field.type.jsonType), (schemaTypeName === "object" || schemaTypeName === "block") && (isReferenceType(field.type) ? field.type.to.forEach((ref)=>dependencies.add(ref.type)) : dependencies.add(field.type)), walkDependencies(field.type, dependencies);
            }
            else if ("of" in schemaType) for (const item of schemaType.of)walkDependencies(item, dependencies);
        }
    }
    const dependencyMap = /* @__PURE__ */ new Map();
    compiledSchema.getTypeNames().forEach((typeName)=>{
        const schemaType = compiledSchema.get(typeName);
        if (schemaType === void 0 || schemaType.type === null) return;
        const dependencies = /* @__PURE__ */ new Set();
        walkDependencies(schemaType, dependencies), dependencyMap.set(schemaType, dependencies), seen.clear();
    });
    const typeNames = [], currentlyVisiting = /* @__PURE__ */ new Set(), visited = /* @__PURE__ */ new Set();
    function visit(type) {
        if (visited.has(type) || currentlyVisiting.has(type)) return;
        currentlyVisiting.add(type);
        const deps = dependencyMap.get(type);
        deps !== void 0 && deps.forEach((dep)=>visit(dep)), currentlyVisiting.delete(type), visited.add(type), typeNames.includes(type.name) || typeNames.unshift(type.name);
    }
    for (const [type] of dependencyMap)visit(type);
    return typeNames;
}
const HELP_IDS = {
    TYPE_INVALID: "schema-type-invalid",
    TYPE_IS_ESM_MODULE: "schema-type-is-esm-module",
    TYPE_NAME_RESERVED: "schema-type-name-reserved",
    TYPE_MISSING_NAME: "schema-type-missing-name-or-type",
    TYPE_MISSING_TYPE: "schema-type-missing-name-or-type",
    TYPE_TITLE_RECOMMENDED: "schema-type-title-is-recommended",
    TYPE_TITLE_INVALID: "schema-type-title-is-recommended",
    OBJECT_FIELDS_INVALID: "schema-object-fields-invalid",
    OBJECT_FIELD_NOT_UNIQUE: "schema-object-fields-invalid",
    OBJECT_FIELD_NAME_INVALID: "schema-object-fields-invalid",
    OBJECT_FIELD_DEFINITION_INVALID_TYPE: "schema-object-fields-invalid",
    ARRAY_PREDEFINED_CHOICES_INVALID: "schema-predefined-choices-invalid",
    ARRAY_OF_ARRAY: "schema-array-of-array",
    ARRAY_OF_INVALID: "schema-array-of-invalid",
    ARRAY_OF_NOT_UNIQUE: "schema-array-of-invalid",
    ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: "schema-array-of-type-global-type-conflict",
    ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: "schema-array-of-type-builtin-type-conflict",
    REFERENCE_TO_INVALID: "schema-reference-to-invalid",
    REFERENCE_TO_NOT_UNIQUE: "schema-reference-to-invalid",
    REFERENCE_INVALID_OPTIONS: "schema-reference-invalid-options",
    REFERENCE_INVALID_OPTIONS_LOCATION: "schema-reference-options-nesting",
    REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: "schema-reference-filter-params-combination",
    SLUG_SLUGIFY_FN_RENAMED: "slug-slugifyfn-renamed",
    ASSET_METADATA_FIELD_INVALID: "asset-metadata-field-invalid",
    CROSS_DATASET_REFERENCE_INVALID: "cross-dataset-reference-invalid",
    GLOBAL_DOCUMENT_REFERENCE_INVALID: "global-document-reference-invalid",
    DEPRECATED_BLOCKEDITOR_KEY: "schema-deprecated-blockeditor-key",
    STANDALONE_BLOCK_TYPE: "schema-standalone-block-type"
};
function createValidationResult(severity, message, helpId) {
    if (helpId && !Object.keys(HELP_IDS).some((id)=>HELP_IDS[id] === helpId)) throw new Error(`Used the unknown helpId "${helpId}", please add it to the array in createValidationResult.js`);
    return {
        severity,
        message,
        helpId
    };
}
const error = (message, helpId)=>createValidationResult("error", message, helpId), warning = (message, helpId)=>createValidationResult("warning", message, helpId);
function groupProblems(types) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(types.map((type)=>getTypeProblems(type))).filter((type)=>type.problems.length > 0);
}
function createTypeWithMembersProblemsAccessor(memberPropertyName, getMembers = (type)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(type, memberPropertyName)) {
    return function(type, parentPath) {
        const currentPath = [
            ...parentPath,
            {
                kind: "type",
                type: type.type,
                name: type.name
            }
        ], members = getMembers(type) || [], memberProblems = Array.isArray(members) ? members.map((memberType)=>{
            const propertySegment = {
                kind: "property",
                name: memberPropertyName
            }, memberPath = [
                ...currentPath,
                propertySegment
            ];
            return getTypeProblems(memberType, memberPath);
        }) : [
            [
                {
                    path: currentPath,
                    problems: [
                        error(`Member declaration (${memberPropertyName}) is not an array`)
                    ]
                }
            ]
        ];
        return [
            {
                path: currentPath,
                problems: type._problems || []
            },
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(memberProblems)
        ];
    };
}
const arrify = (val)=>Array.isArray(val) ? val : typeof val > "u" && [] || [
        val
    ], getObjectProblems = createTypeWithMembersProblemsAccessor("fields"), getImageProblems = createTypeWithMembersProblemsAccessor("fields"), getFileProblems = createTypeWithMembersProblemsAccessor("fields"), getArrayProblems = createTypeWithMembersProblemsAccessor("of"), getReferenceProblems = createTypeWithMembersProblemsAccessor("to", (type)=>"to" in type ? arrify(type.to) : []), getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor("marks.annotations"), getBlockMemberProblems = createTypeWithMembersProblemsAccessor("of"), getBlockProblems = (type, problems)=>[
        ...getBlockAnnotationProblems(type, problems),
        ...getBlockMemberProblems(type, problems)
    ];
function getDefaultProblems(type, path = []) {
    return [
        {
            path: [
                ...path,
                {
                    kind: "type",
                    type: type.type,
                    name: type.name
                }
            ],
            problems: type._problems || []
        }
    ];
}
function getTypeProblems(type, path = []) {
    switch(type.type){
        case "object":
            return getObjectProblems(type, path);
        case "document":
            return getObjectProblems(type, path);
        case "array":
            return getArrayProblems(type, path);
        case "reference":
            return getReferenceProblems(type, path);
        case "block":
            return getBlockProblems(type, path);
        case "image":
            return getImageProblems(type, path);
        case "file":
            return getFileProblems(type, path);
        default:
            return getDefaultProblems(type, path);
    }
}
function getDupes(array2, selector = (v)=>v) {
    const dupes = array2.reduce((acc, item)=>{
        const key = selector(item);
        return acc[key] || (acc[key] = []), acc[key].push(item), acc;
    }, {});
    return Object.keys(dupes).map((key)=>dupes[key].length > 1 ? dupes[key] : null).filter(Boolean);
}
const NOOP_VISITOR = (typeDef)=>typeDef, TYPE_TYPE = {
    name: "type",
    type: null
}, FUTURE_RESERVED = [
    "any",
    "time",
    "date"
];
function traverseSchema(types = [], coreTypes2 = [], visitor = NOOP_VISITOR) {
    const coreTypesRegistry = /* @__PURE__ */ Object.create(null), registry = /* @__PURE__ */ Object.create(null), coreTypeNames2 = coreTypes2.map((typeDef)=>typeDef.name), reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames2), typeNames = types.map((typeDef)=>typeDef && typeDef.name).filter(Boolean);
    coreTypes2.forEach((coreType)=>{
        coreTypesRegistry[coreType.name] = coreType;
    }), types.forEach((type, i)=>{
        registry[type && type.name || `__unnamed_${i}`] = {};
    });
    function getType(typeName) {
        return typeName === "type" ? TYPE_TYPE : coreTypesRegistry[typeName] || registry[typeName] || null;
    }
    const duplicateNames = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniq$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(getDupes(typeNames)));
    function isDuplicate(typeName) {
        return duplicateNames.includes(typeName);
    }
    function getTypeNames() {
        return typeNames.concat(coreTypeNames2);
    }
    function isReserved(typeName) {
        return typeName === "type" || reservedTypeNames.includes(typeName);
    }
    const visitType = (isRoot)=>(typeDef, index)=>visitor(typeDef, {
                visit: visitType(!1),
                isRoot,
                getType,
                getTypeNames,
                isReserved,
                isDuplicate,
                index
            });
    return coreTypes2.forEach((coreTypeDef)=>{
        Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef));
    }), types.forEach((typeDef, i)=>{
        Object.assign(registry[typeDef && typeDef.name || `__unnamed_${i}`], visitType(!0)(typeDef, i));
    }), {
        get (typeName) {
            const res = registry[typeName] || coreTypesRegistry[typeName];
            if (res) return res;
            throw new Error(`No such type: ${typeName}`);
        },
        has (typeName) {
            return typeName in registry || typeName in coreTypesRegistry;
        },
        getTypeNames () {
            return Object.keys(registry);
        },
        getTypes () {
            return this.getTypeNames().map(this.get);
        },
        toJSON () {
            return this.getTypes();
        }
    };
}
const coreTypes = [
    {
        name: "array",
        jsonType: "array",
        type: "type"
    },
    {
        name: "block",
        jsonType: "object",
        type: "type"
    },
    {
        name: "boolean",
        jsonType: "boolean",
        type: "type"
    },
    {
        name: "datetime",
        jsonType: "string",
        type: "type"
    },
    {
        name: "date",
        jsonType: "string",
        type: "type"
    },
    {
        name: "document",
        jsonType: "object",
        type: "type"
    },
    {
        name: "email",
        jsonType: "string",
        type: "type"
    },
    {
        name: "file",
        jsonType: "object",
        type: "type"
    },
    {
        name: "geopoint",
        jsonType: "object",
        type: "type"
    },
    {
        name: "image",
        jsonType: "object",
        type: "type"
    },
    {
        name: "number",
        jsonType: "number",
        type: "type"
    },
    {
        name: "object",
        jsonType: "object",
        type: "type"
    },
    {
        name: "reference",
        jsonType: "object",
        type: "type"
    },
    {
        name: "crossDatasetReference",
        jsonType: "object",
        type: "type"
    },
    {
        name: "globalDocumentReference",
        jsonType: "object",
        type: "type"
    },
    {
        name: "slug",
        jsonType: "object",
        type: "type"
    },
    {
        name: "span",
        jsonType: "object",
        type: "type"
    },
    {
        name: "string",
        jsonType: "string",
        type: "type"
    },
    {
        name: "telephone",
        jsonType: "string",
        type: "type"
    },
    {
        name: "text",
        jsonType: "string",
        type: "type"
    },
    {
        name: "url",
        jsonType: "string",
        type: "type"
    }
], coreTypeNames = coreTypes.map((t)=>t.name);
function traverseSanitySchema(schemaTypes, visitor) {
    return traverseSchema(schemaTypes, coreTypes, visitor);
}
function isPrimitiveTypeName(typeName) {
    return typeName === "string" || typeName === "number" || typeName === "boolean";
}
function isAssignable(typeName, type) {
    return (typeof type.name == "string" ? type.name : type.type) === typeName;
}
function quote$2(n) {
    return `"${n}"`;
}
function pluralize(arr, suf = "s") {
    return arr.length === 1 ? "" : suf;
}
function format(value) {
    return Array.isArray(value) ? `array with ${value.length} entries` : typeof value == "object" && value !== null ? `object with keys ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(Object.keys(value).map(quote$2))}` : quote$2(value);
}
var array = (typeDef, visitorContext)=>{
    const ofIsArray = Array.isArray(typeDef.of);
    if (ofIsArray) {
        const invalid = typeDef.of.reduce((errs, def, idx)=>{
            if (typeof def.name == "string" && // specifying the same name as the type is redundant, but should not be a hard error at this point
            // Consider showing a warning for this and deprecate this ability eventually
            def.name !== def.type && coreTypeNames.includes(def.name)) return errs.concat(error(`Found array member declaration with the same type name as a built-in type ("${def.name}"). Array members can not be given the same name as a built-in type.`, HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT));
            if (def.type === "object" && def.name && visitorContext.getType(def.name)) return errs.concat(warning(`Found array member declaration with the same name as the global schema type "${def.name}". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`, HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT));
            if (def.type === "array") return errs.concat(error('Found array member declaration of type "array" - multidimensional arrays are not currently supported by Sanity', HELP_IDS.ARRAY_OF_ARRAY));
            if (def) return errs;
            const err = `Found ${def === null ? "null" : typeof def}, expected member declaration`;
            return errs.concat(error(`Found invalid type member declaration in array at index ${idx}: ${err}`, HELP_IDS.ARRAY_OF_INVALID));
        }, []);
        if (invalid.length > 0) return {
            ...typeDef,
            of: [],
            _problems: invalid
        };
    }
    const problems = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])([
        ofIsArray ? getDupes(typeDef.of, (t)=>`${t.name};${t.type}`).map((dupes)=>error(`Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in array. This makes it impossible to tell their values apart and you should consider naming them`, HELP_IDS.ARRAY_OF_NOT_UNIQUE)) : error('The array type is missing or having an invalid value for the required "of" property', HELP_IDS.ARRAY_OF_INVALID)
    ]), of = ofIsArray ? typeDef.of : [], hasObjectTypesWithoutName = of.some((type)=>type.type === "object" && typeof type.name > "u");
    of.some((ofType)=>ofType.type === "block") && hasObjectTypesWithoutName && problems.push(error("The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.", HELP_IDS.ARRAY_OF_INVALID));
    const [primitiveTypes, objectTypes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$partition$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(of, (ofType)=>isPrimitiveTypeName(ofType.type) || isPrimitiveTypeName(visitorContext.getType(ofType.type)?.jsonType)), isMixedArray = primitiveTypes.length > 0 && objectTypes.length > 0;
    if (isMixedArray) {
        const primitiveTypeNames = primitiveTypes.map((t)=>t.type), objectTypeNames = objectTypes.map((t)=>t.type);
        problems.push(error(`The array type's 'of' property can't have both object types and primitive types (found primitive type ${pluralize(primitiveTypeNames)} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(primitiveTypeNames.map(quote$2))} and object type${pluralize(objectTypeNames)} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(objectTypeNames.map(quote$2))})`, HELP_IDS.ARRAY_OF_INVALID));
    }
    const list = typeDef?.options?.list;
    return !isMixedArray && Array.isArray(list) && (primitiveTypes.length > 0 ? list.forEach((option)=>{
        const value = option?.value ?? option;
        if (!primitiveTypes.some((primitiveType)=>typeof value === visitorContext.getType(primitiveType.type).jsonType)) {
            const formattedTypeList = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(primitiveTypes.map((t)=>t.name || t.type), {
                conjunction: "or"
            });
            problems.push(error(`An invalid entry found in options.list: ${format(value)}. Must be either a value of type ${formattedTypeList}, or an object with {title: string, value: ${formattedTypeList}}`, HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID));
        }
    }) : list.forEach((option)=>{
        const optionTypeName = option._type || "object";
        objectTypes.some((validObjectType)=>isAssignable(optionTypeName, validObjectType)) || problems.push(error(`An invalid entry found in options.list: ${format(option)}. Must be an object with "_type" set to ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(objectTypes.map((t)=>t.name || t.type).map((t)=>t === "object" ? "undefined" : quote$2(t)), {
            conjunction: "or"
        })}`, HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID));
    })), typeDef?.options?.list && typeDef?.options?.layout === "tags" && problems.push(warning("Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`.")), {
        ...typeDef,
        of: of.map(visitorContext.visit),
        _problems: problems
    };
};
function isJSONTypeOf(type, jsonType, visitorContext) {
    if ("jsonType" in type) return type.jsonType === jsonType;
    const parentType = visitorContext.getType(type.type);
    if (!parentType) throw new Error(`Could not resolve jsonType of ${type.name}. No parent type found`);
    return isJSONTypeOf(parentType, jsonType, visitorContext);
}
const getTypeOf = (thing)=>Array.isArray(thing) ? "array" : typeof thing, quote$1 = (str)=>`"${str}"`, allowedKeys = [
    "components",
    "lists",
    "marks",
    "name",
    "of",
    "options",
    "styles",
    "title",
    "type",
    "validation"
], allowedMarkKeys = [
    "decorators",
    "annotations"
], allowedStyleKeys = [
    "blockEditor",
    "title",
    "value",
    "icon",
    "component"
], allowedDecoratorKeys = [
    "blockEditor",
    "title",
    "value",
    "icon",
    "component"
], allowedListKeys = [
    "title",
    "value",
    "icon",
    "component"
], supportedBuiltInObjectTypes = [
    "file",
    "image",
    "object",
    "reference",
    "crossDatasetReference",
    "globalDocumentReference"
];
function validateBlockType(typeDef, visitorContext) {
    const problems = [];
    let styles = typeDef.styles, lists = typeDef.lists, marks = typeDef.marks, members = typeDef.of;
    const disallowedKeys = Object.keys(typeDef).filter((key)=>!allowedKeys.includes(key) && !key.startsWith("_"));
    return disallowedKeys.length > 0 && problems.push(error(`Found unknown properties for block declaration: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(disallowedKeys.map(quote$1))}`)), marks && (marks = validateMarks(typeDef.marks, visitorContext, problems)), styles && (styles = validateStyles(styles, visitorContext, problems)), lists && (lists = validateLists(lists, visitorContext, problems)), members && (members = validateMembers(members, visitorContext, problems)), {
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeDef, disallowedKeys),
        marks,
        styles,
        name: typeDef.name || typeDef.type,
        of: members,
        _problems: problems
    };
}
function validateMarks(marks, visitorContext, problems) {
    let decorators = marks.decorators, annotations = marks.annotations;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(marks)) return problems.push(error(`"marks" declaration should be an object, got ${getTypeOf(marks)}`)), problems;
    const disallowedMarkKeys = Object.keys(marks).filter((key)=>!allowedMarkKeys.includes(key) && !key.startsWith("_"));
    return disallowedMarkKeys.length > 0 && problems.push(error(`Found unknown properties for block declaration: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(disallowedMarkKeys.map(quote$1))}`)), decorators && !Array.isArray(decorators) ? problems.push(error(`"marks.decorators" declaration should be an array, got ${getTypeOf(decorators)}`)) : decorators && (decorators.filter((dec)=>!!dec.blockEditor).forEach((dec)=>{
        dec.icon = dec.blockEditor.icon, dec.component = dec.blockEditor.render;
    }), decorators = validateDecorators(decorators, visitorContext, problems)), annotations && !Array.isArray(annotations) ? problems.push(error(`"marks.annotations" declaration should be an array, got ${getTypeOf(annotations)}`)) : annotations && (annotations = validateAnnotations(annotations, visitorContext, problems)), {
        ...marks,
        decorators,
        annotations
    };
}
function validateLists(lists, visitorContext, problems) {
    return Array.isArray(lists) ? (lists.forEach((list, index)=>{
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(list)) {
            problems.push(error(`List must be an object, got ${getTypeOf(list)}`));
            return;
        }
        const name = list.value || `#${index}`, disallowedKeys = Object.keys(list).filter((key)=>!allowedListKeys.includes(key) && !key.startsWith("_"));
        disallowedKeys.length > 0 && problems.push(error(`Found unknown properties for list ${name}: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(disallowedKeys.map(quote$1))}`)), list.value ? typeof list.value != "string" ? problems.push(error(`List type #${index} has an invalid "value" property, expected string, got ${getTypeOf(list.value)}`)) : list.title || problems.push(warning(`List type ${name} is missing recommended "title" property`)) : problems.push(error(`List #${index} is missing required "value" property`));
    }), lists) : (problems.push(error(`"lists" declaration should be an array, got ${getTypeOf(lists)}`)), problems);
}
function validateStyles(styles, visitorContext, problems) {
    return Array.isArray(styles) ? (styles.forEach((style, index)=>{
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(style)) {
            problems.push(error(`Style must be an object, got ${getTypeOf(style)}`));
            return;
        }
        const name = style.value || `#${index}`, disallowedKeys = Object.keys(style).filter((key)=>!allowedStyleKeys.includes(key) && !key.startsWith("_"));
        disallowedKeys.length > 0 && problems.push(error(`Found unknown properties for style ${name}: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(disallowedKeys.map(quote$1))}`)), style.value ? typeof style.value != "string" ? problems.push(error(`Style #${index} has an invalid "value" property, expected string, got ${getTypeOf(style.value)}`)) : style.title || problems.push(warning(`Style ${name} is missing recommended "title" property`)) : problems.push(error(`Style #${index} is missing required "value" property`)), typeof style.blockEditor < "u" && (problems.push(warning('Style has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.', HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY)), style.component = style.component || style.blockEditor.render);
    }), styles) : (problems.push(error(`"styles" declaration should be an array, got ${getTypeOf(styles)}`)), problems);
}
function validateDecorators(decorators, visitorContext, problems) {
    return decorators.forEach((decorator, index)=>{
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(decorator)) {
            problems.push(error(`Annotation must be an object, got ${getTypeOf(decorator)}`));
            return;
        }
        const name = decorator.value || `#${index}`, disallowedKeys = Object.keys(decorator).filter((key)=>!allowedDecoratorKeys.includes(key) && !key.startsWith("_"));
        disallowedKeys.length > 0 && problems.push(error(`Found unknown properties for decorator ${name}: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(disallowedKeys.map(quote$1))}`)), decorator.value ? typeof decorator.value != "string" ? problems.push(error(`Decorator #${index} has an invalid "value" property, expected string, got ${getTypeOf(decorator.value)}`)) : decorator.title || problems.push(warning(`Decorator ${name} is missing recommended "title" property`)) : problems.push(error(`Decorator #${index} is missing required "value" property`)), typeof decorator.blockEditor < "u" && (problems.push(warning(`Decorator "${name}" has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.`, HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY)), decorator.icon = decorator.icon || decorator.blockEditor.icon, decorator.component = decorator.component || decorator.blockEditor.render);
    }), decorators;
}
function validateAnnotations(annotations, visitorContext, problems) {
    return annotations.map((annotation)=>{
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(annotation)) return {
            ...annotation,
            _problems: [
                error(`Annotation must be an object, got ${getTypeOf(annotation)}`)
            ]
        };
        const { _problems } = visitorContext.visit(annotation, visitorContext), targetType = annotation.type && visitorContext.getType(annotation.type);
        return targetType && !isJSONTypeOf(targetType, "object", visitorContext) && _problems.push(error(`Annotation cannot have type "${annotation.type}" - annotation types must inherit from object`)), typeof annotation.blockEditor < "u" && (problems.push(warning('Annotation has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.', HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY)), annotation.icon = annotation.icon || annotation.blockEditor.icon, annotation.blockEditor?.render && !annotation.components?.annotation && (annotation.components = annotation.components || {}, annotation.components.annotation = annotation.components.annotation || annotation.blockEditor.render)), {
            ...annotation,
            _problems
        };
    });
}
function validateMembers(members, visitorContext, problems) {
    if (!Array.isArray(members)) {
        problems.push(error(`"of" declaration should be an array, got ${getTypeOf(members)}`));
        return;
    }
    return members.map((member)=>{
        const { _problems } = visitorContext.visit(member, visitorContext);
        if (member.type === "object" && member.name && visitorContext.getType(member.name)) return {
            ...member,
            _problems: [
                warning(`Found array member declaration with the same name as the global schema type "${member.name}". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`, HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT)
            ]
        };
        let type = member;
        for(; type && !type.jsonType;)type = visitorContext.getType(type.type);
        const nonObjectCoreTypes = coreTypeNames.filter((n)=>!supportedBuiltInObjectTypes.includes(n));
        return(// Must be object-like type (to validate hoisted types)
        type && type.jsonType !== "object" || // Can't be a core type, or core object type that isn't supported (like 'span')
        nonObjectCoreTypes.some((coreName)=>coreName === member.type) ? {
            ...member,
            _problems: [
                error(`Block member types must be a supported object-like type. The following built-in types are supported: '${supportedBuiltInObjectTypes.join("', '")}'. You can also use shorthands for previously defined object types like {type: 'myObjectType'}`, HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT)
            ]
        } : {
            ...member,
            _problems
        });
    });
}
function validateNonObjectFieldsProp(typeDef, visitorContext) {
    if (!("fields" in typeDef)) return [];
    let type = typeDef;
    for(; type && !type.jsonType;)type = visitorContext.getType(type.type);
    return type && type.jsonType !== "object" ? [
        error('Type has propery "fields", but is not an object/document type.')
    ] : [];
}
const quote = (str)=>`"${str}"`;
function validateTypeName(typeName, visitorContext) {
    const possibleTypeNames = visitorContext.getTypeNames();
    if (!typeName) return [
        error("Type is missing a type.", HELP_IDS.TYPE_MISSING_TYPE)
    ];
    if (typeof typeName != "string") return [
        error('Type has an invalid "type"-property - should be a string.', HELP_IDS.TYPE_MISSING_TYPE)
    ];
    if (!possibleTypeNames.includes(typeName)) {
        const suggestions = possibleTypeNames.map((possibleTypeName)=>[
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leven$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeName, possibleTypeName),
                possibleTypeName
            ]).filter(([distance])=>distance < 3).map(([_, name])=>name), suggestion = suggestions.length > 0 ? ` Did you mean ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$humanize$2d$list$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(suggestions.map(quote), {
            conjunction: "or"
        })}?` : "";
        return [
            error(`Unknown type: ${typeName}.${suggestion}`)
        ];
    }
    return [];
}
function validateDeprecatedProperties(type) {
    const warnings = [];
    return type?.inputComponent && warnings.push(warning('The "inputComponent" property is deprecated. Use "components.input" instead.')), type?.preview?.component && warnings.push(warning('The "preview.component" property is deprecated. Use "components.preview" instead.')), type?.diffComponent && warnings.push(warning('The "diffComponent" property is deprecated. Use "components.diff" instead.')), type?.options?.editModal && warnings.push(warning('The "options.editModal" property is deprecated. Use "options.modal" instead.')), type?.options?.isHighlighted && warnings.push(warning('The "options.isHighlighted" property is deprecated. You can put fields behind a collapsed fieldset if you want to hide them from plain sight.')), warnings;
}
var common = (typeDef, visitorContext)=>({
        ...typeDef,
        _problems: [
            ...validateTypeName(typeDef.type, visitorContext),
            ...validateNonObjectFieldsProp(typeDef, visitorContext),
            ...validateDeprecatedProperties(typeDef)
        ].filter(Boolean)
    });
function normalizeToProp$2(typeDef) {
    return Array.isArray(typeDef.to) ? typeDef.to : typeDef.to ? [
        typeDef.to
    ] : typeDef.to;
}
const VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/;
function isValidDatasetName(name) {
    return name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name) || `The provided dataset "${name}" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore`;
}
var crossDatasetReference = (typeDef, visitorContext)=>{
    const isValidTo = Array.isArray(typeDef.to) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeDef.to), normalizedTo = normalizeToProp$2(typeDef), problems = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])([
        isValidTo ? getDupes(normalizedTo, (t)=>`${t.name};${t.type}`).map((dupes)=>error(`Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in reference. This makes it impossible to tell their values apart and you should consider naming them`, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID)) : error('The cross dataset reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID)
    ]);
    if (isValidTo && normalizedTo.length === 0 && problems.push(error('The cross dataset reference type should define at least one referenced type. Please check the "to" property.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID)), normalizedTo.forEach((crossDatasetTypeDef, index)=>{
        crossDatasetTypeDef.type || problems.push(error(`The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(crossDatasetTypeDef.preview) || problems.push(error(`Missing required preview config for the referenced type "${crossDatasetTypeDef.type || "<unknown type>"}"`, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }), typeof typeDef.dataset == "string") {
        const datasetValidation = isValidDatasetName(typeDef.dataset);
        datasetValidation !== !0 && problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    } else problems.push(error("A cross dataset reference must specify a `dataset`", HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    return typeDef.studioUrl && typeof typeDef.studioUrl != "function" && problems.push(error('The "studioUrl" property on a cross dataset reference must be a function taking "{id, type}" as argument and returning a studio url.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID)), problems.push(...getOptionErrors$2(typeDef)), {
        ...typeDef,
        _problems: problems
    };
};
function getOptionErrors$2(typeDef) {
    const { options } = typeDef, problems = [];
    return problems.push(...[
        "filter",
        "filterParams"
    ].filter((key)=>key in typeDef).map((key)=>error(`\`${key}\` is not allowed on a reference type definition - did you mean \`options.${key}\`?`, HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION))), options ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(options) ? typeof options.filter == "function" && typeof options.filterParams < "u" ? problems.concat(error("`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.", HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION)) : typeof options.filter == "function" || !options.filter && !options.filterParams ? problems : typeof options.filter != "string" ? problems.concat(error(`If set, \`filter\` must be a string. Got ${typeof options.filter}`)) : typeof options.filterParams < "u" && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(options.filterParams) ? problems.concat(error("If set, `filterParams` must be an object.")) : options.filterParams ? problems.concat(Object.keys(options.filterParams).filter((key)=>key.startsWith("__") || key.startsWith("$")).map((key)=>error(`Filter parameter cannot be prefixed with "$" or "__". Got ${key}".`))) : problems : problems.concat(error("The reference type expects `options` to be an object", HELP_IDS.REFERENCE_INVALID_OPTIONS)) : problems;
}
const REACT_SYM_RE = /^Symbol\(react\..+\)$/;
function isComponentLike(value) {
    return typeof value == "function" || typeof value?.$$typeof == "symbol" && REACT_SYM_RE.test(String(value?.$$typeof));
}
function validateComponent(typeDef) {
    const components = "components" in typeDef ? typeDef.components : !1;
    if (!components) return [];
    const warnings = [];
    return components.input && !isComponentLike(components.input) && warnings.push(warning(`The \`components.input\` property is set but does not appear to be a valid React component (expected a function, but saw ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$object$2d$inspect$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(components.input)}). If you have imported a custom input component, please verify that you have imported the correct named/default export.`)), components.field && !isComponentLike(components.field) && warnings.push(warning(`The \`components.field\` property is set but does not appear to be a valid React component (expected a function, but saw ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$object$2d$inspect$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(components.field)}). If you have imported a custom field component, please verify that you have imported the correct named/default export.`)), components.item && !isComponentLike(components.item) && warnings.push(warning(`The \`components.item\` property is set but does not appear to be a valid React component (expected a function, but saw ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$object$2d$inspect$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(components.item)}). If you have imported a custom item component, please verify that you have imported the correct named/default export.`)), components.preview && !isComponentLike(components.preview) && warnings.push(warning(`The \`components.preview\` property is set but does not appear to be a valid React component (expected a function, but saw ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$object$2d$inspect$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(components.preview)}). If you have imported a custom preview component, please verify that you have imported the correct named/default export.`)), warnings;
}
const VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/, CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/;
function validateFieldName(name) {
    return typeof name != "string" ? [
        error(`Field names must be strings. Saw "${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$object$2d$inspect$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(name)}"`, HELP_IDS.OBJECT_FIELD_NAME_INVALID)
    ] : name.startsWith("_") ? [
        error(`Invalid field name "${name}". Field names cannot start with underscores "_" as it's reserved for system fields.`, HELP_IDS.OBJECT_FIELD_NAME_INVALID)
    ] : VALID_FIELD_RE.test(name) ? CONVENTIONAL_FIELD_RE.test(name) ? [] : [
        warning("Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional? It may be wise to keep special characters out of field names for easier access later on."),
        HELP_IDS.OBJECT_FIELD_NAME_INVALID
    ] : [
        error(`Invalid field name: "${name}". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ${String(VALID_FIELD_RE)}).`, HELP_IDS.OBJECT_FIELD_NAME_INVALID)
    ];
}
function validateField(field, _visitorContext) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(field)) return [
        error(`Incorrect type for field definition - should be an object, saw ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$object$2d$inspect$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(field)}`, HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE)
    ];
    const problems = [];
    return problems.push(..."name" in field ? validateFieldName(field.name) : [
        error("Missing field name", HELP_IDS.OBJECT_FIELD_NAME_INVALID)
    ]), problems.push(...validateComponent(field)), problems;
}
function getDuplicateFields(array2) {
    const dupes = {};
    return array2.forEach((field)=>{
        dupes[field.name] || (dupes[field.name] = []), dupes[field.name].push(field);
    }), Object.keys(dupes).map((fieldName)=>dupes[fieldName].length > 1 ? dupes[fieldName] : null).filter(Boolean);
}
function validateFields(fields, options = {
    allowEmpty: !1
}) {
    const problems = [];
    if (!Array.isArray(fields)) return [
        error(`The "fields" property must be an array of fields. Instead saw "${typeof fields}"`, HELP_IDS.OBJECT_FIELDS_INVALID)
    ];
    const fieldsWithNames = fields.filter((field)=>typeof field.name == "string");
    getDuplicateFields(fieldsWithNames).forEach((dupes)=>{
        problems.push(error(`Found ${dupes.length} fields with name "${dupes[0].name}" in object`, HELP_IDS.OBJECT_FIELD_NOT_UNIQUE));
    }), fields.length === 0 && !options.allowEmpty && problems.push(error("Object should have at least one field", HELP_IDS.OBJECT_FIELDS_INVALID));
    const standaloneBlockFields = fields.filter((field)=>field.type === "block").map((field)=>`"${field.name}"`);
    if (standaloneBlockFields.length > 0) {
        const fmtFields = standaloneBlockFields.join(", ");
        problems.push(error(`Invalid standalone block field(s) ${fmtFields}. Block content must be defined as an array of blocks`, HELP_IDS.STANDALONE_BLOCK_TYPE));
    }
    return problems;
}
function validatePreview(preview) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(preview) ? typeof preview.prepare < "u" && typeof preview.prepare != "function" ? [
        error(`The "preview.prepare" property must be a function, instead saw "${typeof preview.prepare}"`)
    ] : preview.select ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(preview.select) ? Object.keys(preview.select).reduce((errs, key)=>typeof preview.select[key] == "string" ? errs : errs.concat(error(`The key "${key}" of "preview.select" must be a string, instead saw "${typeof preview.select[key]}"`)), []) : [
        error(`The "preview.select" property must be an object, instead saw "${typeof preview.prepare}"`)
    ] : [] : [
        error(`The "preview" property must be an object, instead saw "${typeof preview}"`)
    ];
}
var object = (typeDef, visitorContext)=>{
    let problems = validateFields(typeDef.fields), preview = typeDef.preview;
    if (preview) {
        const previewErrors = validatePreview(typeDef.preview);
        problems = problems.concat(previewErrors), preview = previewErrors.some((err)=>err.severity === "error") ? {} : preview;
    }
    return typeDef.type !== "document" && typeDef.type !== "object" && typeof typeDef.initialValue < "u" && problems.push(error('The "initialValue" property is currently only supported for document & object types.')), {
        ...typeDef,
        preview,
        fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map((field, index)=>{
            const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
            return {
                name,
                ...fieldType,
                _problems: validateField(field).concat(_problems || [])
            };
        }),
        _problems: problems
    };
}, documentVisitor = (typeDefinition, visitorContext)=>{
    const typeDef = object(typeDefinition, visitorContext), { initialValue, initialValues } = typeDef;
    return typeof initialValue < "u" && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(initialValue) && typeof initialValue != "function" && typeDef._problems.push(error('The "initialValue" property must be either a plain object or a function')), typeof initialValues < "u" && typeDef._problems.push(error('Found property "initialValues" - did you mean "initialValue"?')), typeDef;
}, file = (typeDef, visitorContext)=>{
    const problems = [], fields = typeDef.fields;
    fields && problems.push(...validateFields(fields, {
        allowEmpty: !0
    }));
    const invalidFieldNames = Array.isArray(fields) ? fields?.filter((field)=>field.name === "asset") : [];
    return typeDef.options && typeof typeDef.options.metadata < "u" && !Array.isArray(typeDef.options.metadata) ? problems.push(error("Invalid type for file `metadata` field - must be an array of strings", HELP_IDS.ASSET_METADATA_FIELD_INVALID)) : invalidFieldNames.length > 0 && problems.push(error("The name `asset` is not a valid field name for type `file`.")), {
        ...typeDef,
        fields: (Array.isArray(fields) ? fields : []).map((field, index)=>{
            const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
            return {
                name,
                ...fieldType,
                _problems: validateField(field).concat(_problems || [])
            };
        }),
        _problems: problems
    };
};
function normalizeToProp$1(typeDef) {
    return Array.isArray(typeDef.to) ? typeDef.to : typeDef.to ? [
        typeDef.to
    ] : typeDef.to;
}
function isValidResourceType(resourceType) {
    return resourceType ? resourceType != "media-library" && resourceType != "dataset" ? 'The resource type must be either "media-library" or "dataset"' : !0 : "The resource type must be a non-empty string";
}
function isValidResourceId(resourceType, resourceId) {
    return resourceId ? resourceType === "dataset" ? resourceId.split(".").length !== 2 ? 'The resource ID for a dataset reference must be on the form "<projectId>.<datasetName>"' : !0 : resourceType === "media-library" ? !0 : `Cannot validate resource ID for resource type: ${resourceType}` : "The resource ID must be a non-empty string";
}
var globalDocumentReference = (typeDef, visitorContext)=>{
    const isValidTo = Array.isArray(typeDef.to) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeDef.to), normalizedTo = normalizeToProp$1(typeDef), problems = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])([
        isValidTo ? getDupes(normalizedTo, (t)=>`${t.name};${t.type}`).map((dupes)=>error(`Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in reference. This makes it impossible to tell their values apart and you should consider naming them`, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID)) : error('The global document reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.', HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID)
    ]);
    if (isValidTo && normalizedTo.length === 0 && problems.push(error('The global document reference type should define at least one referenced type. Please check the "to" property.', HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID)), normalizedTo.forEach((crossDatasetTypeDef, index)=>{
        crossDatasetTypeDef.type || problems.push(error(`The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(crossDatasetTypeDef.preview) || problems.push(error(`Missing required preview config for the referenced type "${crossDatasetTypeDef.type || "<unknown type>"}"`, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID));
    }), typeof typeDef.resourceType == "string") {
        const validation = isValidResourceType(typeDef.resourceType);
        validation !== !0 && problems.push(error(validation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID));
    } else problems.push(error("A global document reference must specify a `resourceType`", HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID));
    if (typeof typeDef.resourceId == "string") {
        const datasetValidation = isValidResourceId(typeDef.resourceType, typeDef.resourceId);
        datasetValidation !== !0 && problems.push(error(datasetValidation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID));
    } else problems.push(error("A global document reference must specify a `resourceId`", HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID));
    return typeDef.studioUrl && typeof typeDef.studioUrl != "function" && problems.push(error('The "studioUrl" property on a global document reference must be a function taking "{id, type}" as argument and returning a studio url.', HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID)), problems.push(...getOptionErrors$1(typeDef)), {
        ...typeDef,
        _problems: problems
    };
};
function getOptionErrors$1(typeDef) {
    const { options } = typeDef, problems = [];
    return problems.push(...[
        "filter",
        "filterParams"
    ].filter((key)=>key in typeDef).map((key)=>error(`\`${key}\` is not allowed on a reference type definition - did you mean \`options.${key}\`?`, HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION))), options ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(options) ? typeof options.filter == "function" && typeof options.filterParams < "u" ? problems.concat(error("`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.", HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION)) : typeof options.filter == "function" || !options.filter && !options.filterParams ? problems : typeof options.filter != "string" ? problems.concat(error(`If set, \`filter\` must be a string. Got ${typeof options.filter}`)) : typeof options.filterParams < "u" && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(options.filterParams) ? problems.concat(error("If set, `filterParams` must be an object.")) : options.filterParams ? problems.concat(Object.keys(options.filterParams).filter((key)=>key.startsWith("__") || key.startsWith("$")).map((key)=>error(`Filter parameter cannot be prefixed with "$" or "__". Got ${key}".`))) : problems : problems.concat(error("The reference type expects `options` to be an object", HELP_IDS.REFERENCE_INVALID_OPTIONS)) : problems;
}
const autoMeta = [
    "dimensions",
    "hasAlpha",
    "isOpaque"
];
var image = (typeDef, visitorContext)=>{
    const problems = [], fields = typeDef.fields;
    fields && problems.push(...validateFields(fields, {
        allowEmpty: !0
    }));
    let options = typeDef.options;
    const metadata = options?.metadata, superfluousMeta = Array.isArray(metadata) ? metadata.filter((meta)=>autoMeta.includes(meta)) : [], invalidFieldNames = [
        "asset",
        "hotspot",
        "crop"
    ], fieldsWithInvalidName = Array.isArray(fields) ? fields?.filter((field)=>invalidFieldNames.includes(field.name)) : [];
    return typeof metadata < "u" && !Array.isArray(metadata) ? problems.push(error("Invalid type for image `metadata` field - must be an array of strings", HELP_IDS.ASSET_METADATA_FIELD_INVALID)) : superfluousMeta.length > 0 ? (problems.push(warning(`Image \`metadata\` field contains superfluous properties (they are always included): ${superfluousMeta.join(", ")}`)), options = {
        ...options,
        metadata: metadata.filter((meta)=>!autoMeta.includes(meta))
    }) : fieldsWithInvalidName.length > 0 && problems.push(error(`The names \`${invalidFieldNames.join("`, `")}\` are invalid field names for type \`image\`.`)), {
        ...typeDef,
        options,
        fields: (Array.isArray(fields) ? fields : []).map((field, index)=>{
            const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
            return {
                name,
                ...fieldType,
                _problems: validateField(field).concat(_problems || [])
            };
        }),
        _problems: problems
    };
};
function normalizeToProp(typeDef) {
    return Array.isArray(typeDef.to) ? typeDef.to : typeDef.to ? [
        typeDef.to
    ] : typeDef.to;
}
var reference = (typeDef, visitorContext)=>{
    const isValidTo = Array.isArray(typeDef.to) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeDef.to), normalizedTo = normalizeToProp(typeDef), problems = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])([
        isValidTo ? getDupes(normalizedTo, (t)=>`${t.name};${t.type}`).map((dupes)=>error(`Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in reference. This makes it impossible to tell their values apart and you should consider naming them`, HELP_IDS.REFERENCE_TO_INVALID)) : error('The reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.', HELP_IDS.REFERENCE_TO_INVALID)
    ]);
    return isValidTo && normalizedTo.length === 0 && problems.push(error('The reference type should define at least one accepted type. Please check the "to" property.', HELP_IDS.REFERENCE_TO_INVALID)), problems.push(...getOptionErrors(typeDef)), {
        ...typeDef,
        to: (isValidTo ? normalizedTo : []).map(visitorContext.visit),
        _problems: problems
    };
};
function getOptionErrors(typeDef) {
    const { options } = typeDef, problems = [];
    return problems.push(...[
        "filter",
        "filterParams"
    ].filter((key)=>key in typeDef).map((key)=>error(`\`${key}\` is not allowed on a reference type definition - did you mean \`options.${key}\`?`, HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION))), options ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(options) ? typeof options.filter == "function" && typeof options.filterParams < "u" ? problems.concat(error("`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.", HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION)) : typeof options.filter == "function" || !options.filter && !options.filterParams ? problems : typeof options.filter != "string" ? problems.concat(error(`If set, \`filter\` must be a string. Got ${typeof options.filter}`)) : typeof options.filterParams < "u" && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(options.filterParams) ? problems.concat(error("If set, `filterParams` must be an object.")) : options.filterParams ? problems.concat(Object.keys(options.filterParams).filter((key)=>key.startsWith("__") || key.startsWith("$")).map((key)=>error(`Filter parameter cannot be prefixed with "$" or "__". Got ${key}".`))) : problems : problems.concat(error("The reference type expects `options` to be an object", HELP_IDS.REFERENCE_INVALID_OPTIONS)) : problems;
}
var rootType = (typeDef, visitorContext)=>{
    const hasName = !!typeDef.name;
    if (!hasName && Object.keys(typeDef).length === 1) return {
        ...typeDef,
        _problems: [
            error("Invalid/undefined type declaration, check declaration or the import/export of the schema type.", HELP_IDS.TYPE_INVALID)
        ]
    };
    const problems = [];
    return looksLikeEsmModule(typeDef) ? problems.push(error("Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property", HELP_IDS.TYPE_IS_ESM_MODULE)) : hasName ? visitorContext.isReserved(typeDef.name) && problems.push(error(`Invalid type name: "${typeDef.name}" is a reserved name.`, HELP_IDS.TYPE_NAME_RESERVED)) : problems.push(error("Missing type name", HELP_IDS.TYPE_MISSING_NAME)), visitorContext.isDuplicate(typeDef.name) && problems.push(error(`Invalid type name: A type with name "${typeDef.name}" is already defined in the schema.`)), problems.push(...validateComponent(typeDef)), "title" in typeDef && typeof typeDef.title != "string" && problems.push(warning("Type title is not a string.", HELP_IDS.TYPE_TITLE_INVALID)), {
        ...typeDef,
        _problems: problems
    };
};
function looksLikeEsmModule(typeDef) {
    return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title);
}
var slug = (typeDef, visitorContext)=>{
    const problems = [];
    return typeDef.options && typeDef.options.slugifyFn && (problems.push(warning('Heads up! The "slugifyFn" option has been renamed to "slugify".', HELP_IDS.SLUG_SLUGIFY_FN_RENAMED)), typeDef.options.slugify = typeDef.options.slugifyFn), {
        ...typeDef,
        _problems: problems
    };
};
const typeVisitors = {
    array,
    object,
    slug,
    file,
    image,
    block: validateBlockType,
    document: documentVisitor,
    reference,
    crossDatasetReference,
    globalDocumentReference
}, getNoopVisitor = (visitorContext)=>(schemaDef)=>({
            name: `<unnamed_type_@_index_${visitorContext.index}>`,
            ...schemaDef,
            _problems: []
        });
function combine(...visitors) {
    return (schemaType, visitorContext)=>visitors.reduce((result, visitor)=>{
            const res = visitor(result, visitorContext);
            return {
                ...res,
                _problems: result._problems.concat(res._problems)
            };
        }, {
            _problems: [],
            ...schemaType
        });
}
function validateSchema(schemaTypes) {
    return traverseSanitySchema(schemaTypes, (schemaDef, visitorContext)=>{
        const typeVisitor = schemaDef && schemaDef.type && typeVisitors[schemaDef.type] || getNoopVisitor(visitorContext);
        return visitorContext.isRoot ? combine(rootType, common, typeVisitor)(schemaDef, visitorContext) : combine(common, typeVisitor)(schemaDef, visitorContext);
    });
}
;
 //# sourceMappingURL=_internal.mjs.map
}}),
"[project]/node_modules/@sanity/schema/lib/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Schema": (()=>Schema2),
    "default": (()=>DeprecatedDefaultSchema)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/omit.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/pick.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$arrify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/arrify/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isUndefined$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isUndefined.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omitBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/omitBy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$capitalize$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/capitalize.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$schema$2f$lib$2f$_chunks$2d$es$2f$resolve$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/schema/lib/_chunks-es/resolve.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$castArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/castArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatMap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/flatMap.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/startCase.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isPlainObject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$toPath$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/toPath.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
const DEFAULT_OVERRIDEABLE_FIELDS = [
    "jsonType",
    "type",
    "name",
    "title",
    "description",
    "options",
    "fieldsets",
    "validation",
    "readOnly",
    "hidden",
    "components",
    "diffComponent",
    "initialValue",
    "deprecated"
], OVERRIDABLE_FIELDS$f = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], ANY_CORE = {
    name: "any",
    type: null,
    jsonType: "any"
}, AnyType = {
    get () {
        return ANY_CORE;
    },
    extend (subTypeDef, extendMember) {
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(ANY_CORE, OVERRIDABLE_FIELDS$f), subTypeDef, {
            type: ANY_CORE,
            of: subTypeDef.of.map((fieldDef)=>({
                    name: fieldDef.name,
                    type: extendMember((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omit$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(fieldDef, "name"))
                }))
        });
        return subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    if (extensionDef.of) throw new Error('Cannot override `of` property of subtypes of "array"');
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$f), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
};
function lazyGetter(target, key, getter, config = {}) {
    return Object.defineProperty(target, key, {
        configurable: !0,
        enumerable: config.enumerable !== !1,
        get () {
            const val = getter();
            return Object.defineProperty(target, key, {
                value: val,
                writable: !!config.writable,
                configurable: !1
            }), val;
        }
    }), target;
}
const OVERRIDABLE_FIELDS$e = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], ARRAY_CORE = {
    name: "array",
    type: null,
    jsonType: "array",
    of: []
}, ArrayType = {
    get () {
        return ARRAY_CORE;
    },
    extend (subTypeDef, createMemberType) {
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(ARRAY_CORE, OVERRIDABLE_FIELDS$e), subTypeDef, {
            type: ARRAY_CORE
        });
        return lazyGetter(parsed, "of", ()=>subTypeDef.of.map((ofTypeDef)=>createMemberType(ofTypeDef))), subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    if (extensionDef.of) throw new Error('Cannot override `of` property of subtypes of "array"');
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$e), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
};
function warnIfPreviewOnOptions(type) {
    type.options && type.options.preview && console.warn(`Heads up! The preview config is no longer defined on "options", but instead on the type/field itself.
Please move {options: {preview: ...}} to {..., preview: ...} on the type/field definition of "${type.name}".
`);
}
function warnIfPreviewHasFields(type) {
    const preview = type.preview || (type.options || {}).preview;
    preview && "fields" in preview && console.warn(`Heads up! "preview.fields" should be renamed to "preview.select". Please update the preview config for "${type.name}".
`);
}
function isEmpty(object) {
    for(const key in object)if (object.hasOwnProperty(key)) return !1;
    return !0;
}
function _stringify(value, options, depth) {
    if (depth > options.maxDepth) return "...";
    if (Array.isArray(value)) {
        if (value.length === 0) return "[empty]";
        const capLength = Math.max(value.length - options.maxBreadth), asString2 = value.slice(0, options.maxBreadth).map((item, index)=>_stringify(item, options, depth + 1)).concat(capLength > 0 ? `\u2026+${capLength}` : []).join(", ");
        return depth === 0 ? asString2 : `[${asString2}]`;
    }
    if (typeof value == "object" && value !== null) {
        const keys = Object.keys(value).filter((key)=>!options.ignoreKeys.includes(key) && typeof value[key] < "u");
        if (isEmpty((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value, keys))) return "{empty}";
        const asString2 = keys.slice(0, options.maxBreadth).map((key)=>`${key}: ${_stringify(value[key], options, depth + 1)}`).join(", ");
        return depth === 0 ? asString2 : `{${asString2}}`;
    }
    const asString = String(value);
    return asString === "" ? '""' : asString;
}
function stringify(value, options = {}) {
    const opts = {
        maxDepth: "maxDepth" in options ? options.maxDepth : 2,
        maxBreadth: "maxBreadth" in options ? options.maxBreadth : 2,
        ignoreKeys: "ignoreKeys" in options ? options.ignoreKeys : []
    };
    return _stringify(value, opts, 0);
}
const OPTIONS = {
    maxEntries: 2,
    maxDepth: 2,
    maxBreadth: 2,
    ignoreKeys: [
        "_id",
        "_type",
        "_key",
        "_ref"
    ]
};
function createFallbackPrepare(fieldNames) {
    return (value)=>({
            title: stringify((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value, fieldNames), OPTIONS)
        });
}
function isBlockField(field) {
    return field.type === "array" && field.of && field.of.some((member)=>member.type === "block") || !1;
}
const TITLE_CANDIDATES = [
    "title",
    "name",
    "label",
    "heading",
    "header",
    "caption"
], DESCRIPTION_CANDIDATES = [
    "description",
    ...TITLE_CANDIDATES
];
function fieldHasReferenceTo(fieldDef, refType) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$arrify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(fieldDef.to || []).some((memberTypeDef)=>memberTypeDef.type === refType);
}
function isImageAssetField(fieldDef) {
    return fieldHasReferenceTo(fieldDef, "sanity.imageAsset");
}
function resolveImageAssetPath(typeDef) {
    const fields = typeDef.fields || [], imageAssetField = fields.find(isImageAssetField);
    if (imageAssetField) return imageAssetField.name;
    const fieldWithImageAsset = fields.find((fieldDef)=>(fieldDef.fields || []).some(isImageAssetField));
    return fieldWithImageAsset ? `${fieldWithImageAsset.name}.asset` : void 0;
}
function isFileAssetField(fieldDef) {
    return fieldHasReferenceTo(fieldDef, "sanity.fileAsset");
}
function resolveFileAssetPath(typeDef) {
    const fields = typeDef.fields || [], assetField = fields.find(isFileAssetField);
    if (assetField) return assetField.name;
    const fieldWithFileAsset = fields.find((fieldDef)=>(fieldDef.fields || []).some(isFileAssetField));
    return fieldWithFileAsset ? `${fieldWithFileAsset.name}.asset` : void 0;
}
function guessPreviewFields(rawObjectTypeDef) {
    const objectTypeDef = {
        fields: [],
        ...rawObjectTypeDef
    }, stringFieldNames = objectTypeDef.fields.filter((field)=>field.type === "string").map((field)=>field.name), blockFieldNames = objectTypeDef.fields.filter(isBlockField).map((field)=>field.name);
    let titleField = TITLE_CANDIDATES.find((candidate)=>stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate)), descField = DESCRIPTION_CANDIDATES.find((candidate)=>candidate !== titleField && (stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate)));
    titleField || (titleField = stringFieldNames[0] || blockFieldNames[0], descField = stringFieldNames[1] || blockFieldNames[1]);
    const mediaField = objectTypeDef.fields.find((field)=>field.type === "image"), imageAssetPath = resolveImageAssetPath(objectTypeDef);
    if (!titleField) {
        const fileAssetPath = resolveFileAssetPath(objectTypeDef);
        fileAssetPath && (titleField = `${fileAssetPath}.originalFilename`), imageAssetPath && (titleField = `${imageAssetPath}.originalFilename`);
    }
    if (!titleField && !imageAssetPath) {
        const fieldNames = objectTypeDef.fields.map((field)=>field.name);
        return {
            select: fieldNames.reduce((acc, fieldName)=>(acc[fieldName] = fieldName, acc), {}),
            prepare: createFallbackPrepare(fieldNames)
        };
    }
    return {
        select: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omitBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            title: titleField,
            description: descField,
            media: mediaField ? mediaField.name : imageAssetPath
        }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isUndefined$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])
    };
}
function parseSelection(selection) {
    return selection.reduce((acc, field)=>(acc[field] = field, acc), {});
}
function parsePreview(preview) {
    if (!preview) return preview;
    const select = preview.select || preview.fields || {};
    return Array.isArray(select) ? {
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(preview, [
            "prepare",
            "component"
        ]),
        select: parseSelection(select)
    } : {
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(preview, [
            "prepare",
            "component"
        ]),
        select
    };
}
function createPreviewGetter(objectTypeDef) {
    return function() {
        return warnIfPreviewOnOptions(objectTypeDef), warnIfPreviewHasFields(objectTypeDef), parsePreview(objectTypeDef.preview || (objectTypeDef.options || {}).preview) || guessPreviewFields(objectTypeDef);
    };
}
const DEFAULT_LINK_ANNOTATION = {
    type: "object",
    name: "link",
    title: "Link",
    i18nTitleKey: "inputs.portable-text.annotation.link",
    options: {
        modal: {
            type: "popover"
        }
    },
    fields: [
        {
            name: "href",
            type: "url",
            title: "Link",
            description: "A valid web, email, phone, or relative link.",
            validation: (Rule)=>Rule.uri({
                    scheme: [
                        "http",
                        "https",
                        "tel",
                        "mailto"
                    ],
                    allowRelative: !0
                })
        }
    ]
}, DEFAULT_TEXT_FIELD = {
    type: "text",
    name: "text",
    title: "Text"
}, DEFAULT_MARKS_FIELD = {
    name: "marks",
    type: "array",
    of: [
        {
            type: "string"
        }
    ],
    title: "Marks"
}, LIST_TYPES = {
    bullet: {
        title: "Bulleted list",
        value: "bullet",
        i18nTitleKey: "inputs.portable-text.list-type.bullet"
    },
    numbered: {
        title: "Numbered list",
        value: "number",
        i18nTitleKey: "inputs.portable-text.list-type.number"
    }
}, DEFAULT_LIST_TYPES = [
    LIST_TYPES.bullet,
    LIST_TYPES.numbered
], BLOCK_STYLES = {
    normal: {
        title: "Normal",
        value: "normal",
        i18nTitleKey: "inputs.portable-text.style.normal"
    },
    h1: {
        title: "Heading 1",
        value: "h1",
        i18nTitleKey: "inputs.portable-text.style.h1"
    },
    h2: {
        title: "Heading 2",
        value: "h2",
        i18nTitleKey: "inputs.portable-text.style.h2"
    },
    h3: {
        title: "Heading 3",
        value: "h3",
        i18nTitleKey: "inputs.portable-text.style.h3"
    },
    h4: {
        title: "Heading 4",
        value: "h4",
        i18nTitleKey: "inputs.portable-text.style.h4"
    },
    h5: {
        title: "Heading 5",
        value: "h5",
        i18nTitleKey: "inputs.portable-text.style.h5"
    },
    h6: {
        title: "Heading 6",
        value: "h6",
        i18nTitleKey: "inputs.portable-text.style.h6"
    },
    blockquote: {
        title: "Quote",
        value: "blockquote",
        i18nTitleKey: "inputs.portable-text.style.quote"
    }
}, DEFAULT_BLOCK_STYLES = [
    BLOCK_STYLES.normal,
    BLOCK_STYLES.h1,
    BLOCK_STYLES.h2,
    BLOCK_STYLES.h3,
    BLOCK_STYLES.h4,
    BLOCK_STYLES.h5,
    BLOCK_STYLES.h6,
    BLOCK_STYLES.blockquote
], DECORATOR_STRONG = {
    title: "Strong",
    value: "strong",
    i18nTitleKey: "inputs.portable-text.decorator.strong"
}, DECORATOR_EMPHASIS = {
    title: "Italic",
    value: "em",
    i18nTitleKey: "inputs.portable-text.decorator.emphasis"
}, DECORATOR_CODE = {
    title: "Code",
    value: "code",
    i18nTitleKey: "inputs.portable-text.decorator.code"
}, DECORATOR_UNDERLINE = {
    title: "Underline",
    value: "underline",
    i18nTitleKey: "inputs.portable-text.decorator.underline"
}, DECORATOR_STRIKE = {
    title: "Strike",
    value: "strike-through",
    i18nTitleKey: "inputs.portable-text.decorator.strike-through"
}, DECORATORS = {
    strong: DECORATOR_STRONG,
    em: DECORATOR_EMPHASIS,
    code: DECORATOR_CODE,
    underline: DECORATOR_UNDERLINE,
    strikeThrough: DECORATOR_STRIKE
}, DEFAULT_DECORATORS = [
    DECORATORS.strong,
    DECORATORS.em,
    DECORATORS.code,
    DECORATORS.underline,
    DECORATORS.strikeThrough
], INHERITED_FIELDS$1 = [
    "type",
    "name",
    "title",
    "jsonType",
    "description",
    "options",
    "fieldsets",
    "icon"
], BLOCK_CORE = {
    name: "block",
    title: "Block",
    type: null,
    jsonType: "object"
}, DEFAULT_OPTIONS$3 = {}, BlockType = {
    get () {
        return BLOCK_CORE;
    },
    extend (subTypeDef, extendMember) {
        const options = {
            ...subTypeDef.options || DEFAULT_OPTIONS$3
        }, { marks, styles, lists, of, ...rest } = subTypeDef, childrenField = createChildrenField(marks, of), styleField = createStyleField(styles), listItemField = createListItemField(lists), markDefsField = {
            name: "markDefs",
            title: "Mark definitions",
            type: "array",
            of: marks?.annotations || DEFAULT_ANNOTATIONS
        }, fields = [
            childrenField,
            styleField,
            listItemField,
            markDefsField,
            {
                name: "level",
                title: "Indentation",
                type: "number"
            }
        ].concat(subTypeDef.fields || []), parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(BLOCK_CORE, INHERITED_FIELDS$1), rest, {
            type: BLOCK_CORE,
            options
        });
        return lazyGetter(parsed, "fields", ()=>fields.map((fieldDef)=>{
                const { name, ...type } = fieldDef;
                return {
                    name,
                    type: extendMember(type)
                };
            })), lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef)), subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    if (extensionDef.fields) throw new Error('Cannot override `fields` of subtypes of "block"');
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, INHERITED_FIELDS$1), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
};
function ensureNormalStyle(styles) {
    return styles.some((style)=>style.value === "normal") ? styles : [
        BLOCK_STYLES.normal,
        ...styles
    ];
}
function createStyleField(styles) {
    return {
        name: "style",
        title: "Style",
        type: "string",
        options: {
            list: ensureNormalStyle(styles || DEFAULT_BLOCK_STYLES)
        }
    };
}
function createListItemField(lists) {
    return {
        name: "listItem",
        title: "List type",
        type: "string",
        options: {
            list: lists || DEFAULT_LIST_TYPES
        }
    };
}
const DEFAULT_ANNOTATIONS = [
    DEFAULT_LINK_ANNOTATION
];
function createChildrenField(marks, of = []) {
    return {
        name: "children",
        title: "Content",
        type: "array",
        of: [
            {
                type: "span",
                fields: [
                    DEFAULT_TEXT_FIELD,
                    DEFAULT_MARKS_FIELD
                ],
                annotations: marks && marks.annotations ? marks.annotations : DEFAULT_ANNOTATIONS,
                decorators: marks && marks.decorators ? marks.decorators : DEFAULT_DECORATORS
            },
            ...of.filter((memberType)=>memberType.type !== "span")
        ]
    };
}
const INHERITED_FIELDS = [
    "type",
    "name",
    "title",
    "jsonType",
    "description",
    "options",
    "fieldsets",
    "icon"
], SPAN_CORE = {
    name: "span",
    title: "Span",
    type: null,
    jsonType: "object"
}, MARKS_FIELD = {
    name: "marks",
    title: "Marks",
    type: "array",
    of: [
        {
            type: "string"
        }
    ]
}, TEXT_FIELD = {
    name: "text",
    title: "Text",
    type: "string"
}, DEFAULT_OPTIONS$2 = {}, SpanType = {
    get () {
        return SPAN_CORE;
    },
    extend (subTypeDef, extendMember) {
        const options = {
            ...subTypeDef.options || DEFAULT_OPTIONS$2
        }, { annotations = [], marks = [] } = subTypeDef, fields = [
            MARKS_FIELD,
            TEXT_FIELD
        ], parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(SPAN_CORE, INHERITED_FIELDS), subTypeDef, {
            type: SPAN_CORE,
            options
        });
        return lazyGetter(parsed, "fields", ()=>fields.map((fieldDef)=>{
                const { name, ...type } = fieldDef;
                return {
                    name,
                    type: extendMember(type)
                };
            })), lazyGetter(parsed, "annotations", ()=>annotations.map(extendMember)), lazyGetter(parsed, "marks", ()=>marks.map(extendMember)), lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef)), subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    if (extensionDef.fields) throw new Error('Cannot override `fields` of subtypes of "span"');
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, INHERITED_FIELDS), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
};
var primitivePreview = {
    prepare: (val)=>({
            title: String(val)
        })
};
const OVERRIDABLE_FIELDS$d = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], BOOLEAN_CORE = {
    name: "boolean",
    title: "Boolean",
    type: null,
    jsonType: "boolean"
}, BooleanType = {
    get () {
        return BOOLEAN_CORE;
    },
    extend (subTypeDef) {
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(BOOLEAN_CORE, OVERRIDABLE_FIELDS$d), subTypeDef, {
            type: BOOLEAN_CORE,
            preview: primitivePreview
        });
        return subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$d), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, REF_FIELD$2 = {
    name: "_ref",
    title: "Referenced document ID",
    type: "string"
}, WEAK_FIELD$2 = {
    name: "_weak",
    title: "Weak reference marker",
    type: "boolean"
}, DATASET_FIELD = {
    name: "_dataset",
    title: "Target dataset",
    type: "string"
}, PROJECT_ID_FIELD = {
    name: "_projectId",
    title: "Target project ID",
    type: "string",
    hidden: !0
}, REFERENCE_FIELDS$2 = [
    REF_FIELD$2,
    WEAK_FIELD$2,
    DATASET_FIELD,
    PROJECT_ID_FIELD
], OVERRIDABLE_FIELDS$c = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], CROSS_DATASET_REFERENCE_CORE = {
    name: "crossDatasetReference",
    type: null,
    jsonType: "object"
};
function humanize$2(arr, conjunction) {
    const len = arr.length;
    if (len === 1) return arr[0];
    const first = arr.slice(0, len - 1), last = arr[len - 1];
    return `${first.join(", ")} ${conjunction} ${last}`;
}
function buildTitle$2(type) {
    return !type.to || type.to.length === 0 ? "Cross dataset Reference" : `Cross dataset reference to ${humanize$2((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$arrify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(type.to).map((toType)=>toType.title || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$capitalize$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(toType.type)), "or").toLowerCase()}`;
}
const CrossDatasetReferenceType = {
    get () {
        return CROSS_DATASET_REFERENCE_CORE;
    },
    extend (subTypeDef, createMemberType) {
        if (!subTypeDef.to) throw new Error(`Missing "to" field in cross dataset reference definition. Check the type ${subTypeDef.name}`);
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(CROSS_DATASET_REFERENCE_CORE, OVERRIDABLE_FIELDS$c), subTypeDef, {
            type: CROSS_DATASET_REFERENCE_CORE
        });
        return lazyGetter(parsed, "fields", ()=>REFERENCE_FIELDS$2.map((fieldDef)=>{
                const { name, ...type } = fieldDef;
                return {
                    name,
                    type: createMemberType(type)
                };
            })), lazyGetter(parsed, "to", ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$arrify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(subTypeDef.to).map((toType)=>({
                    ...toType,
                    // eslint-disable-next-line camelcase
                    __experimental_search: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$schema$2f$lib$2f$_chunks$2d$es$2f$resolve$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resolveSearchConfigForBaseFieldPaths"])(toType)
                }))), lazyGetter(parsed, "title", ()=>subTypeDef.title || buildTitle$2(parsed)), subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    if (extensionDef.of) throw new Error('Cannot override `of` of subtypes of "reference"');
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$c), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, OVERRIDABLE_FIELDS$b = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], DATE_CORE = {
    name: "date",
    title: "Datetime",
    type: null,
    jsonType: "string"
}, DateType = {
    get () {
        return DATE_CORE;
    },
    extend (subTypeDef) {
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(DATE_CORE, OVERRIDABLE_FIELDS$b), subTypeDef, {
            type: DATE_CORE,
            preview: primitivePreview
        });
        return subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$b), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, OVERRIDABLE_FIELDS$a = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], DATETIME_CORE = {
    name: "datetime",
    title: "Datetime",
    type: null,
    jsonType: "string"
}, DateTimeType = {
    get () {
        return DATETIME_CORE;
    },
    extend (subTypeDef) {
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(DATETIME_CORE, OVERRIDABLE_FIELDS$a), subTypeDef, {
            type: DATETIME_CORE,
            preview: primitivePreview
        });
        return subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$a), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, CANDIDATES = [
    "title",
    "name",
    "label",
    "heading",
    "header",
    "caption",
    "description"
], PRIMITIVES = [
    "string",
    "boolean",
    "number"
], isPrimitive = (field)=>PRIMITIVES.includes(field.type);
function guessOrderingConfig(objectTypeDef) {
    let candidates = CANDIDATES.filter((candidate)=>objectTypeDef.fields.some((field)=>isPrimitive(field) && field.name === candidate));
    return candidates.length === 0 && (candidates = objectTypeDef.fields.filter(isPrimitive).map((field)=>field.name)), candidates.map((name)=>({
            name,
            i18n: {
                title: {
                    key: `default-orderings.${name}`,
                    ns: "studio"
                }
            },
            title: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$capitalize$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(name)),
            by: [
                {
                    field: name,
                    direction: "asc"
                }
            ]
        }));
}
function normalizeSearchConfigs(configs) {
    if (!Array.isArray(configs)) throw new Error("The search config of a document type must be an array of search config objects");
    return configs.map((conf)=>{
        if (conf === "defaults") return conf;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(conf)) throw new Error("Search config must be an object of {path: string, weight: number}");
        return {
            weight: "weight" in conf ? conf.weight : 1,
            path: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$toPath$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(conf.path),
            mapWith: typeof conf.mapWith == "string" ? conf.mapWith : void 0
        };
    });
}
const OVERRIDABLE_FIELDS$9 = [
    ...DEFAULT_OVERRIDEABLE_FIELDS,
    "orderings",
    "__experimental_search",
    "blockEditor",
    "icon"
], ObjectType = {
    get () {
        return {
            name: "object",
            title: "Object",
            type: null,
            jsonType: "object"
        };
    },
    extend (rawSubTypeDef, createMemberType) {
        const subTypeDef = {
            fields: [],
            ...rawSubTypeDef
        }, options = {
            ...subTypeDef.options || {}
        }, parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this.get(), OVERRIDABLE_FIELDS$9), subTypeDef, {
            type: this.get(),
            title: subTypeDef.title || (subTypeDef.name ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(subTypeDef.name) : "Object"),
            options,
            orderings: subTypeDef.orderings || guessOrderingConfig(subTypeDef),
            fields: subTypeDef.fields.map((fieldDef)=>{
                const { name, fieldset, group, ...rest } = fieldDef;
                return lazyGetter({
                    name,
                    group,
                    fieldset
                }, "type", ()=>createMemberType({
                        ...rest,
                        title: fieldDef.title || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(name)
                    }));
            })
        });
        return lazyGetter(parsed, "fieldsets", ()=>createFieldsets(subTypeDef, parsed.fields)), lazyGetter(parsed, "groups", ()=>createFieldsGroups(subTypeDef, parsed.fields)), lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef)), lazyGetter(parsed, "__experimental_search", ()=>{
            const userProvidedSearchConfig = subTypeDef.__experimental_search ? normalizeSearchConfigs(subTypeDef.__experimental_search) : null;
            return userProvidedSearchConfig ? userProvidedSearchConfig.map((entry)=>entry === "defaults" ? normalizeSearchConfigs(subTypeDef) : entry) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$schema$2f$lib$2f$_chunks$2d$es$2f$resolve$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resolveSearchConfig"])(parsed);
        }, {
            enumerable: !1
        }), subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    if (extensionDef.fields) throw new Error('Cannot override `fields` of subtypes of "object"');
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$9), {
                        title: extensionDef.title || subTypeDef.title || (subTypeDef.name ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(subTypeDef.name) : "Object"),
                        type: parent
                    });
                    return lazyGetter(current, "__experimental_search", ()=>parent.__experimental_search), subtype(current);
                }
            };
        }
    }
};
function createFieldsets(typeDef, fields) {
    const fieldsetsByName = {};
    for (const fieldset of typeDef.fieldsets || []){
        if (fieldsetsByName[fieldset.name]) throw new Error(`Duplicate fieldset name "${fieldset.name}" found for type '${typeDef.title ? typeDef.title : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeDef.name)}'`);
        fieldsetsByName[fieldset.name] = {
            title: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(fieldset.name),
            ...fieldset,
            fields: []
        };
    }
    const fieldsets = /* @__PURE__ */ new Set();
    for (const field of fields){
        if (!field.fieldset) {
            fieldsets.add({
                single: !0,
                field
            });
            continue;
        }
        const fieldset = fieldsetsByName[field.fieldset];
        if (!fieldset) throw new Error(`Fieldset '${field.fieldset}' is not defined in schema for type '${typeDef.name}'`);
        fieldset.fields.push(field), fieldsets.add(fieldset);
    }
    return Array.from(fieldsets);
}
function createFieldsGroups(typeDef, fields) {
    const groupsByName = {};
    let numDefaultGroups = 0;
    for (const group of typeDef.groups || []){
        if (groupsByName[group.name]) throw new Error(`Duplicate group name "${group.name}" found for type '${typeDef.title ? typeDef.title : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeDef.name)}'`);
        if (groupsByName[group.name] = {
            title: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(group.name),
            ...group,
            fields: []
        }, group.default && ++numDefaultGroups > 1) throw new Error(`More than one field group defined as default for type '${typeDef.title ? typeDef.title : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeDef.name)}' - only 1 is supported`);
    }
    return fields.forEach((field)=>{
        const fieldGroupNames = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$castArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(field.group || []);
        fieldGroupNames.length !== 0 && fieldGroupNames.forEach((fieldGroupName)=>{
            const currentGroup = groupsByName[fieldGroupName];
            if (!currentGroup) throw new Error(`Field group '${fieldGroupName}' is not defined in schema for type '${typeDef.title ? typeDef.name : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(typeDef.name)}'`);
            currentGroup.fields.push(field);
        });
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatMap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(groupsByName).filter((group)=>group.fields.length > 0);
}
const DOCUMENT_CORE = {
    name: "document",
    title: "Document",
    type: null,
    jsonType: "object"
}, DocumentType = {
    get () {
        return DOCUMENT_CORE;
    },
    extend: ObjectType.extend
}, OVERRIDABLE_FIELDS$8 = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], EMAIL_CORE = {
    name: "email",
    title: "Email",
    type: null,
    jsonType: "string"
}, EmailType = {
    get () {
        return EMAIL_CORE;
    },
    extend (subTypeDef) {
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(EMAIL_CORE, OVERRIDABLE_FIELDS$8), subTypeDef, {
            type: EMAIL_CORE,
            preview: primitivePreview
        });
        return subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$8), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, ASSET_FIELD$1 = {
    name: "asset",
    type: "reference",
    to: {
        type: "sanity.fileAsset"
    }
}, OVERRIDABLE_FIELDS$7 = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], FILE_CORE = {
    name: "file",
    title: "File",
    type: null,
    jsonType: "object"
}, DEFAULT_OPTIONS$1 = {
    accept: ""
}, FileType = {
    get () {
        return FILE_CORE;
    },
    extend (rawSubTypeDef, createMemberType) {
        const options = {
            ...rawSubTypeDef.options || DEFAULT_OPTIONS$1
        }, fields = [
            ASSET_FIELD$1,
            ...rawSubTypeDef.fields || []
        ], subTypeDef = {
            ...rawSubTypeDef,
            fields
        }, parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(FILE_CORE, OVERRIDABLE_FIELDS$7), subTypeDef, {
            type: FILE_CORE,
            title: subTypeDef.title || (subTypeDef.name ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(subTypeDef.name) : FILE_CORE.title),
            options,
            fields: subTypeDef.fields.map((fieldDef)=>{
                const { name, fieldset, ...rest } = fieldDef, compiledField = {
                    name,
                    fieldset,
                    isCustomized: !!rawSubTypeDef.fields
                };
                return lazyGetter(compiledField, "type", ()=>createMemberType({
                        ...rest,
                        title: fieldDef.title || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(name)
                    }));
            })
        });
        return lazyGetter(parsed, "fieldsets", ()=>createFieldsets(subTypeDef, parsed.fields)), lazyGetter(parsed, "preview", createPreviewGetter(Object.assign({}, subTypeDef, {
            fields
        }))), subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    if (extensionDef.fields) throw new Error('Cannot override `fields` of subtypes of "file"');
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$7), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, REF_FIELD$1 = {
    name: "_ref",
    title: "Referenced document ID",
    type: "string"
}, WEAK_FIELD$1 = {
    name: "_weak",
    title: "Weak reference",
    type: "boolean"
}, REFERENCE_FIELDS$1 = [
    REF_FIELD$1,
    WEAK_FIELD$1
], OVERRIDABLE_FIELDS$6 = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], GLOBAL_DOCUMENT_REFERENCE_CORE = {
    name: "globalDocumentReference",
    title: "Global Document Reference",
    type: null,
    jsonType: "object"
};
function humanize$1(arr, conjunction) {
    const len = arr.length;
    if (len === 1) return arr[0];
    const first = arr.slice(0, len - 1), last = arr[len - 1];
    return `${first.join(", ")} ${conjunction} ${last}`;
}
function buildTitle$1(type) {
    return !type.to || type.to.length === 0 ? "Global Document Reference" : `Global Document Reference to ${humanize$1((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$arrify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(type.to).map((toType)=>toType.title), "or").toLowerCase()}`;
}
const GlobalDocumentReferenceType = {
    get () {
        return GLOBAL_DOCUMENT_REFERENCE_CORE;
    },
    extend (subTypeDef, createMemberType) {
        if (!subTypeDef.to) throw new Error(`Missing "to" field in global document reference definition. Check the type ${subTypeDef.name}`);
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(GLOBAL_DOCUMENT_REFERENCE_CORE, OVERRIDABLE_FIELDS$6), subTypeDef, {
            type: GLOBAL_DOCUMENT_REFERENCE_CORE
        });
        return lazyGetter(parsed, "fields", ()=>REFERENCE_FIELDS$1.map((fieldDef)=>{
                const { name, ...type } = fieldDef;
                return {
                    name,
                    type: createMemberType(type)
                };
            })), lazyGetter(parsed, "to", ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$arrify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(subTypeDef.to).map((toType)=>({
                    ...toType
                }))), lazyGetter(parsed, "title", ()=>subTypeDef.title || buildTitle$1(parsed)), subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    if (extensionDef.of) throw new Error('Cannot override `of` of subtypes of "globalDocumentReference"');
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$6), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, ASSET_FIELD = {
    name: "asset",
    type: "reference",
    to: [
        {
            type: "sanity.imageAsset"
        }
    ]
}, HOTSPOT_FIELD = {
    name: "hotspot",
    type: "sanity.imageHotspot"
}, CROP_FIELD = {
    name: "crop",
    type: "sanity.imageCrop"
}, OVERRIDABLE_FIELDS$5 = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], IMAGE_CORE = {
    name: "image",
    title: "Image",
    type: null,
    jsonType: "object"
}, DEFAULT_OPTIONS = {}, ImageType = {
    get () {
        return IMAGE_CORE;
    },
    extend (rawSubTypeDef, createMemberType) {
        const options = {
            ...rawSubTypeDef.options || DEFAULT_OPTIONS
        };
        let hotspotFields = [
            HOTSPOT_FIELD,
            CROP_FIELD
        ];
        options.hotspot || (hotspotFields = hotspotFields.map((field)=>({
                ...field,
                hidden: !0
            })));
        const fields = [
            ASSET_FIELD,
            ...hotspotFields,
            ...rawSubTypeDef.fields || []
        ], subTypeDef = {
            ...rawSubTypeDef,
            fields
        }, parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this.get(), OVERRIDABLE_FIELDS$5), subTypeDef, {
            type: IMAGE_CORE,
            title: subTypeDef.title || (subTypeDef.name ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(subTypeDef.name) : IMAGE_CORE.title),
            options,
            fields: subTypeDef.fields.map((fieldDef)=>{
                const { name, fieldset, ...rest } = fieldDef, compiledField = {
                    name,
                    fieldset,
                    isCustomized: !!rawSubTypeDef.fields
                };
                return lazyGetter(compiledField, "type", ()=>createMemberType({
                        ...rest,
                        title: fieldDef.title || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(name)
                    }));
            })
        });
        return lazyGetter(parsed, "fieldsets", ()=>createFieldsets(subTypeDef, parsed.fields)), lazyGetter(parsed, "preview", createPreviewGetter(Object.assign({}, subTypeDef, {
            fields
        }))), subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    if (extensionDef.fields) throw new Error('Cannot override `fields` of subtypes of "image"');
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$5), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, OVERRIDABLE_FIELDS$4 = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], NUMBER_CORE = {
    name: "number",
    title: "Number",
    type: null,
    jsonType: "number"
}, NumberType = {
    get () {
        return NUMBER_CORE;
    },
    extend (subTypeDef) {
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(NUMBER_CORE, OVERRIDABLE_FIELDS$4), subTypeDef, {
            type: NUMBER_CORE,
            preview: primitivePreview
        });
        return subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$4), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, REF_FIELD = {
    name: "_ref",
    title: "Referenced document ID",
    type: "string"
}, WEAK_FIELD = {
    name: "_weak",
    title: "Weak reference",
    type: "boolean"
}, REFERENCE_FIELDS = [
    REF_FIELD,
    WEAK_FIELD
], OVERRIDABLE_FIELDS$3 = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], REFERENCE_CORE = {
    name: "reference",
    title: "Reference",
    type: null,
    jsonType: "object"
};
function humanize(arr, conjunction) {
    const len = arr.length;
    if (len === 1) return arr[0];
    const first = arr.slice(0, len - 1), last = arr[len - 1];
    return `${first.join(", ")} ${conjunction} ${last}`;
}
function buildTitle(type) {
    return !type.to || type.to.length === 0 ? "Reference" : `Reference to ${humanize((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$arrify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(type.to).map((toType)=>toType.title), "or").toLowerCase()}`;
}
const ReferenceType = {
    get () {
        return REFERENCE_CORE;
    },
    extend (subTypeDef, createMemberType) {
        if (!subTypeDef.to) throw new Error(`Missing "to" field in reference definition. Check the type ${subTypeDef.name}`);
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(REFERENCE_CORE, OVERRIDABLE_FIELDS$3), subTypeDef, {
            type: REFERENCE_CORE
        });
        return lazyGetter(parsed, "fields", ()=>REFERENCE_FIELDS.map((fieldDef)=>{
                const { name, ...type } = fieldDef;
                return {
                    name,
                    type: createMemberType(type)
                };
            })), lazyGetter(parsed, "fieldsets", ()=>createFieldsets(subTypeDef, parsed.fields)), lazyGetter(parsed, "to", ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$arrify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(subTypeDef.to).map((toType)=>createMemberType(toType))), lazyGetter(parsed, "title", ()=>subTypeDef.title || buildTitle(parsed)), subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    if (extensionDef.of) throw new Error('Cannot override `of` of subtypes of "reference"');
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$3), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, OVERRIDABLE_FIELDS$2 = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], STRING_CORE = {
    name: "string",
    title: "String",
    type: null,
    jsonType: "string"
}, StringType = {
    get () {
        return STRING_CORE;
    },
    extend (subTypeDef) {
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(STRING_CORE, OVERRIDABLE_FIELDS$2), subTypeDef, {
            type: STRING_CORE,
            preview: primitivePreview
        });
        return subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$2), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, OVERRIDABLE_FIELDS$1 = [
    ...DEFAULT_OVERRIDEABLE_FIELDS,
    "rows"
], TEXT_CORE = {
    name: "text",
    title: "Text",
    type: null,
    jsonType: "string"
}, TextType = {
    get () {
        return TEXT_CORE;
    },
    extend (subTypeDef) {
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(TEXT_CORE, OVERRIDABLE_FIELDS$1), subTypeDef, {
            type: TEXT_CORE,
            preview: primitivePreview
        });
        return subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS$1), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
}, OVERRIDABLE_FIELDS = [
    ...DEFAULT_OVERRIDEABLE_FIELDS
], URL_CORE = {
    name: "url",
    title: "Url",
    type: null,
    jsonType: "string"
}, UrlType = {
    get () {
        return URL_CORE;
    },
    extend (subTypeDef) {
        const parsed = Object.assign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(URL_CORE, OVERRIDABLE_FIELDS), subTypeDef, {
            type: URL_CORE,
            preview: primitivePreview
        });
        return subtype(parsed);
        "TURBOPACK unreachable";
        function subtype(parent) {
            return {
                get () {
                    return parent;
                },
                extend: (extensionDef)=>{
                    const current = Object.assign({}, parent, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(extensionDef, OVERRIDABLE_FIELDS), {
                        type: parent
                    });
                    return subtype(current);
                }
            };
        }
    }
};
var types = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    any: AnyType,
    array: ArrayType,
    block: BlockType,
    boolean: BooleanType,
    crossDatasetReference: CrossDatasetReferenceType,
    date: DateType,
    datetime: DateTimeType,
    document: DocumentType,
    email: EmailType,
    file: FileType,
    globalDocumentReference: GlobalDocumentReferenceType,
    image: ImageType,
    number: NumberType,
    object: ObjectType,
    reference: ReferenceType,
    span: SpanType,
    string: StringType,
    text: TextType,
    url: UrlType
});
function compileRegistry(schemaDef) {
    const registry = Object.assign(/* @__PURE__ */ Object.create(null), types), defsByName = schemaDef.types.reduce((acc, def)=>{
        if (acc[def.name]) throw new Error(`Duplicate type name added to schema: ${def.name}`);
        return acc[def.name] = def, acc;
    }, {});
    return schemaDef.types.forEach(add), registry;
    "TURBOPACK unreachable";
    function ensure(typeName) {
        if (!registry[typeName]) {
            if (!defsByName[typeName]) throw new Error(`Unknown type: ${typeName}`);
            add(defsByName[typeName]);
        }
    }
    function extendMember(memberDef) {
        return ensure(memberDef.type), registry[memberDef.type].extend(memberDef, extendMember).get();
    }
    function add(typeDef) {
        ensure(typeDef.type), !registry[typeDef.name] && (registry[typeDef.name] = registry[typeDef.type].extend(typeDef, extendMember));
    }
}
let Schema$1 = class Schema {
    _original;
    _registry;
    static compile(schemaDef) {
        return new Schema(schemaDef);
    }
    constructor(schemaDef){
        this._original = schemaDef, this._registry = compileRegistry(schemaDef);
    }
    get name() {
        return this._original.name;
    }
    get(name) {
        return this._registry[name] && this._registry[name].get();
    }
    has(name) {
        return name in this._registry;
    }
    getTypeNames() {
        return Object.keys(this._registry);
    }
};
class DeprecatedDefaultSchema extends Schema$1 {
    static compile(schemaDef) {
        return new DeprecatedDefaultSchema(schemaDef);
    }
    constructor(schemaDef){
        super(schemaDef);
        const stack = new Error('The default export of `@sanity/schema` is deprecated. Use `import {Schema} from "@sanity/schema"` instead.').stack.replace(/^Error/, "Warning");
        console.warn(stack);
    }
}
const Schema2 = Schema$1;
;
 //# sourceMappingURL=index.mjs.map
}}),

};

//# sourceMappingURL=node_modules_%40sanity_schema_lib_9d6cd498._.js.map