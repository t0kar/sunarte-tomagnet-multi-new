{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"resolve.mjs","sources":["file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/searchConfig/resolve.ts"],"sourcesContent":["import {isFinite, uniqBy} from 'lodash'\n\nexport const DEFAULT_MAX_FIELD_DEPTH = 5\n\nconst stringFieldsSymbols = {} as Record<number, symbol>\n\nconst getStringFieldSymbol = (maxDepth: number) => {\n  if (!stringFieldsSymbols[maxDepth]) {\n    stringFieldsSymbols[maxDepth] = Symbol(`__cachedStringFields_${maxDepth}`)\n  }\n\n  return stringFieldsSymbols[maxDepth]\n}\n\nconst isReference = (type: any) => type.type && type.type.name === 'reference'\n\nconst portableTextFields = ['style', 'list']\nconst isPortableTextBlock: any = (type: any) =>\n  type.name === 'block' || (type.type && isPortableTextBlock(type.type))\nconst isPortableTextArray = (type: any) =>\n  type.jsonType === 'array' && Array.isArray(type.of) && type.of.some(isPortableTextBlock)\n\nfunction reduceType(type: any, reducer: any, acc: any, path = [], maxDepth: any) {\n  if (maxDepth < 0) {\n    return acc\n  }\n\n  const accumulator = reducer(acc, type, path)\n  if (type.jsonType === 'array' && Array.isArray(type.of)) {\n    return reduceArray(type, reducer, accumulator, path, maxDepth)\n  }\n\n  if (type.jsonType === 'object' && Array.isArray(type.fields) && !isReference(type)) {\n    return reduceObject(type, reducer, accumulator, path, maxDepth)\n  }\n\n  return accumulator\n}\n\nfunction reduceArray(arrayType: any, reducer: any, accumulator: any, path: any, maxDepth: any) {\n  return arrayType.of.reduce(\n    (acc: any, ofType: any) => reduceType(ofType, reducer, acc, path, maxDepth - 1),\n    accumulator,\n  )\n}\n\nfunction reduceObject(objectType: any, reducer: any, accumulator: any, path: any, maxDepth: any) {\n  const isPtBlock = isPortableTextBlock(objectType)\n  return objectType.fields.reduce((acc: any, field: any) => {\n    // Don't include styles and list types as searchable paths for portable text blocks\n    if (isPtBlock && portableTextFields.includes(field.name)) {\n      return acc\n    }\n\n    const segment = [field.name].concat(field.type.jsonType === 'array' ? [[]] : [])\n    return reduceType(field.type, reducer, acc, path.concat(segment), maxDepth - 1)\n  }, accumulator)\n}\n\nconst BASE_WEIGHTS = [\n  {weight: 1, path: ['_id']},\n  {weight: 1, path: ['_type']},\n]\n\nconst PREVIEW_FIELD_WEIGHT_MAP = {\n  title: 10,\n  subtitle: 5,\n  description: 1.5,\n}\n\n/**\n * @internal\n */\nexport function deriveFromPreview(\n  type: {\n    preview: {select: Record<string, string>}\n  },\n  maxDepth: number,\n): {weight?: number; path: (string | number)[]}[] {\n  const select = type?.preview?.select\n\n  if (!select) {\n    return []\n  }\n\n  const fields: {weight: number; path: (string | number)[]}[] = []\n\n  for (const fieldName of Object.keys(select)) {\n    if (!(fieldName in PREVIEW_FIELD_WEIGHT_MAP)) {\n      continue\n    }\n\n    const path = select[fieldName].split('.')\n\n    if (maxDepth > -1 && path.length - 1 > maxDepth) {\n      continue\n    }\n\n    fields.push({\n      weight: (PREVIEW_FIELD_WEIGHT_MAP as any)[fieldName],\n      path,\n    })\n  }\n\n  return fields\n}\n\nfunction getCachedStringFieldPaths(type: any, maxDepth: number) {\n  const symbol = getStringFieldSymbol(maxDepth)\n  if (!type[symbol]) {\n    type[symbol] = uniqBy(\n      [\n        ...BASE_WEIGHTS,\n        ...deriveFromPreview(type, maxDepth),\n        ...getStringFieldPaths(type, maxDepth).map((path: any) => ({weight: 1, path})),\n        ...getPortableTextFieldPaths(type, maxDepth).map((path: any) => ({\n          weight: 1,\n          path,\n          mapWith: 'pt::text',\n        })),\n      ],\n      (spec) => spec.path.join('.'),\n    )\n  }\n  return type[symbol]\n}\n\nfunction getCachedBaseFieldPaths(type: any, maxDepth: number) {\n  const symbol = getStringFieldSymbol(maxDepth)\n  if (!type[symbol]) {\n    type[symbol] = uniqBy([...BASE_WEIGHTS, ...deriveFromPreview(type, maxDepth)], (spec) =>\n      spec.path.join('.'),\n    )\n  }\n  return type[symbol]\n}\n\nfunction getStringFieldPaths(type: any, maxDepth: number) {\n  const reducer = (accumulator: any, childType: any, path: any) =>\n    childType.jsonType === 'string' ? [...accumulator, path] : accumulator\n\n  return reduceType(type, reducer, [], [], maxDepth)\n}\n\nfunction getPortableTextFieldPaths(type: any, maxDepth: any) {\n  const reducer = (accumulator: any, childType: any, path: any) =>\n    isPortableTextArray(childType) ? [...accumulator, path] : accumulator\n\n  return reduceType(type, reducer, [], [], maxDepth)\n}\n\nexport function resolveSearchConfigForBaseFieldPaths(type: any, maxDepth?: number) {\n  return getCachedBaseFieldPaths(type, normalizeMaxDepth(maxDepth))\n}\n\n/**\n * @internal\n */\nexport function resolveSearchConfig(type: any, maxDepth?: number) {\n  return getCachedStringFieldPaths(type, normalizeMaxDepth(maxDepth))\n}\n\n/**\n * Normalizes a one-indexed maxDepth to a zero-indexed maxDepth\n * 0 = all fields\n *\n * @internal\n */\nfunction normalizeMaxDepth(maxDepth?: number) {\n  if (!isFinite(maxDepth) || maxDepth! < 1 || maxDepth! > DEFAULT_MAX_FIELD_DEPTH) {\n    return DEFAULT_MAX_FIELD_DEPTH - 1\n  }\n\n  return maxDepth! - 1\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"file":"_internal.mjs","sources":["file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/actionUtils.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/extractSchema.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/createValidationResult.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/groupProblems.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/utils/getDupes.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/core/traverseSchema.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/coreTypes.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/traverseSchema.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/array.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/utils/isJSONTypeOf.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/block.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/utils/validateNonObjectFieldsProp.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/utils/validateTypeName.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/deprecated.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/common.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/crossDatasetReference.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/utils/isComponent.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/utils/validateComponent.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/object.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/document.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/file.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/globalDocumentReference.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/image.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/reference.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/rootType.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validation/types/slug.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/sanity/validateSchema.ts"],"sourcesContent":["import {generateHelpUrl} from '@sanity/generate-help-url'\nimport {type SchemaType} from '@sanity/types'\nimport {difference} from 'lodash'\n\nconst ACTIONS_FLAG = '__experimental_actions'\n\nconst DEFAULT_ACTIONS = ['create', 'update', 'delete', 'publish']\nconst VALID_ACTIONS = DEFAULT_ACTIONS\n\n// todo: enable this when officially deprecating experimental actions\nconst DEPRECATE_EXPERIMENTAL_ACTIONS = false\n\nconst hasWarned = {}\nconst readActions = (schemaType: SchemaType): string[] => {\n  if (DEPRECATE_EXPERIMENTAL_ACTIONS && !(schemaType.name in hasWarned)) {\n    console.warn(`Heads up! Experimental actions is now deprecated and replaced by Document Actions. Read more about how to migrate on ${generateHelpUrl(\n      'experimental-actions-replaced-by-document-actions',\n    )}\".\n`)\n    ;(hasWarned as any)[schemaType.name] = true\n  }\n\n  return ACTIONS_FLAG in schemaType ? (schemaType[ACTIONS_FLAG] as string[]) : DEFAULT_ACTIONS\n}\n\nconst validateActions = (typeName: string, actions: string[]) => {\n  if (!Array.isArray(actions)) {\n    throw new Error(\n      `The value of <type>.${ACTIONS_FLAG} should be an array with any of the actions ${VALID_ACTIONS.join(\n        ', ',\n      )}`,\n    )\n  }\n\n  const invalid = difference(actions, VALID_ACTIONS)\n\n  if (invalid.length > 0) {\n    throw new Error(\n      `Invalid action${\n        invalid.length > 1 ? 's' : ''\n      } configured for schema type \"${typeName}\": ${invalid.join(\n        ', ',\n      )}. Valid actions are: ${VALID_ACTIONS.join(', ')}`,\n    )\n  }\n\n  return actions\n}\n\nexport const resolveEnabledActions = (schemaType: SchemaType): string[] =>\n  validateActions(schemaType.name, readActions(schemaType))\n\nexport const isActionEnabled = (schemaType: SchemaType, action: string): boolean =>\n  resolveEnabledActions(schemaType).includes(action)\n","import {\n  type ArraySchemaType,\n  type NumberSchemaType,\n  type ObjectField,\n  type ObjectFieldType,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type Rule,\n  type Schema as SchemaDef,\n  type SchemaType as SanitySchemaType,\n  type StringSchemaType,\n} from '@sanity/types'\nimport {\n  type ArrayTypeNode,\n  createReferenceTypeNode,\n  type DocumentSchemaType,\n  type InlineTypeNode,\n  type NullTypeNode,\n  type NumberTypeNode,\n  type ObjectAttribute,\n  type ObjectTypeNode,\n  type SchemaType,\n  type StringTypeNode,\n  type TypeDeclarationSchemaType,\n  type TypeNode,\n  type UnionTypeNode,\n  type UnknownTypeNode,\n} from 'groq-js'\n\nconst documentDefaultFields = (typeName: string): Record<string, ObjectAttribute> => ({\n  _id: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _type: {\n    type: 'objectAttribute',\n    value: {type: 'string', value: typeName},\n  },\n  _createdAt: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _updatedAt: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _rev: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n})\nconst typesMap = new Map<string, TypeNode>([\n  ['text', {type: 'string'}],\n  ['url', {type: 'string'}],\n  ['datetime', {type: 'string'}],\n  ['date', {type: 'string'}],\n  ['boolean', {type: 'boolean'}],\n  ['email', {type: 'string'}],\n])\n\nexport interface ExtractSchemaOptions {\n  enforceRequiredFields?: boolean\n}\n\nexport function extractSchema(\n  schemaDef: SchemaDef,\n  extractOptions: ExtractSchemaOptions = {},\n): SchemaType {\n  const inlineFields = new Set<SanitySchemaType>()\n  const documentTypes = new Map<string, DocumentSchemaType>()\n  const schema: SchemaType = []\n\n  // get a list of all the types in the schema, sorted by their dependencies. This ensures that when we check for inline/reference types, we have already processed the type\n  const sortedSchemaTypeNames = sortByDependencies(schemaDef)\n  sortedSchemaTypeNames.forEach((typeName) => {\n    const schemaType = schemaDef.get(typeName)\n    if (schemaType === undefined) {\n      return\n    }\n    const base = convertBaseType(schemaType)\n    if (base === null) {\n      return\n    }\n    if (base.type === 'type') {\n      inlineFields.add(schemaType)\n    }\n    if (base.type === 'document') {\n      documentTypes.set(typeName, base)\n    }\n\n    schema.push(base)\n  })\n\n  function convertBaseType(\n    schemaType: SanitySchemaType,\n  ): DocumentSchemaType | TypeDeclarationSchemaType | null {\n    let typeName: string | undefined\n    if (schemaType.type) {\n      typeName = schemaType.type.name\n    } else if ('jsonType' in schemaType) {\n      typeName = schemaType.jsonType\n    }\n\n    if (typeName === 'document' && isObjectType(schemaType)) {\n      const defaultAttributes = documentDefaultFields(schemaType.name)\n\n      const object = createObject(schemaType)\n      if (object.type === 'unknown') {\n        return null\n      }\n\n      return {\n        name: schemaType.name,\n        type: 'document',\n        attributes: {\n          ...defaultAttributes,\n          ...object.attributes,\n        },\n      }\n    }\n\n    const value = convertSchemaType(schemaType)\n    if (value.type === 'unknown') {\n      return null\n    }\n    if (value.type === 'object') {\n      return {\n        name: schemaType.name,\n        type: 'type',\n        value: {\n          type: 'object',\n          attributes: {\n            _type: {\n              type: 'objectAttribute',\n              value: {\n                type: 'string',\n                value: schemaType.name,\n              },\n            },\n            ...value.attributes,\n          },\n        },\n      }\n    }\n\n    return {\n      name: schemaType.name,\n      type: 'type',\n      value,\n    }\n  }\n\n  function convertSchemaType(schemaType: SanitySchemaType): TypeNode {\n    // if we have already seen the base type, we can just reference it\n    if (inlineFields.has(schemaType.type!)) {\n      return {type: 'inline', name: schemaType.type!.name} satisfies InlineTypeNode\n    }\n\n    // If we have a type that is point to a type, that is pointing to a type, we assume this is a circular reference\n    // and we return an inline type referencing it instead\n    if (schemaType.type?.type?.name === 'object') {\n      return {type: 'inline', name: schemaType.type.name} satisfies InlineTypeNode\n    }\n\n    if (isStringType(schemaType)) {\n      return createStringTypeNodeDefintion(schemaType)\n    }\n\n    if (isNumberType(schemaType)) {\n      return createNumberTypeNodeDefintion(schemaType)\n    }\n\n    // map some known types\n    if (schemaType.type && typesMap.has(schemaType.type.name)) {\n      return typesMap.get(schemaType.type.name)!\n    }\n\n    // Cross dataset references are not supported\n    if (isCrossDatasetReferenceType(schemaType)) {\n      return {type: 'unknown'} satisfies UnknownTypeNode // we don't support cross-dataset references at the moment\n    }\n\n    // Global document references are not supported\n    if (isGlobalDocumentReferenceType(schemaType)) {\n      return {type: 'unknown'} satisfies UnknownTypeNode // we don't support global document references at the moment\n    }\n\n    if (isReferenceType(schemaType)) {\n      return createReferenceTypeNodeDefintion(schemaType)\n    }\n\n    if (isArrayType(schemaType)) {\n      return createArray(schemaType)\n    }\n\n    if (isObjectType(schemaType)) {\n      return createObject(schemaType)\n    }\n\n    if (lastType(schemaType)?.name === 'document') {\n      const doc = documentTypes.get(schemaType.name)\n      if (doc === undefined) {\n        return {type: 'unknown'} satisfies UnknownTypeNode\n      }\n      return {type: 'object', attributes: doc?.attributes} satisfies ObjectTypeNode\n    }\n\n    throw new Error(`Type \"${schemaType.name}\" not found`)\n  }\n\n  function createObject(\n    schemaType: ObjectSchemaType | SanitySchemaType,\n  ): ObjectTypeNode | UnknownTypeNode {\n    const attributes: Record<string, ObjectAttribute> = {}\n\n    const fields = gatherFields(schemaType)\n    for (const field of fields) {\n      const fieldIsRequired = isFieldRequired(field)\n      const value = convertSchemaType(field.type)\n      if (value === null) {\n        continue\n      }\n\n      // if the field sets assetRequired() we will mark the asset attribute as required\n      // also guard against the case where the field is not an object, though type validation should catch this\n      if (hasAssetRequired(field) && value.type === 'object') {\n        value.attributes.asset.optional = false\n      }\n\n      // if we extract with enforceRequiredFields, we will mark the field as optional only if it is not a required field,\n      // else we will always mark it as optional\n      const optional = extractOptions.enforceRequiredFields ? fieldIsRequired === false : true\n\n      attributes[field.name] = {\n        type: 'objectAttribute',\n        value,\n        optional,\n      }\n    }\n\n    // Ignore empty objects\n    if (Object.keys(attributes).length === 0) {\n      return {type: 'unknown'} satisfies UnknownTypeNode\n    }\n\n    if (schemaType.type?.name !== 'document' && schemaType.name !== 'object') {\n      attributes._type = {\n        type: 'objectAttribute',\n        value: {\n          type: 'string',\n          value: schemaType.name,\n        },\n      }\n    }\n\n    return {\n      type: 'object',\n      attributes,\n    }\n  }\n\n  function createArray(arraySchemaType: ArraySchemaType): ArrayTypeNode | NullTypeNode {\n    const of: TypeNode[] = []\n    for (const item of arraySchemaType.of) {\n      const field = convertSchemaType(item)\n      if (field.type === 'inline') {\n        of.push({\n          type: 'object',\n          attributes: {\n            _key: createKeyField(),\n          },\n          rest: field,\n        } satisfies ObjectTypeNode)\n      } else if (field.type === 'object') {\n        field.rest = {\n          type: 'object',\n          attributes: {\n            _key: createKeyField(),\n          },\n        }\n        of.push(field)\n      } else {\n        of.push(field)\n      }\n    }\n\n    if (of.length === 0) {\n      return {type: 'null'}\n    }\n\n    return {\n      type: 'array',\n      of:\n        of.length > 1\n          ? {\n              type: 'union',\n              of,\n            }\n          : of[0],\n    }\n  }\n\n  return schema\n}\n\nfunction createKeyField(): ObjectAttribute<StringTypeNode> {\n  return {\n    type: 'objectAttribute',\n    value: {\n      type: 'string',\n    },\n  }\n}\n\nfunction isFieldRequired(field: ObjectField): boolean {\n  const {validation} = field.type\n  if (!validation) {\n    return false\n  }\n  const rules = Array.isArray(validation) ? validation : [validation]\n  for (const rule of rules) {\n    let required = false\n\n    // hack to check if a field is required. We create a proxy that returns itself when a method is called,\n    // if the method is \"required\" we set a flag\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => {\n          if (methodName === 'required') {\n            required = true\n          }\n          return proxy\n        },\n      },\n    ) as Rule\n\n    if (typeof rule === 'function') {\n      rule(proxy)\n      if (required) {\n        return true\n      }\n    }\n\n    if (typeof rule === 'object' && rule !== null && '_required' in rule) {\n      if (rule._required === 'required') {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction hasAssetRequired(field: ObjectField): boolean {\n  const {validation} = field.type\n  if (!validation) {\n    return false\n  }\n  const rules = Array.isArray(validation) ? validation : [validation]\n  for (const rule of rules) {\n    let assetRequired = false\n\n    // hack to check if a field is required. We create a proxy that returns itself when a method is called,\n    // if the method is \"required\" we set a flag\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => {\n          if (methodName === 'assetRequired') {\n            assetRequired = true\n          }\n          return proxy\n        },\n      },\n    ) as Rule\n\n    if (typeof rule === 'function') {\n      rule(proxy)\n      if (assetRequired) {\n        return true\n      }\n    }\n\n    if (\n      typeof rule === 'object' &&\n      rule !== null &&\n      '_rules' in rule &&\n      Array.isArray(rule._rules)\n    ) {\n      if (rule._rules.some((r) => r.flag === 'assetRequired')) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction isObjectType(typeDef: SanitySchemaType): typeDef is ObjectSchemaType {\n  return isType(typeDef, 'object') || typeDef.jsonType === 'object' || 'fields' in typeDef\n}\nfunction isArrayType(typeDef: SanitySchemaType): typeDef is ArraySchemaType {\n  return isType(typeDef, 'array')\n}\nfunction isReferenceType(typeDef: SanitySchemaType): typeDef is ReferenceSchemaType {\n  return isType(typeDef, 'reference')\n}\nfunction isCrossDatasetReferenceType(typeDef: SanitySchemaType) {\n  return isType(typeDef, 'crossDatasetReference')\n}\nfunction isGlobalDocumentReferenceType(typeDef: SanitySchemaType) {\n  return isType(typeDef, 'globalDocumentReference')\n}\nfunction isStringType(typeDef: SanitySchemaType): typeDef is StringSchemaType {\n  return isType(typeDef, 'string')\n}\nfunction isNumberType(typeDef: SanitySchemaType): typeDef is NumberSchemaType {\n  return isType(typeDef, 'number')\n}\nfunction createStringTypeNodeDefintion(\n  stringSchemaType: StringSchemaType,\n): StringTypeNode | UnionTypeNode<StringTypeNode> {\n  const listOptions = stringSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'string',\n        value: typeof v === 'string' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'string',\n  }\n}\n\nfunction createNumberTypeNodeDefintion(\n  numberSchemaType: NumberSchemaType,\n): NumberTypeNode | UnionTypeNode<NumberTypeNode> {\n  const listOptions = numberSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'number',\n        value: typeof v === 'number' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'number',\n  }\n}\n\nfunction createReferenceTypeNodeDefintion(\n  reference: ReferenceSchemaType,\n): ObjectTypeNode | UnionTypeNode<ObjectTypeNode> {\n  const references = gatherReferenceNames(reference)\n  if (references.length === 1) {\n    return createReferenceTypeNode(references[0])\n  }\n\n  return {\n    type: 'union',\n    of: references.map((name) => createReferenceTypeNode(name)),\n  }\n}\n\n// Traverse the reference type tree and gather all the reference names\nfunction gatherReferenceNames(type: ReferenceSchemaType): string[] {\n  const allReferences = gatherReferenceTypes(type)\n  // Remove duplicates\n  return [...new Set([...allReferences.map((ref) => ref.name)])]\n}\n\nfunction gatherReferenceTypes(type: ReferenceSchemaType): ObjectSchemaType[] {\n  const refTo = 'to' in type ? type.to : []\n  if ('type' in type && isReferenceType(type.type!)) {\n    return [...gatherReferenceTypes(type.type), ...refTo]\n  }\n\n  return refTo\n}\n\n// Traverse the type tree and gather all the fields\nfunction gatherFields(type: SanitySchemaType | ObjectSchemaType): ObjectField[] {\n  if ('fields' in type) {\n    return type.type ? gatherFields(type.type).concat(type.fields) : type.fields\n  }\n\n  return []\n}\n\n// Traverse the type tree and check if the type or any of its subtypes are of the given type\nfunction isType(\n  typeDef: SanitySchemaType | ObjectField | ObjectFieldType,\n  typeName: string,\n): boolean {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (type.name === typeName || (type.type && type.type.name === typeName)) {\n      return true\n    }\n\n    type = type.type\n  }\n  return false\n}\n\n// Traverse the type tree and return the \"last\" type, ie deepest type in the tree\nfunction lastType(typeDef: SanitySchemaType): SanitySchemaType | undefined {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (!type.type) {\n      return type\n    }\n    type = type.type\n  }\n\n  return undefined\n}\n\n// Sorts the types by their dependencies by using a topological sort depth-first algorithm.\nfunction sortByDependencies(compiledSchema: SchemaDef): string[] {\n  const seen = new Set<SanitySchemaType>()\n\n  // Walks the dependencies of a schema type and adds them to the dependencies set\n  function walkDependencies(\n    schemaType: SanitySchemaType,\n    dependencies: Set<SanitySchemaType>,\n  ): void {\n    if (seen.has(schemaType)) {\n      return\n    }\n    seen.add(schemaType)\n\n    if ('fields' in schemaType) {\n      for (const field of gatherFields(schemaType)) {\n        const last = lastType(field.type)\n        if (last!.name === 'document') {\n          dependencies.add(last!)\n          continue\n        }\n\n        let schemaTypeName: string | undefined\n        if (schemaType.type!.type) {\n          schemaTypeName = field.type.type!.name\n        } else if ('jsonType' in schemaType.type!) {\n          schemaTypeName = field.type.jsonType\n        }\n\n        if (schemaTypeName === 'object' || schemaTypeName === 'block') {\n          if (isReferenceType(field.type)) {\n            field.type.to.forEach((ref) => dependencies.add(ref.type!))\n          } else {\n            dependencies.add(field.type)\n          }\n        }\n        walkDependencies(field.type, dependencies)\n      }\n    } else if ('of' in schemaType) {\n      for (const item of schemaType.of) {\n        walkDependencies(item, dependencies)\n      }\n    }\n  }\n  const dependencyMap = new Map<SanitySchemaType, Set<SanitySchemaType>>()\n  compiledSchema.getTypeNames().forEach((typeName) => {\n    const schemaType = compiledSchema.get(typeName)\n    if (schemaType === undefined || schemaType.type === null) {\n      return\n    }\n    const dependencies = new Set<SanitySchemaType>()\n\n    walkDependencies(schemaType, dependencies)\n    dependencyMap.set(schemaType, dependencies)\n    seen.clear() // Clear the seen set for the next type\n  })\n\n  // Sorts the types by their dependencies\n  const typeNames: string[] = []\n  // holds a temporary mark for types that are currently being visited, to detect cyclic dependencies\n  const currentlyVisiting = new Set<SanitySchemaType>()\n\n  // holds a permanent mark for types that have been already visited\n  const visited = new Set<SanitySchemaType>()\n\n  // visit implements a depth-first search\n  function visit(type: SanitySchemaType) {\n    if (visited.has(type)) {\n      return\n    }\n    // If we find a type that is already in the temporary mark, we have a cyclic dependency.\n    if (currentlyVisiting.has(type)) {\n      return\n    }\n    // mark this as a temporary mark, meaning it's being visited\n    currentlyVisiting.add(type)\n    const deps = dependencyMap.get(type)\n    if (deps !== undefined) {\n      deps.forEach((dep) => visit(dep))\n    }\n    currentlyVisiting.delete(type)\n    visited.add(type)\n\n    if (!typeNames.includes(type.name)) {\n      typeNames.unshift(type.name)\n    }\n  }\n  // Visit all types in the dependency map\n  for (const [type] of dependencyMap) {\n    visit(type)\n  }\n\n  return typeNames\n}\n","import {type SchemaValidationResult} from '../typedefs'\n\n// Temporary solution to ensure we have a central registry over used helpIds\nexport const HELP_IDS = {\n  TYPE_INVALID: 'schema-type-invalid',\n  TYPE_IS_ESM_MODULE: 'schema-type-is-esm-module',\n  TYPE_NAME_RESERVED: 'schema-type-name-reserved',\n  TYPE_MISSING_NAME: 'schema-type-missing-name-or-type',\n  TYPE_MISSING_TYPE: 'schema-type-missing-name-or-type',\n  TYPE_TITLE_RECOMMENDED: 'schema-type-title-is-recommended',\n  TYPE_TITLE_INVALID: 'schema-type-title-is-recommended',\n  OBJECT_FIELDS_INVALID: 'schema-object-fields-invalid',\n  OBJECT_FIELD_NOT_UNIQUE: 'schema-object-fields-invalid',\n  OBJECT_FIELD_NAME_INVALID: 'schema-object-fields-invalid',\n  OBJECT_FIELD_DEFINITION_INVALID_TYPE: 'schema-object-fields-invalid',\n  ARRAY_PREDEFINED_CHOICES_INVALID: 'schema-predefined-choices-invalid',\n  ARRAY_OF_ARRAY: 'schema-array-of-array',\n  ARRAY_OF_INVALID: 'schema-array-of-invalid',\n  ARRAY_OF_NOT_UNIQUE: 'schema-array-of-invalid',\n  ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: 'schema-array-of-type-global-type-conflict',\n  ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: 'schema-array-of-type-builtin-type-conflict',\n  REFERENCE_TO_INVALID: 'schema-reference-to-invalid',\n  REFERENCE_TO_NOT_UNIQUE: 'schema-reference-to-invalid',\n  REFERENCE_INVALID_OPTIONS: 'schema-reference-invalid-options',\n  REFERENCE_INVALID_OPTIONS_LOCATION: 'schema-reference-options-nesting',\n  REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: 'schema-reference-filter-params-combination',\n  SLUG_SLUGIFY_FN_RENAMED: 'slug-slugifyfn-renamed',\n  ASSET_METADATA_FIELD_INVALID: 'asset-metadata-field-invalid',\n  CROSS_DATASET_REFERENCE_INVALID: 'cross-dataset-reference-invalid',\n  GLOBAL_DOCUMENT_REFERENCE_INVALID: 'global-document-reference-invalid',\n  DEPRECATED_BLOCKEDITOR_KEY: 'schema-deprecated-blockeditor-key',\n  STANDALONE_BLOCK_TYPE: 'schema-standalone-block-type',\n}\n\nfunction createValidationResult(\n  severity: SchemaValidationResult['severity'],\n  message: string,\n  helpId: string | null,\n): SchemaValidationResult {\n  if (helpId && !Object.keys(HELP_IDS).some((id) => (HELP_IDS as any)[id] === helpId)) {\n    throw new Error(\n      `Used the unknown helpId \"${helpId}\", please add it to the array in createValidationResult.js`,\n    )\n  }\n  return {\n    severity,\n    message,\n    helpId: helpId!,\n  }\n}\n\nexport const error = (message: string, helpId?: string | null): SchemaValidationResult =>\n  createValidationResult('error', message, helpId!)\n\nexport const warning = (message: string, helpId?: string | null): SchemaValidationResult =>\n  createValidationResult('warning', message, helpId!)\n","import {\n  type SchemaType,\n  type SchemaTypeDefinition,\n  type SchemaValidationProblemGroup,\n} from '@sanity/types'\nimport {flatten, get} from 'lodash'\n\nimport {type ProblemPath, type ProblemPathPropertySegment, type TypeWithProblems} from './typedefs'\nimport {error} from './validation/createValidationResult'\n\n/**\n * @internal\n */\nexport function groupProblems(types: SchemaTypeDefinition[]): SchemaValidationProblemGroup[] {\n  return flatten<TypeWithProblems>(types.map((type) => getTypeProblems(type))).filter(\n    (type) => type.problems.length > 0,\n  )\n}\n\nfunction createTypeWithMembersProblemsAccessor(\n  memberPropertyName: string,\n  getMembers = (type: SchemaType) => get(type, memberPropertyName),\n) {\n  return function getProblems(type: any, parentPath: ProblemPath): TypeWithProblems[] {\n    const currentPath: ProblemPath = [\n      ...parentPath,\n      {kind: 'type', type: type.type, name: type.name},\n    ]\n\n    const members = getMembers(type) || []\n\n    const memberProblems: TypeWithProblems[][] = Array.isArray(members)\n      ? members.map((memberType) => {\n          const propertySegment: ProblemPathPropertySegment = {\n            kind: 'property',\n            name: memberPropertyName,\n          }\n          const memberPath: ProblemPath = [...currentPath, propertySegment]\n          return getTypeProblems(memberType, memberPath as any)\n        })\n      : [\n          [\n            {\n              path: currentPath,\n              problems: [error(`Member declaration (${memberPropertyName}) is not an array`)],\n            },\n          ],\n        ]\n\n    return [\n      {\n        path: currentPath,\n        problems: type._problems || [],\n      },\n      ...flatten(memberProblems),\n    ]\n  }\n}\n\nconst arrify = (val: any) =>\n  Array.isArray(val) ? val : (typeof val === 'undefined' && []) || [val]\n\nconst getObjectProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getImageProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getFileProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getArrayProblems = createTypeWithMembersProblemsAccessor('of')\nconst getReferenceProblems = createTypeWithMembersProblemsAccessor('to', (type) =>\n  'to' in type ? arrify(type.to) : [],\n)\nconst getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor('marks.annotations')\nconst getBlockMemberProblems = createTypeWithMembersProblemsAccessor('of')\nconst getBlockProblems = (type: any, problems: any) => [\n  ...getBlockAnnotationProblems(type, problems),\n  ...getBlockMemberProblems(type, problems),\n]\n\nfunction getDefaultProblems(type: any, path = []): TypeWithProblems[] {\n  return [\n    {\n      path: [...path, {kind: 'type', type: type.type, name: type.name}],\n      problems: type._problems || [],\n    },\n  ]\n}\n\nfunction getTypeProblems(type: SchemaTypeDefinition, path = []): TypeWithProblems[] {\n  switch (type.type) {\n    case 'object': {\n      return getObjectProblems(type, path)\n    }\n    case 'document': {\n      return getObjectProblems(type, path)\n    }\n    case 'array': {\n      return getArrayProblems(type, path)\n    }\n    case 'reference': {\n      return getReferenceProblems(type, path)\n    }\n    case 'block': {\n      return getBlockProblems(type, path)\n    }\n    case 'image': {\n      return getImageProblems(type, path)\n    }\n    case 'file': {\n      return getFileProblems(type, path)\n    }\n    default: {\n      return getDefaultProblems(type, path)\n    }\n  }\n}\n","export function getDupes(array: any, selector = (v: any) => v) {\n  const dupes = array.reduce((acc: any, item: any) => {\n    const key = selector(item)\n    if (!acc[key]) {\n      acc[key] = []\n    }\n    acc[key].push(item)\n    return acc\n  }, {})\n\n  return Object.keys(dupes)\n    .map((key) => (dupes[key].length > 1 ? dupes[key] : null))\n    .filter(Boolean)\n}\n","import {flatten, uniq} from 'lodash'\n\nimport {getDupes} from '../sanity/validation/utils/getDupes'\n\ntype SchemaType = Record<string, any>\ntype SchemaTypeDef = Record<string, any>\n\ntype VisitContext = {\n  isRoot: boolean\n  isReserved: (typeName: string) => boolean\n  visit: Visitor\n  index: number\n  isDuplicate: (typeName: string) => boolean\n  getType: (typeName: string) => null | SchemaType\n  getTypeNames: () => Array<string>\n}\n\nexport type Visitor = (typeDef: SchemaTypeDef, arg1: VisitContext) => SchemaType\n\nconst NOOP_VISITOR: Visitor = (typeDef) => typeDef\n\nexport class UnknownType {\n  name: string\n\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nconst TYPE_TYPE = {name: 'type', type: null}\n\nconst FUTURE_RESERVED = ['any', 'time', 'date']\n\nexport function traverseSchema(\n  types: SchemaTypeDef[] = [],\n  coreTypes: SchemaTypeDef[] = [],\n  visitor: Visitor = NOOP_VISITOR,\n) {\n  const coreTypesRegistry = Object.create(null)\n  const registry = Object.create(null)\n\n  const coreTypeNames = coreTypes.map((typeDef) => typeDef.name)\n\n  const reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames)\n\n  const typeNames = types.map((typeDef) => typeDef && typeDef.name).filter(Boolean)\n\n  coreTypes.forEach((coreType) => {\n    coreTypesRegistry[coreType.name] = coreType\n  })\n\n  types.forEach((type, i) => {\n    // Allocate a placeholder for each type\n    registry[(type && type.name) || `__unnamed_${i}`] = {}\n  })\n\n  function getType(typeName: any) {\n    return typeName === 'type'\n      ? TYPE_TYPE\n      : coreTypesRegistry[typeName] || registry[typeName] || null\n  }\n\n  const duplicateNames = uniq(flatten(getDupes(typeNames)))\n\n  function isDuplicate(typeName: any) {\n    return duplicateNames.includes(typeName)\n  }\n  function getTypeNames() {\n    return typeNames.concat(coreTypeNames)\n  }\n  function isReserved(typeName: any) {\n    return typeName === 'type' || reservedTypeNames.includes(typeName)\n  }\n\n  const visitType = (isRoot: any) => (typeDef: any, index: any) => {\n    return visitor(typeDef, {\n      visit: visitType(false),\n      isRoot,\n      getType,\n      getTypeNames,\n      isReserved,\n      isDuplicate,\n      index,\n    })\n  }\n\n  coreTypes.forEach((coreTypeDef) => {\n    Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef))\n  })\n\n  types.forEach((typeDef, i) => {\n    Object.assign(\n      registry[(typeDef && typeDef.name) || `__unnamed_${i}`],\n      visitType(true)(typeDef, i),\n    )\n  })\n\n  return {\n    get(typeName: string) {\n      const res = registry[typeName] || coreTypesRegistry[typeName]\n      if (res) {\n        return res\n      }\n      throw new Error(`No such type: ${typeName}`)\n    },\n    has(typeName: string): boolean {\n      return typeName in registry || typeName in coreTypesRegistry\n    },\n    getTypeNames(): string[] {\n      return Object.keys(registry)\n    },\n    getTypes() {\n      return this.getTypeNames().map(this.get)\n    },\n    toJSON() {\n      return this.getTypes()\n    },\n  }\n}\n","const coreTypes = [\n  {name: 'array', jsonType: 'array', type: 'type'},\n  {name: 'block', jsonType: 'object', type: 'type'},\n  {name: 'boolean', jsonType: 'boolean', type: 'type'},\n  {name: 'datetime', jsonType: 'string', type: 'type'},\n  {name: 'date', jsonType: 'string', type: 'type'},\n  {name: 'document', jsonType: 'object', type: 'type'},\n  {name: 'email', jsonType: 'string', type: 'type'},\n  {name: 'file', jsonType: 'object', type: 'type'},\n  {name: 'geopoint', jsonType: 'object', type: 'type'},\n  {name: 'image', jsonType: 'object', type: 'type'},\n  {name: 'number', jsonType: 'number', type: 'type'},\n  {name: 'object', jsonType: 'object', type: 'type'},\n  {name: 'reference', jsonType: 'object', type: 'type'},\n  {name: 'crossDatasetReference', jsonType: 'object', type: 'type'},\n  {name: 'globalDocumentReference', jsonType: 'object', type: 'type'},\n  {name: 'slug', jsonType: 'object', type: 'type'},\n  {name: 'span', jsonType: 'object', type: 'type'},\n  {name: 'string', jsonType: 'string', type: 'type'},\n  {name: 'telephone', jsonType: 'string', type: 'type'},\n  {name: 'text', jsonType: 'string', type: 'type'},\n  {name: 'url', jsonType: 'string', type: 'type'},\n] as const\n\nexport const coreTypeNames = coreTypes.map((t) => t.name)\nexport default coreTypes\n","import {traverseSchema, type Visitor} from '../core/traverseSchema'\nimport coreTypes from './coreTypes'\nimport {type _FIXME_} from './typedefs'\n\nexport function traverseSanitySchema(schemaTypes: _FIXME_[], visitor: Visitor) {\n  return traverseSchema(schemaTypes, coreTypes as _FIXME_, visitor)\n}\n","import humanizeList from 'humanize-list'\nimport {flatten, partition} from 'lodash'\n\nimport {coreTypeNames} from '../../coreTypes'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction isPrimitiveTypeName(typeName: any) {\n  return typeName === 'string' || typeName === 'number' || typeName === 'boolean'\n}\n\nfunction isAssignable(typeName: any, type: any) {\n  return (typeof type.name === 'string' ? type.name : type.type) === typeName\n}\n\nfunction quote(n: any) {\n  return `\"${n}\"`\n}\n\nfunction pluralize(arr: unknown[], suf = 's') {\n  return arr.length === 1 ? '' : suf\n}\n\nfunction format(value: unknown) {\n  if (Array.isArray(value)) {\n    return `array with ${value.length} entries`\n  }\n  if (typeof value === 'object' && value !== null) {\n    return `object with keys ${humanizeList(Object.keys(value).map(quote))}`\n  }\n  return quote(value)\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  // name should already have been marked\n  const ofIsArray = Array.isArray(typeDef.of)\n\n  if (ofIsArray) {\n    const invalid = typeDef.of.reduce((errs: any, def: any, idx: any) => {\n      if (typeof def.name === 'string') {\n        // If an array member has been given a \"local\" type name, we want to trigger an error if the given member type name\n        // is one of the builtin types\n        //\n        // The following examples should be an error (where book is an existing root level type and reference is a built-in type):\n        //  - (…) of: [{type: 'book', name: 'image'}]\n        //  - (…) of: [{type: 'book', name: 'object'}]\n        //  - (…) of: [{type: 'object', name: 'reference'}]\n        // The following examples are valid (where \"address\" is not defined as a global object type)\n        //  - (…) of: [{type: 'object', name: 'address'}]\n        // The following examples are redundant, but should be allowed (at least for now)\n        //  - (…) of: [{type: 'object', name: 'object'}]\n        //  - (…) of: [{type: 'image', name: 'image'}]\n\n        if (\n          // specifying the same name as the type is redundant, but should not be a hard error at this point\n          // Consider showing a warning for this and deprecate this ability eventually\n          def.name !== def.type &&\n          coreTypeNames.includes(def.name)\n        ) {\n          return errs.concat(\n            error(\n              `Found array member declaration with the same type name as a built-in type (\"${def.name}\"). Array members can not be given the same name as a built-in type.`,\n              HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT,\n            ),\n          )\n        }\n      }\n\n      if (def.type === 'object' && def.name && visitorContext.getType(def.name)) {\n        return errs.concat(\n          warning(\n            `Found array member declaration with the same name as the global schema type \"${def.name}\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,\n            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT,\n          ),\n        )\n      }\n      if (def.type === 'array') {\n        return errs.concat(\n          error(\n            `Found array member declaration of type \"array\" - multidimensional arrays are not currently supported by Sanity`,\n            HELP_IDS.ARRAY_OF_ARRAY,\n          ),\n        )\n      }\n\n      if (def) {\n        return errs\n      }\n\n      const err = `Found ${def === null ? 'null' : typeof def}, expected member declaration`\n      return errs.concat(\n        error(\n          `Found invalid type member declaration in array at index ${idx}: ${err}`,\n          HELP_IDS.ARRAY_OF_INVALID,\n        ),\n      )\n    }, [])\n\n    if (invalid.length > 0) {\n      return {\n        ...typeDef,\n        of: [],\n        _problems: invalid,\n      }\n    }\n  }\n\n  const problems = flatten([\n    ofIsArray\n      ? getDupes(typeDef.of, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in array. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.ARRAY_OF_NOT_UNIQUE,\n          ),\n        )\n      : error(\n          'The array type is missing or having an invalid value for the required \"of\" property',\n          HELP_IDS.ARRAY_OF_INVALID,\n        ),\n  ])\n  const of = ofIsArray ? typeDef.of : []\n\n  // Don't allow object types without a name in block arrays\n  const hasObjectTypesWithoutName = of.some(\n    (type: any) => type.type === 'object' && typeof type.name === 'undefined',\n  )\n  const hasBlockType = of.some((ofType: any) => ofType.type === 'block')\n  if (hasBlockType && hasObjectTypesWithoutName) {\n    problems.push(\n      error(\n        \"The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.\",\n        HELP_IDS.ARRAY_OF_INVALID,\n      ),\n    )\n  }\n\n  const [primitiveTypes, objectTypes] = partition(\n    of,\n    (ofType) =>\n      isPrimitiveTypeName(ofType.type) ||\n      isPrimitiveTypeName(visitorContext.getType(ofType.type)?.jsonType),\n  )\n\n  const isMixedArray = primitiveTypes.length > 0 && objectTypes.length > 0\n\n  if (isMixedArray) {\n    const primitiveTypeNames = primitiveTypes.map((t) => t.type)\n    const objectTypeNames = objectTypes.map((t) => t.type)\n    problems.push(\n      error(\n        `The array type's 'of' property can't have both object types and primitive types (found primitive type ${pluralize(\n          primitiveTypeNames,\n        )} ${humanizeList(primitiveTypeNames.map(quote))} and object type${pluralize(\n          objectTypeNames,\n        )} ${humanizeList(objectTypeNames.map(quote))})`,\n        HELP_IDS.ARRAY_OF_INVALID,\n      ),\n    )\n  }\n\n  const list = typeDef?.options?.list\n  if (!isMixedArray && Array.isArray(list)) {\n    const isArrayOfPrimitives = primitiveTypes.length > 0\n    if (isArrayOfPrimitives) {\n      list.forEach((option) => {\n        const value = option?.value ?? option\n        const isDeclared = primitiveTypes.some((primitiveType) => {\n          return typeof value === visitorContext.getType(primitiveType.type).jsonType\n        })\n        if (!isDeclared) {\n          const formattedTypeList = humanizeList(\n            primitiveTypes.map((t) => t.name || t.type),\n            {conjunction: 'or'},\n          )\n          problems.push(\n            error(\n              `An invalid entry found in options.list: ${format(\n                value,\n              )}. Must be either a value of type ${formattedTypeList}, or an object with {title: string, value: ${formattedTypeList}}`,\n              HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID,\n            ),\n          )\n        }\n      })\n    } else {\n      list.forEach((option) => {\n        const optionTypeName = option._type || 'object'\n        const isDeclared = objectTypes.some((validObjectType) =>\n          isAssignable(optionTypeName, validObjectType),\n        )\n        if (!isDeclared) {\n          problems.push(\n            error(\n              `An invalid entry found in options.list: ${format(\n                option,\n              )}. Must be an object with \"_type\" set to ${humanizeList(\n                objectTypes\n                  .map((t) => t.name || t.type)\n                  .map((t) => (t === 'object' ? 'undefined' : quote(t))),\n                {conjunction: 'or'},\n              )}`,\n              HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID,\n            ),\n          )\n        }\n      })\n    }\n  }\n\n  if (typeDef?.options?.list && typeDef?.options?.layout === 'tags') {\n    problems.push(\n      warning(\n        'Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`.',\n      ),\n    )\n  }\n\n  return {\n    ...typeDef,\n    of: of.map(visitorContext.visit),\n    _problems: problems,\n  }\n}\n","export function isJSONTypeOf(type: any, jsonType: any, visitorContext: any) {\n  if ('jsonType' in type) {\n    return type.jsonType === jsonType\n  }\n  const parentType = visitorContext.getType(type.type)\n  if (!parentType) {\n    throw new Error(`Could not resolve jsonType of ${type.name}. No parent type found`)\n  }\n  return isJSONTypeOf(parentType, jsonType, visitorContext)\n}\n","import humanizeList from 'humanize-list'\nimport {isPlainObject, omit} from 'lodash'\n\nimport {coreTypeNames} from '../../coreTypes'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {isJSONTypeOf} from '../utils/isJSONTypeOf'\n\nconst getTypeOf = (thing: any) => (Array.isArray(thing) ? 'array' : typeof thing)\nconst quote = (str: any) => `\"${str}\"`\nconst allowedKeys = [\n  'components',\n  'lists',\n  'marks',\n  'name',\n  'of',\n  'options',\n  'styles',\n  'title',\n  'type',\n  'validation',\n]\nconst allowedMarkKeys = ['decorators', 'annotations']\nconst allowedStyleKeys = ['blockEditor', 'title', 'value', 'icon', 'component']\nconst allowedDecoratorKeys = ['blockEditor', 'title', 'value', 'icon', 'component']\nconst allowedListKeys = ['title', 'value', 'icon', 'component']\nconst supportedBuiltInObjectTypes = [\n  'file',\n  'image',\n  'object',\n  'reference',\n  'crossDatasetReference',\n  'globalDocumentReference',\n]\n\nexport default function validateBlockType(typeDef: any, visitorContext: any) {\n  const problems = []\n  let styles = typeDef.styles\n  let lists = typeDef.lists\n  let marks = typeDef.marks\n  let members = typeDef.of\n\n  const disallowedKeys = Object.keys(typeDef).filter(\n    (key) => !allowedKeys.includes(key) && !key.startsWith('_'),\n  )\n\n  if (disallowedKeys.length > 0) {\n    problems.push(\n      error(\n        `Found unknown properties for block declaration: ${humanizeList(\n          disallowedKeys.map(quote),\n        )}`,\n      ),\n    )\n  }\n\n  if (marks) {\n    marks = validateMarks(typeDef.marks, visitorContext, problems)\n  }\n\n  if (styles) {\n    styles = validateStyles(styles, visitorContext, problems)\n  }\n\n  if (lists) {\n    lists = validateLists(lists, visitorContext, problems)\n  }\n\n  if (members) {\n    members = validateMembers(members, visitorContext, problems)\n  }\n  return {\n    ...omit(typeDef, disallowedKeys),\n    marks,\n    styles,\n    name: typeDef.name || typeDef.type,\n    of: members,\n    _problems: problems,\n  }\n}\n\nfunction validateMarks(marks: any, visitorContext: any, problems: any) {\n  let decorators = marks.decorators\n  let annotations = marks.annotations\n\n  if (!isPlainObject(marks)) {\n    problems.push(error(`\"marks\" declaration should be an object, got ${getTypeOf(marks)}`))\n    return problems\n  }\n\n  const disallowedMarkKeys = Object.keys(marks).filter(\n    (key) => !allowedMarkKeys.includes(key) && !key.startsWith('_'),\n  )\n\n  if (disallowedMarkKeys.length > 0) {\n    problems.push(\n      error(\n        `Found unknown properties for block declaration: ${humanizeList(\n          disallowedMarkKeys.map(quote),\n        )}`,\n      ),\n    )\n  }\n\n  if (decorators && !Array.isArray(decorators)) {\n    problems.push(\n      error(`\"marks.decorators\" declaration should be an array, got ${getTypeOf(decorators)}`),\n    )\n  } else if (decorators) {\n    decorators\n      .filter((dec: any) => !!dec.blockEditor)\n      .forEach((dec: any) => {\n        dec.icon = dec.blockEditor.icon\n        dec.component = dec.blockEditor.render\n      })\n    decorators = validateDecorators(decorators, visitorContext, problems)\n  }\n\n  if (annotations && !Array.isArray(annotations)) {\n    problems.push(\n      error(`\"marks.annotations\" declaration should be an array, got ${getTypeOf(annotations)}`),\n    )\n  } else if (annotations) {\n    annotations = validateAnnotations(annotations, visitorContext, problems)\n  }\n\n  return {...marks, decorators, annotations}\n}\n\nfunction validateLists(lists: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(lists)) {\n    problems.push(error(`\"lists\" declaration should be an array, got ${getTypeOf(lists)}`))\n    return problems\n  }\n\n  lists.forEach((list, index) => {\n    if (!isPlainObject(list)) {\n      problems.push(error(`List must be an object, got ${getTypeOf(list)}`))\n      return\n    }\n\n    const name = list.value || `#${index}`\n    const disallowedKeys = Object.keys(list).filter(\n      (key) => !allowedListKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for list ${name}: ${humanizeList(disallowedKeys.map(quote))}`,\n        ),\n      )\n    }\n\n    if (!list.value) {\n      problems.push(error(`List #${index} is missing required \"value\" property`))\n    } else if (typeof list.value !== 'string') {\n      problems.push(\n        error(\n          `List type #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            list.value,\n          )}`,\n        ),\n      )\n    } else if (!list.title) {\n      problems.push(warning(`List type ${name} is missing recommended \"title\" property`))\n    }\n  })\n  return lists\n}\n\nfunction validateStyles(styles: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(styles)) {\n    problems.push(error(`\"styles\" declaration should be an array, got ${getTypeOf(styles)}`))\n    return problems\n  }\n\n  styles.forEach((style, index) => {\n    if (!isPlainObject(style)) {\n      problems.push(error(`Style must be an object, got ${getTypeOf(style)}`))\n      return\n    }\n\n    const name = style.value || `#${index}`\n    const disallowedKeys = Object.keys(style).filter(\n      (key) => !allowedStyleKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for style ${name}: ${humanizeList(disallowedKeys.map(quote))}`,\n        ),\n      )\n    }\n\n    if (!style.value) {\n      problems.push(error(`Style #${index} is missing required \"value\" property`))\n    } else if (typeof style.value !== 'string') {\n      problems.push(\n        error(\n          `Style #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            style.value,\n          )}`,\n        ),\n      )\n    } else if (!style.title) {\n      problems.push(warning(`Style ${name} is missing recommended \"title\" property`))\n    }\n    if (typeof style.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Style has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      style.component = style.component || style.blockEditor.render\n    }\n  })\n  return styles\n}\n\nfunction validateDecorators(decorators: any, visitorContext: any, problems: any) {\n  decorators.forEach((decorator: any, index: any) => {\n    if (!isPlainObject(decorator)) {\n      problems.push(error(`Annotation must be an object, got ${getTypeOf(decorator)}`))\n      return\n    }\n\n    const name = decorator.value || `#${index}`\n    const disallowedKeys = Object.keys(decorator).filter(\n      (key) => !allowedDecoratorKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for decorator ${name}: ${humanizeList(\n            disallowedKeys.map(quote),\n          )}`,\n        ),\n      )\n    }\n\n    if (!decorator.value) {\n      problems.push(error(`Decorator #${index} is missing required \"value\" property`))\n    } else if (typeof decorator.value !== 'string') {\n      problems.push(\n        error(\n          `Decorator #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            decorator.value,\n          )}`,\n        ),\n      )\n    } else if (!decorator.title) {\n      problems.push(warning(`Decorator ${name} is missing recommended \"title\" property`))\n    }\n    if (typeof decorator.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Decorator \"${name}\" has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      decorator.icon = decorator.icon || decorator.blockEditor.icon\n      decorator.component = decorator.component || decorator.blockEditor.render\n    }\n  })\n  return decorators\n}\n\nfunction validateAnnotations(annotations: any, visitorContext: any, problems: any) {\n  return annotations.map((annotation: any) => {\n    if (!isPlainObject(annotation)) {\n      return {\n        ...annotation,\n        _problems: [error(`Annotation must be an object, got ${getTypeOf(annotation)}`)],\n      }\n    }\n\n    const {_problems} = visitorContext.visit(annotation, visitorContext)\n    const targetType = annotation.type && visitorContext.getType(annotation.type)\n    if (targetType && !isJSONTypeOf(targetType, 'object', visitorContext)) {\n      _problems.push(\n        error(\n          `Annotation cannot have type \"${annotation.type}\" - annotation types must inherit from object`,\n        ),\n      )\n    }\n\n    if (typeof annotation.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Annotation has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      annotation.icon = annotation.icon || annotation.blockEditor.icon\n      if (annotation.blockEditor?.render && !annotation.components?.annotation) {\n        annotation.components = annotation.components || {}\n        annotation.components.annotation =\n          annotation.components.annotation || annotation.blockEditor.render\n      }\n    }\n\n    return {...annotation, _problems}\n  })\n}\n\nfunction validateMembers(members: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(members)) {\n    problems.push(error(`\"of\" declaration should be an array, got ${getTypeOf(members)}`))\n    return undefined\n  }\n\n  return members.map((member) => {\n    const {_problems} = visitorContext.visit(member, visitorContext)\n    if (member.type === 'object' && member.name && visitorContext.getType(member.name)) {\n      return {\n        ...member,\n        _problems: [\n          warning(\n            `Found array member declaration with the same name as the global schema type \"${member.name}\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,\n            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT,\n          ),\n        ],\n      }\n    }\n\n    // Test that each member is of a support object-like type\n    let type = member\n    while (type && !type.jsonType) {\n      type = visitorContext.getType(type.type)\n    }\n    const nonObjectCoreTypes = coreTypeNames.filter((n) => !supportedBuiltInObjectTypes.includes(n))\n    if (\n      // Must be object-like type (to validate hoisted types)\n      (type && type.jsonType !== 'object') ||\n      // Can't be a core type, or core object type that isn't supported (like 'span')\n      nonObjectCoreTypes.some((coreName) => coreName === member.type)\n    ) {\n      return {\n        ...member,\n        _problems: [\n          error(\n            `Block member types must be a supported object-like type. The following built-in types are supported: '${supportedBuiltInObjectTypes.join(\n              \"', '\",\n            )}'. You can also use shorthands for previously defined object types like {type: 'myObjectType'}`,\n            HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT,\n          ),\n        ],\n      }\n    }\n    return {...member, _problems}\n  })\n}\n","import {type SchemaType} from '@sanity/types'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error} from '../createValidationResult'\n\nexport function validateNonObjectFieldsProp(\n  typeDef: SchemaType,\n  visitorContext: any,\n): SchemaValidationResult[] {\n  if (!('fields' in typeDef)) {\n    return []\n  }\n\n  let type = typeDef\n  while (type && !type.jsonType) {\n    type = visitorContext.getType(type.type)\n  }\n\n  if (type && type.jsonType !== 'object') {\n    return [error(`Type has propery \"fields\", but is not an object/document type.`)]\n  }\n\n  return []\n}\n","import humanize from 'humanize-list'\nimport leven from 'leven'\n\nimport {error, HELP_IDS} from '../createValidationResult'\n\nconst quote = (str: any) => `\"${str}\"`\n\nexport function validateTypeName(typeName: string, visitorContext: any) {\n  const possibleTypeNames = visitorContext.getTypeNames()\n\n  if (!typeName) {\n    return [error(`Type is missing a type.`, HELP_IDS.TYPE_MISSING_TYPE)]\n  }\n\n  if (typeof typeName !== 'string') {\n    return [\n      error(\n        `Type has an invalid \"type\"-property - should be a string.`,\n        HELP_IDS.TYPE_MISSING_TYPE,\n      ),\n    ]\n  }\n\n  const isValid = possibleTypeNames.includes(typeName)\n\n  if (!isValid) {\n    const suggestions = possibleTypeNames\n      .map((possibleTypeName: any) => {\n        return [leven(typeName, possibleTypeName), possibleTypeName]\n      })\n      .filter(([distance]: any) => distance < 3)\n      .map(([_, name]: any) => name)\n\n    const suggestion =\n      suggestions.length > 0\n        ? ` Did you mean ${humanize(suggestions.map(quote), {conjunction: 'or'})}?`\n        : ''\n\n    return [error(`Unknown type: ${typeName}.${suggestion}`)]\n  }\n  return []\n}\n","import {type SchemaValidationResult} from '../../typedefs'\nimport {warning} from '../createValidationResult'\n\nexport function validateDeprecatedProperties(type: any): SchemaValidationResult[] {\n  const warnings = []\n\n  if (type?.inputComponent) {\n    warnings.push(\n      warning(`The \"inputComponent\" property is deprecated. Use \"components.input\" instead.`),\n    )\n  }\n\n  if (type?.preview?.component) {\n    warnings.push(\n      warning(`The \"preview.component\" property is deprecated. Use \"components.preview\" instead.`),\n    )\n  }\n\n  if (type?.diffComponent) {\n    warnings.push(\n      warning(`The \"diffComponent\" property is deprecated. Use \"components.diff\" instead.`),\n    )\n  }\n\n  if (type?.options?.editModal) {\n    warnings.push(\n      warning(`The \"options.editModal\" property is deprecated. Use \"options.modal\" instead.`),\n    )\n  }\n\n  if (type?.options?.isHighlighted) {\n    warnings.push(\n      warning(\n        `The \"options.isHighlighted\" property is deprecated. You can put fields behind a collapsed fieldset if you want to hide them from plain sight.`,\n      ),\n    )\n  }\n\n  return warnings\n}\n","import {validateNonObjectFieldsProp} from '../utils/validateNonObjectFieldsProp'\nimport {validateTypeName} from '../utils/validateTypeName'\nimport {validateDeprecatedProperties} from './deprecated'\n\nexport default (typeDef: any, visitorContext: any) => {\n  return {\n    ...typeDef,\n    _problems: [\n      ...validateTypeName(typeDef.type, visitorContext),\n      ...validateNonObjectFieldsProp(typeDef, visitorContext),\n      ...validateDeprecatedProperties(typeDef),\n    ].filter(Boolean),\n  }\n}\n","import {flatten, isPlainObject} from 'lodash'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error, HELP_IDS} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction normalizeToProp(typeDef: any) {\n  if (Array.isArray(typeDef.to)) {\n    return typeDef.to\n  }\n  return typeDef.to ? [typeDef.to] : typeDef.to\n}\n\nconst VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/\nexport function isValidDatasetName(name: string): string | true {\n  const isValid = name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name)\n  return (\n    isValid ||\n    `The provided dataset \"${name}\" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore`\n  )\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to)\n  const normalizedTo = normalizeToProp(typeDef)\n\n  const problems = flatten([\n    isValidTo\n      ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n          ),\n        )\n      : error(\n          'The cross dataset reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n  ])\n\n  if (isValidTo && normalizedTo.length === 0) {\n    problems.push(\n      error(\n        'The cross dataset reference type should define at least one referenced type. Please check the \"to\" property.',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  normalizedTo.forEach((crossDatasetTypeDef: any, index: any) => {\n    if (!crossDatasetTypeDef.type) {\n      problems.push(\n        error(\n          `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n      )\n    }\n\n    if (!isPlainObject(crossDatasetTypeDef.preview)) {\n      problems.push(\n        error(\n          `Missing required preview config for the referenced type \"${\n            crossDatasetTypeDef.type || '<unknown type>'\n          }\"`,\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n      )\n    }\n  })\n\n  if (typeof typeDef.dataset === 'string') {\n    const datasetValidation = isValidDatasetName(typeDef.dataset)\n    if (datasetValidation !== true) {\n      problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID))\n    }\n  } else {\n    problems.push(\n      error(\n        'A cross dataset reference must specify a `dataset`',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  if (typeDef.studioUrl && typeof typeDef.studioUrl !== 'function') {\n    problems.push(\n      error(\n        'The \"studioUrl\" property on a cross dataset reference must be a function taking \"{id, type}\" as argument and returning a studio url.',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  problems.push(...getOptionErrors(typeDef))\n\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n\nfunction getOptionErrors(typeDef: any): SchemaValidationResult[] {\n  const {options} = typeDef\n  const problems = [] as SchemaValidationResult[]\n\n  problems.push(\n    ...['filter', 'filterParams']\n      .filter((key) => key in typeDef)\n      .map((key) =>\n        error(\n          `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n          HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION,\n        ),\n      ),\n  )\n\n  if (!options) {\n    return problems\n  }\n\n  if (!isPlainObject(options)) {\n    return problems.concat(\n      error(\n        'The reference type expects `options` to be an object',\n        HELP_IDS.REFERENCE_INVALID_OPTIONS,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {\n    return problems.concat(\n      error(\n        '`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.',\n        HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {\n    return problems\n  }\n\n  if (typeof options.filter !== 'string') {\n    return problems.concat(\n      error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`),\n    )\n  }\n\n  if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {\n    return problems.concat(error(`If set, \\`filterParams\\` must be an object.`))\n  }\n\n  if (options.filterParams) {\n    return problems.concat(\n      Object.keys(options.filterParams)\n        .filter((key) => key.startsWith('__') || key.startsWith('$'))\n        .map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`)),\n    )\n  }\n\n  return problems\n}\n","const REACT_SYM_RE = /^Symbol\\(react\\..+\\)$/\n\nexport function isComponentLike(value: any) {\n  const type = typeof value\n  // Note: we're not using `isValidElementType` from react-is here since it accepts too much, e.g. any strings.\n  return (\n    type === 'function' ||\n    (typeof value?.$$typeof === 'symbol' && REACT_SYM_RE.test(String(value?.$$typeof)))\n  )\n}\n","import inspect from '../../inspect'\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {warning} from '../createValidationResult'\nimport {isComponentLike} from './isComponent'\n\nexport function validateComponent(typeDef: any): SchemaValidationResult[] {\n  const components = 'components' in typeDef ? typeDef.components : false\n  if (!components) {\n    return []\n  }\n\n  const warnings: SchemaValidationResult[] = []\n\n  if (components.input && !isComponentLike(components.input)) {\n    warnings.push(\n      warning(\n        `The \\`components.input\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.input,\n        )}). If you have imported a custom input component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.field && !isComponentLike(components.field)) {\n    warnings.push(\n      warning(\n        `The \\`components.field\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.field,\n        )}). If you have imported a custom field component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.item && !isComponentLike(components.item)) {\n    warnings.push(\n      warning(\n        `The \\`components.item\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.item,\n        )}). If you have imported a custom item component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.preview && !isComponentLike(components.preview)) {\n    warnings.push(\n      warning(\n        `The \\`components.preview\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.preview,\n        )}). If you have imported a custom preview component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  return warnings\n}\n","import {isPlainObject} from 'lodash'\n\nimport inspect from '../../inspect'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateComponent} from '../utils/validateComponent'\n\nconst VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/\nconst CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/\ninterface Field {\n  name: string\n}\n\ninterface PreviewConfig {\n  select?: {\n    [key: string]: string\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  prepare?: Function\n}\n\nfunction validateFieldName(name: any): Array<any> {\n  if (typeof name !== 'string') {\n    return [\n      error(\n        `Field names must be strings. Saw \"${inspect(name)}\"`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n  if (name.startsWith('_')) {\n    return [\n      error(\n        `Invalid field name \"${name}\". Field names cannot start with underscores \"_\" as it's reserved for system fields.`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n\n  if (!VALID_FIELD_RE.test(name)) {\n    return [\n      error(\n        `Invalid field name: \"${name}\". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ${String(\n          VALID_FIELD_RE,\n        )}).`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n  if (!CONVENTIONAL_FIELD_RE.test(name)) {\n    return [\n      warning(\n        'Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional?' +\n          ' It may be wise to keep special characters out of field names for easier access later on.',\n      ),\n      HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n    ]\n  }\n  return []\n}\n\nexport function validateField(field: any, _visitorContext: any) {\n  if (!isPlainObject(field)) {\n    return [\n      error(\n        `Incorrect type for field definition - should be an object, saw ${inspect(field)}`,\n        HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE,\n      ),\n    ]\n  }\n\n  const problems = []\n  problems.push(\n    ...('name' in field\n      ? validateFieldName(field.name)\n      : [error('Missing field name', HELP_IDS.OBJECT_FIELD_NAME_INVALID)]),\n  )\n  problems.push(...validateComponent(field))\n  return problems\n}\n\nfunction getDuplicateFields(array: Array<Field>): Array<Array<Field> | null> {\n  const dupes: {[name: string]: Array<Field>} = {}\n  array.forEach((field) => {\n    if (!dupes[field.name]) {\n      dupes[field.name] = []\n    }\n    dupes[field.name].push(field)\n  })\n  return Object.keys(dupes)\n    .map((fieldName) => (dupes[fieldName].length > 1 ? dupes[fieldName] : null))\n    .filter(Boolean)\n}\n\nexport function validateFields(fields: any, options = {allowEmpty: false}) {\n  const problems = []\n  const fieldsIsArray = Array.isArray(fields)\n  if (!fieldsIsArray) {\n    return [\n      error(\n        `The \"fields\" property must be an array of fields. Instead saw \"${typeof fields}\"`,\n        HELP_IDS.OBJECT_FIELDS_INVALID,\n      ),\n    ]\n  }\n\n  const fieldsWithNames = fields.filter((field) => typeof field.name === 'string')\n\n  getDuplicateFields(fieldsWithNames).forEach((dupes) => {\n    problems.push(\n      error(\n        `Found ${dupes!.length} fields with name \"${dupes![0].name}\" in object`,\n        HELP_IDS.OBJECT_FIELD_NOT_UNIQUE,\n      ),\n    )\n  })\n\n  if (fields.length === 0 && !options.allowEmpty) {\n    problems.push(error('Object should have at least one field', HELP_IDS.OBJECT_FIELDS_INVALID))\n  }\n\n  const standaloneBlockFields = fields\n    .filter((field) => field.type === 'block')\n    .map((field) => `\"${field.name}\"`)\n\n  if (standaloneBlockFields.length > 0) {\n    const fmtFields = standaloneBlockFields.join(', ')\n    problems.push(\n      error(\n        `Invalid standalone block field(s) ${fmtFields}. Block content must be defined as an array of blocks`,\n        HELP_IDS.STANDALONE_BLOCK_TYPE,\n      ),\n    )\n  }\n\n  return problems\n}\n\nexport function validatePreview(preview: PreviewConfig) {\n  if (!isPlainObject(preview)) {\n    return [error(`The \"preview\" property must be an object, instead saw \"${typeof preview}\"`)]\n  }\n\n  if (typeof preview.prepare !== 'undefined' && typeof preview.prepare !== 'function') {\n    return [\n      error(\n        `The \"preview.prepare\" property must be a function, instead saw \"${typeof preview.prepare}\"`,\n      ),\n    ]\n  }\n\n  if (!preview.select) {\n    return []\n  }\n\n  if (!isPlainObject(preview.select)) {\n    return [\n      error(\n        `The \"preview.select\" property must be an object, instead saw \"${typeof preview.prepare}\"`,\n      ),\n    ]\n  }\n\n  return Object.keys(preview.select).reduce((errs: any, key) => {\n    return typeof preview.select![key] === 'string'\n      ? errs\n      : errs.concat(\n          error(\n            `The key \"${key}\" of \"preview.select\" must be a string, instead saw \"${typeof preview\n              .select![key]}\"`,\n          ),\n        )\n  }, [])\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  let problems = validateFields(typeDef.fields)\n\n  let preview = typeDef.preview\n  if (preview) {\n    const previewErrors = validatePreview(typeDef.preview)\n    problems = problems.concat(previewErrors)\n    preview = previewErrors.some((err: any) => err.severity === 'error') ? {} : preview\n  }\n\n  if (\n    typeDef.type !== 'document' &&\n    typeDef.type !== 'object' &&\n    typeof typeDef.initialValue !== 'undefined'\n  ) {\n    problems.push(\n      error(`The \"initialValue\" property is currently only supported for document & object types.`),\n    )\n  }\n\n  return {\n    ...typeDef,\n    preview,\n    fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map((field: any, index: any) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {isPlainObject} from 'lodash'\n\nimport {error} from '../createValidationResult'\nimport object from './object'\n\nexport default (typeDefinition: any, visitorContext: any) => {\n  const typeDef = object(typeDefinition, visitorContext)\n  const {initialValue, initialValues} = typeDef\n\n  const hasInitialValue = typeof initialValue !== 'undefined'\n  if (hasInitialValue && !isPlainObject(initialValue) && typeof initialValue !== 'function') {\n    typeDef._problems.push(\n      error(`The \"initialValue\" property must be either a plain object or a function`),\n    )\n  }\n\n  if (typeof initialValues !== 'undefined') {\n    typeDef._problems.push(error(`Found property \"initialValues\" - did you mean \"initialValue\"?`))\n  }\n\n  return typeDef\n}\n","import {error, HELP_IDS} from '../createValidationResult'\nimport {validateField, validateFields} from './object'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n  const fields = typeDef.fields\n\n  if (fields) {\n    problems.push(...validateFields(fields, {allowEmpty: true}))\n  }\n\n  const invalidFieldNames = Array.isArray(fields)\n    ? fields?.filter((field) => field.name === 'asset')\n    : []\n\n  if (\n    typeDef.options &&\n    typeof typeDef.options.metadata !== 'undefined' &&\n    !Array.isArray(typeDef.options.metadata)\n  ) {\n    problems.push(\n      error(\n        `Invalid type for file \\`metadata\\` field - must be an array of strings`,\n        HELP_IDS.ASSET_METADATA_FIELD_INVALID,\n      ),\n    )\n  } else if (invalidFieldNames.length > 0) {\n    problems.push(error('The name `asset` is not a valid field name for type `file`.'))\n  }\n\n  return {\n    ...typeDef,\n    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {flatten, isPlainObject} from 'lodash'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error, HELP_IDS} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction normalizeToProp(typeDef: any) {\n  if (Array.isArray(typeDef.to)) {\n    return typeDef.to\n  }\n  return typeDef.to ? [typeDef.to] : typeDef.to\n}\n\nexport function isValidResourceType(resourceType: string): string | true {\n  if (!resourceType) {\n    return 'The resource type must be a non-empty string'\n  }\n  if (resourceType != 'media-library' && resourceType != 'dataset') {\n    return 'The resource type must be either \"media-library\" or \"dataset\"'\n  }\n  return true\n}\n\nexport function isValidResourceId(resourceType: string, resourceId: string): string | true {\n  if (!resourceId) {\n    return 'The resource ID must be a non-empty string'\n  }\n  if (resourceType === 'dataset') {\n    const parts = resourceId.split('.')\n    if (parts.length !== 2) {\n      return 'The resource ID for a dataset reference must be on the form \"<projectId>.<datasetName>\"'\n    }\n    return true\n  }\n  if (resourceType === 'media-library') {\n    return true\n  }\n  return `Cannot validate resource ID for resource type: ${resourceType}`\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to)\n  const normalizedTo = normalizeToProp(typeDef)\n\n  const problems = flatten([\n    isValidTo\n      ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n          ),\n        )\n      : error(\n          'The global document reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n          HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n        ),\n  ])\n\n  if (isValidTo && normalizedTo.length === 0) {\n    problems.push(\n      error(\n        'The global document reference type should define at least one referenced type. Please check the \"to\" property.',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  normalizedTo.forEach((crossDatasetTypeDef: any, index: any) => {\n    if (!crossDatasetTypeDef.type) {\n      problems.push(\n        error(\n          `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,\n          HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n        ),\n      )\n    }\n\n    if (!isPlainObject(crossDatasetTypeDef.preview)) {\n      problems.push(\n        error(\n          `Missing required preview config for the referenced type \"${\n            crossDatasetTypeDef.type || '<unknown type>'\n          }\"`,\n          HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n        ),\n      )\n    }\n  })\n\n  if (typeof typeDef.resourceType === 'string') {\n    const validation = isValidResourceType(typeDef.resourceType)\n    if (validation !== true) {\n      problems.push(error(validation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID))\n    }\n  } else {\n    problems.push(\n      error(\n        'A global document reference must specify a `resourceType`',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  if (typeof typeDef.resourceId === 'string') {\n    const datasetValidation = isValidResourceId(typeDef.resourceType, typeDef.resourceId)\n    if (datasetValidation !== true) {\n      problems.push(error(datasetValidation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID))\n    }\n  } else {\n    problems.push(\n      error(\n        'A global document reference must specify a `resourceId`',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  if (typeDef.studioUrl && typeof typeDef.studioUrl !== 'function') {\n    problems.push(\n      error(\n        'The \"studioUrl\" property on a global document reference must be a function taking \"{id, type}\" as argument and returning a studio url.',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  problems.push(...getOptionErrors(typeDef))\n\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n\nfunction getOptionErrors(typeDef: any): SchemaValidationResult[] {\n  const {options} = typeDef\n  const problems = [] as SchemaValidationResult[]\n\n  problems.push(\n    ...['filter', 'filterParams']\n      .filter((key) => key in typeDef)\n      .map((key) =>\n        error(\n          `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n          HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION,\n        ),\n      ),\n  )\n\n  if (!options) {\n    return problems\n  }\n\n  if (!isPlainObject(options)) {\n    return problems.concat(\n      error(\n        'The reference type expects `options` to be an object',\n        HELP_IDS.REFERENCE_INVALID_OPTIONS,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {\n    return problems.concat(\n      error(\n        '`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.',\n        HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {\n    return problems\n  }\n\n  if (typeof options.filter !== 'string') {\n    return problems.concat(\n      error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`),\n    )\n  }\n\n  if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {\n    return problems.concat(error(`If set, \\`filterParams\\` must be an object.`))\n  }\n\n  if (options.filterParams) {\n    return problems.concat(\n      Object.keys(options.filterParams)\n        .filter((key) => key.startsWith('__') || key.startsWith('$'))\n        .map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`)),\n    )\n  }\n\n  return problems\n}\n","import {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateField, validateFields} from './object'\n\nconst autoMeta = ['dimensions', 'hasAlpha', 'isOpaque']\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n  const fields = typeDef.fields\n\n  if (fields) {\n    problems.push(...validateFields(fields, {allowEmpty: true}))\n  }\n\n  let options = typeDef.options\n  const metadata = options?.metadata\n  const superfluousMeta = Array.isArray(metadata)\n    ? metadata.filter((meta) => autoMeta.includes(meta))\n    : []\n\n  const invalidFieldNames = ['asset', 'hotspot', 'crop']\n\n  const fieldsWithInvalidName = Array.isArray(fields)\n    ? fields?.filter((field) => invalidFieldNames.includes(field.name))\n    : []\n\n  if (typeof metadata !== 'undefined' && !Array.isArray(metadata)) {\n    problems.push(\n      error(\n        `Invalid type for image \\`metadata\\` field - must be an array of strings`,\n        HELP_IDS.ASSET_METADATA_FIELD_INVALID,\n      ),\n    )\n  } else if (superfluousMeta.length > 0) {\n    problems.push(\n      warning(\n        `Image \\`metadata\\` field contains superfluous properties (they are always included): ${superfluousMeta.join(\n          ', ',\n        )}`,\n      ),\n    )\n    options = {...options, metadata: metadata!.filter((meta) => !autoMeta.includes(meta))}\n  } else if (fieldsWithInvalidName.length > 0) {\n    problems.push(\n      error(\n        `The names \\`${invalidFieldNames.join(\n          '`, `',\n        )}\\` are invalid field names for type \\`image\\`.`,\n      ),\n    )\n  }\n\n  return {\n    ...typeDef,\n    options,\n    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {flatten, isPlainObject} from 'lodash'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error, HELP_IDS} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction normalizeToProp(typeDef: any) {\n  if (Array.isArray(typeDef.to)) {\n    return typeDef.to\n  }\n  return typeDef.to ? [typeDef.to] : typeDef.to\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to)\n  const normalizedTo = normalizeToProp(typeDef)\n\n  const problems = flatten([\n    isValidTo\n      ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.REFERENCE_TO_INVALID,\n          ),\n        )\n      : error(\n          'The reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n          HELP_IDS.REFERENCE_TO_INVALID,\n        ),\n  ])\n\n  if (isValidTo && normalizedTo.length === 0) {\n    problems.push(\n      error(\n        'The reference type should define at least one accepted type. Please check the \"to\" property.',\n        HELP_IDS.REFERENCE_TO_INVALID,\n      ),\n    )\n  }\n\n  problems.push(...getOptionErrors(typeDef))\n\n  return {\n    ...typeDef,\n    to: (isValidTo ? normalizedTo : []).map(visitorContext.visit),\n    _problems: problems,\n  }\n}\n\nfunction getOptionErrors(typeDef: any): SchemaValidationResult[] {\n  const {options} = typeDef\n  const problems = [] as SchemaValidationResult[]\n\n  problems.push(\n    ...['filter', 'filterParams']\n      .filter((key) => key in typeDef)\n      .map((key) =>\n        error(\n          `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n          HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION,\n        ),\n      ),\n  )\n\n  if (!options) {\n    return problems\n  }\n\n  if (!isPlainObject(options)) {\n    return problems.concat(\n      error(\n        'The reference type expects `options` to be an object',\n        HELP_IDS.REFERENCE_INVALID_OPTIONS,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {\n    return problems.concat(\n      error(\n        '`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.',\n        HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {\n    return problems\n  }\n\n  if (typeof options.filter !== 'string') {\n    return problems.concat(\n      error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`),\n    )\n  }\n\n  if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {\n    return problems.concat(error(`If set, \\`filterParams\\` must be an object.`))\n  }\n\n  if (options.filterParams) {\n    return problems.concat(\n      Object.keys(options.filterParams)\n        .filter((key) => key.startsWith('__') || key.startsWith('$'))\n        .map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`)),\n    )\n  }\n\n  return problems\n}\n","import {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateComponent} from '../utils/validateComponent'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const hasName = Boolean(typeDef.name)\n  if (!hasName && Object.keys(typeDef).length === 1) {\n    // Short-circuit on obviously invalid types (only key is _problems)\n    return {\n      ...typeDef,\n      _problems: [\n        error(\n          'Invalid/undefined type declaration, check declaration or the import/export of the schema type.',\n          HELP_IDS.TYPE_INVALID,\n        ),\n      ],\n    }\n  }\n\n  const problems = []\n  if (looksLikeEsmModule(typeDef)) {\n    problems.push(\n      error(\n        'Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property',\n        HELP_IDS.TYPE_IS_ESM_MODULE,\n      ),\n    )\n  } else if (!hasName) {\n    problems.push(error('Missing type name', HELP_IDS.TYPE_MISSING_NAME))\n  } else if (visitorContext.isReserved(typeDef.name)) {\n    problems.push(\n      error(\n        `Invalid type name: \"${typeDef.name}\" is a reserved name.`,\n        HELP_IDS.TYPE_NAME_RESERVED,\n      ),\n    )\n  }\n\n  if (visitorContext.isDuplicate(typeDef.name)) {\n    problems.push(\n      error(\n        `Invalid type name: A type with name \"${typeDef.name}\" is already defined in the schema.`,\n      ),\n    )\n  }\n\n  problems.push(...validateComponent(typeDef))\n\n  if ('title' in typeDef && typeof typeDef.title !== 'string') {\n    problems.push(warning('Type title is not a string.', HELP_IDS.TYPE_TITLE_INVALID))\n  }\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n\nfunction looksLikeEsmModule(typeDef: any) {\n  return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title)\n}\n","import {HELP_IDS, warning} from '../createValidationResult'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n\n  if (typeDef.options && typeDef.options.slugifyFn) {\n    problems.push(\n      warning(\n        'Heads up! The \"slugifyFn\" option has been renamed to \"slugify\".',\n        HELP_IDS.SLUG_SLUGIFY_FN_RENAMED,\n      ),\n    )\n\n    typeDef.options.slugify = typeDef.options.slugifyFn\n  }\n\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n","import {traverseSanitySchema} from './traverseSchema'\nimport {type _FIXME_} from './typedefs'\nimport array from './validation/types/array'\nimport block from './validation/types/block'\nimport common from './validation/types/common'\nimport crossDatasetReference from './validation/types/crossDatasetReference'\nimport documentVisitor from './validation/types/document'\nimport file from './validation/types/file'\nimport globalDocumentReference from './validation/types/globalDocumentReference'\nimport image from './validation/types/image'\nimport object from './validation/types/object'\nimport reference from './validation/types/reference'\nimport rootType from './validation/types/rootType'\nimport slug from './validation/types/slug'\n\nconst typeVisitors = {\n  array,\n  object,\n  slug,\n  file,\n  image,\n  block,\n  document: documentVisitor,\n  reference: reference,\n  crossDatasetReference: crossDatasetReference,\n  globalDocumentReference,\n}\n\nconst getNoopVisitor = (visitorContext: any) => (schemaDef: any) => ({\n  name: `<unnamed_type_@_index_${visitorContext.index}>`,\n  ...schemaDef,\n  _problems: [],\n})\n\nfunction combine(...visitors: any) {\n  return (schemaType: any, visitorContext: any) => {\n    return visitors.reduce(\n      (result: any, visitor: any) => {\n        const res = visitor(result, visitorContext)\n        return {\n          ...res,\n          _problems: result._problems.concat(res._problems),\n        }\n      },\n      {_problems: [], ...schemaType},\n    )\n  }\n}\n\n/**\n * @internal\n */\nexport function validateSchema(schemaTypes: _FIXME_) {\n  return traverseSanitySchema(schemaTypes, (schemaDef, visitorContext) => {\n    const typeVisitor =\n      (schemaDef && schemaDef.type && (typeVisitors as any)[schemaDef.type]) ||\n      getNoopVisitor(visitorContext)\n\n    if (visitorContext.isRoot) {\n      return combine(rootType, common, typeVisitor)(schemaDef, visitorContext)\n    }\n\n    return combine(common, typeVisitor)(schemaDef, visitorContext)\n  })\n}\n"],"names":["object","reference","array","coreTypes","coreTypeNames","quote","humanize","normalizeToProp","getOptionErrors","block"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIM,MAAA,eAAe,0BAEf,kBAAkB;IAAC;IAAU;IAAU;IAAU,SAAS;CAAA,EAC1D,gBAAgB,iBAMhB,cAAc,CAAC,aASZ,gBAAgB,aAAc,UAAA,CAAW,YAAY,CAAA,GAAiB,iBAGzE,kBAAkB,CAAC,UAAkB,YAAsB;IAC3D,IAAA,CAAC,MAAM,OAAA,CAAQ,OAAO,GACxB,MAAM,IAAI,MACR,CAAA,oBAAA,EAAuB,YAAY,CAAA,4CAAA,EAA+C,cAAc,IAAA,CAC9F,OACD;IAIC,MAAA,WAAU,kJAAA,EAAW,SAAS,aAAa;IAEjD,IAAI,QAAQ,MAAA,GAAS,GACnB,MAAM,IAAI,MACR,CAAA,cAAA,EACE,QAAQ,MAAA,GAAS,IAAI,MAAM,EAC7B,CAAA,6BAAA,EAAgC,QAAQ,CAAA,GAAA,EAAM,QAAQ,IAAA,CACpD,MACD,qBAAA,EAAwB,cAAc,IAAA,CAAK,IAAI,CAAC,EAAA;IAI9C,OAAA;AACT,GAEa,wBAAwB,CAAC,aACpC,gBAAgB,WAAW,IAAA,EAAM,YAAY,UAAU,CAAC,GAE7C,kBAAkB,CAAC,YAAwB,SACtD,sBAAsB,UAAU,EAAE,QAAA,CAAS,MAAM,GCxB7C,wBAAwB,CAAC,WAAA,CAAuD;QACpF,KAAK;YACH,MAAM;YACN,OAAO;gBAAC,MAAM;YAAQ;QACxB;QACA,OAAO;YACL,MAAM;YACN,OAAO;gBAAC,MAAM;gBAAU,OAAO;YAAQ;QACzC;QACA,YAAY;YACV,MAAM;YACN,OAAO;gBAAC,MAAM;YAAQ;QACxB;QACA,YAAY;YACV,MAAM;YACN,OAAO;gBAAC,MAAM;YAAQ;QACxB;QACA,MAAM;YACJ,MAAM;YACN,OAAO;gBAAC,MAAM;YAAQ;QAAA;IAE1B,CAAA,GACM,WAAA,aAAA,GAAA,IAAe,IAAsB;IACzC;QAAC;QAAQ;YAAC,MAAM;QAAA,CAAS;KAAA;IACzB;QAAC;QAAO;YAAC,MAAM;QAAA,CAAS;KAAA;IACxB;QAAC;QAAY;YAAC,MAAM;QAAA,CAAS;KAAA;IAC7B;QAAC;QAAQ;YAAC,MAAM;QAAA,CAAS;KAAA;IACzB;QAAC;QAAW;YAAC,MAAM;QAAA,CAAU;KAAA;IAC7B;QAAC;QAAS;YAAC,MAAM;QAAS,CAAA;KAAA;CAC3B;AAMM,SAAS,cACd,SAAA,EACA,iBAAuC,CAAA,CAAA,EAC3B;IACN,MAAA,eAAA,aAAA,GAAA,IAAmB,IAAsB,GACzC,gBAAoB,aAAA,GAAA,IAAA,IAAA,GACpB,SAAqB,CAAC,CAAA;IAGE,mBAAmB,SAAS,EACpC,OAAA,CAAQ,CAAC,aAAa;QACpC,MAAA,aAAa,UAAU,GAAA,CAAI,QAAQ;QACzC,IAAI,eAAe,KAAA,GACjB;QAEI,MAAA,OAAO,gBAAgB,UAAU;QACnC,SAAS,QAAA,CAGT,KAAK,IAAA,KAAS,UAChB,aAAa,GAAA,CAAI,UAAU,GAEzB,KAAK,IAAA,KAAS,cAChB,cAAc,GAAA,CAAI,UAAU,IAAI,GAGlC,OAAO,IAAA,CAAK,IAAI,CAAA;IAAA,CACjB;IAED,SAAS,gBACP,UAAA,EACuD;QACnD,IAAA;QAOJ,IANI,WAAW,IAAA,GACb,WAAW,WAAW,IAAA,CAAK,IAAA,GAClB,cAAc,cAAA,CACvB,WAAW,WAAW,QAAA,GAGpB,aAAa,cAAc,aAAa,UAAU,GAAG;YACvD,MAAM,oBAAoB,sBAAsB,WAAW,IAAI,GAEzDA,UAAS,aAAa,UAAU;YAClC,OAAAA,QAAO,IAAA,KAAS,YACX,OAGF;gBACL,MAAM,WAAW,IAAA;gBACjB,MAAM;gBACN,YAAY;oBACV,GAAG,iBAAA;oBACH,GAAGA,QAAO,UAAA;gBAAA;YAEd;QAAA;QAGI,MAAA,QAAQ,kBAAkB,UAAU;QAC1C,OAAI,MAAM,IAAA,KAAS,YACV,OAEL,MAAM,IAAA,KAAS,WACV;YACL,MAAM,WAAW,IAAA;YACjB,MAAM;YACN,OAAO;gBACL,MAAM;gBACN,YAAY;oBACV,OAAO;wBACL,MAAM;wBACN,OAAO;4BACL,MAAM;4BACN,OAAO,WAAW,IAAA;wBAAA;oBAEtB;oBACA,GAAG,MAAM,UAAA;gBAAA;YACX;QACF,IAIG;YACL,MAAM,WAAW,IAAA;YACjB,MAAM;YACN;QACF;IAAA;IAGF,SAAS,kBAAkB,UAAA,EAAwC;QAE7D,IAAA,aAAa,GAAA,CAAI,WAAW,IAAK,GACnC,OAAO;YAAC,MAAM;YAAU,MAAM,WAAW,IAAA,CAAM,IAAA;QAAI;QAKjD,IAAA,WAAW,IAAA,EAAM,MAAM,SAAS,UAClC,OAAO;YAAC,MAAM;YAAU,MAAM,WAAW,IAAA,CAAK,IAAA;QAAI;QAGpD,IAAI,aAAa,UAAU,GACzB,OAAO,8BAA8B,UAAU;QAGjD,IAAI,aAAa,UAAU,GACzB,OAAO,8BAA8B,UAAU;QAIjD,IAAI,WAAW,IAAA,IAAQ,SAAS,GAAA,CAAI,WAAW,IAAA,CAAK,IAAI,GACtD,OAAO,SAAS,GAAA,CAAI,WAAW,IAAA,CAAK,IAAI;QAI1C,IAAI,4BAA4B,UAAU,GACjC,OAAA;YAAC,MAAM;QAAS;QAIzB,IAAI,8BAA8B,UAAU,GACnC,OAAA;YAAC,MAAM;QAAS;QAGzB,IAAI,gBAAgB,UAAU,GAC5B,OAAO,iCAAiC,UAAU;QAGpD,IAAI,YAAY,UAAU,GACxB,OAAO,YAAY,UAAU;QAG/B,IAAI,aAAa,UAAU,GACzB,OAAO,aAAa,UAAU;QAGhC,IAAI,SAAS,UAAU,GAAG,SAAS,YAAY;YAC7C,MAAM,MAAM,cAAc,GAAA,CAAI,WAAW,IAAI;YACzC,OAAA,QAAQ,KAAA,IACH;gBAAC,MAAM;YAAA,IAET;gBAAC,MAAM;gBAAU,YAAY,KAAK;YAAU;QAAA;QAGrD,MAAM,IAAI,MAAM,CAAA,MAAA,EAAS,WAAW,IAAI,CAAA,WAAA,CAAa;IAAA;IAGvD,SAAS,aACP,UAAA,EACkC;QAClC,MAAM,aAA8C,CAE9C,GAAA,SAAS,aAAa,UAAU;QACtC,KAAA,MAAW,SAAS,OAAQ;YAC1B,MAAM,kBAAkB,gBAAgB,KAAK,GACvC,QAAQ,kBAAkB,MAAM,IAAI;YAC1C,IAAI,UAAU,MACZ;YAKE,iBAAiB,KAAK,KAAK,MAAM,IAAA,KAAS,YAAA,CAC5C,MAAM,UAAA,CAAW,KAAA,CAAM,QAAA,GAAW,CAAA,CAAA;YAKpC,MAAM,WAAW,eAAe,qBAAA,GAAwB,oBAAoB,CAAA,IAAQ,CAAA;YAEzE,UAAA,CAAA,MAAM,IAAI,CAAA,GAAI;gBACvB,MAAM;gBACN;gBACA;YACF;QAAA;QAIF,OAAI,OAAO,IAAA,CAAK,UAAU,EAAE,MAAA,KAAW,IAC9B;YAAC,MAAM;QAAA,IAAA,CAGZ,WAAW,IAAA,EAAM,SAAS,cAAc,WAAW,IAAA,KAAS,YAAA,CAC9D,WAAW,KAAA,GAAQ;YACjB,MAAM;YACN,OAAO;gBACL,MAAM;gBACN,OAAO,WAAW,IAAA;YAAA;QACpB,CAAA,GAIG;YACL,MAAM;YACN;QAAA,CAAA;IACF;IAGF,SAAS,YAAY,eAAA,EAAgE;QACnF,MAAM,KAAiB,CAAC,CAAA;QACb,KAAA,MAAA,QAAQ,gBAAgB,EAAA,CAAI;YAC/B,MAAA,QAAQ,kBAAkB,IAAI;YAChC,MAAM,IAAA,KAAS,WACjB,GAAG,IAAA,CAAK;gBACN,MAAM;gBACN,YAAY;oBACV,MAAM,eAAe;gBACvB;gBACA,MAAM;YACkB,CAAA,IAAA,CACjB,MAAM,IAAA,KAAS,YAAA,CACxB,MAAM,IAAA,GAAO;gBACX,MAAM;gBACN,YAAY;oBACV,MAAM,eAAe;gBAAA;YAEzB,CAAA,GACA,GAAG,IAAA,CAAK,KAAK,CAAA;QAAA;QAMjB,OAAI,GAAG,MAAA,KAAW,IACT;YAAC,MAAM;QAAA,IAGT;YACL,MAAM;YACN,IACE,GAAG,MAAA,GAAS,IACR;gBACE,MAAM;gBACN;YACF,IACA,EAAA,CAAG,CAAC,CAAA;QACZ;IAAA;IAGK,OAAA;AACT;AAEA,SAAS,iBAAkD;IAClD,OAAA;QACL,MAAM;QACN,OAAO;YACL,MAAM;QAAA;IAEV;AACF;AAEA,SAAS,gBAAgB,KAAA,EAA6B;IAC9C,MAAA,EAAC,UAAA,EAAA,GAAc,MAAM,IAAA;IAC3B,IAAI,CAAC,YACI,OAAA,CAAA;IAET,MAAM,QAAQ,MAAM,OAAA,CAAQ,UAAU,IAAI,aAAa;QAAC,UAAU;KAAA;IAClE,KAAA,MAAW,QAAQ,MAAO;QACxB,IAAI,WAAW,CAAA;QAIf,MAAM,QAAQ,IAAI,MAChB,CAAC,GACD;YACE,KAAK,CAAC,QAAQ,aAAe,IAAA,CACvB,eAAe,cAAA,CACjB,WAAW,CAAA,CAAA,GAEN,KAAA;QAAA;QAYb,IAPI,OAAO,QAAS,cAAA,CAClB,KAAK,KAAK,GACN,QAAA,KAKF,OAAO,QAAS,YAAY,SAAS,QAAQ,eAAe,QAC1D,KAAK,SAAA,KAAc,YACd,OAAA,CAAA;IAAA;IAKN,OAAA,CAAA;AACT;AAEA,SAAS,iBAAiB,KAAA,EAA6B;IAC/C,MAAA,EAAC,UAAA,EAAA,GAAc,MAAM,IAAA;IAC3B,IAAI,CAAC,YACI,OAAA,CAAA;IAET,MAAM,QAAQ,MAAM,OAAA,CAAQ,UAAU,IAAI,aAAa;QAAC,UAAU;KAAA;IAClE,KAAA,MAAW,QAAQ,MAAO;QACxB,IAAI,gBAAgB,CAAA;QAIpB,MAAM,QAAQ,IAAI,MAChB,CAAC,GACD;YACE,KAAK,CAAC,QAAQ,aAAe,IAAA,CACvB,eAAe,mBAAA,CACjB,gBAAgB,CAAA,CAAA,GAEX,KAAA;QAAA;QAKT,IAAA,OAAO,QAAS,cAAA,CAClB,KAAK,KAAK,GACN,aAAA,KAMJ,OAAO,QAAS,YAChB,SAAS,QACT,YAAY,QACZ,MAAM,OAAA,CAAQ,KAAK,MAAM,KAErB,KAAK,MAAA,CAAO,IAAA,CAAK,CAAC,IAAM,EAAE,IAAA,KAAS,eAAe,GAC7C,OAAA,CAAA;IAAA;IAKN,OAAA,CAAA;AACT;AAEA,SAAS,aAAa,OAAA,EAAwD;IAC5E,OAAO,OAAO,SAAS,QAAQ,KAAK,QAAQ,QAAA,KAAa,YAAY,YAAY;AACnF;AACA,SAAS,YAAY,OAAA,EAAuD;IACnE,OAAA,OAAO,SAAS,OAAO;AAChC;AACA,SAAS,gBAAgB,OAAA,EAA2D;IAC3E,OAAA,OAAO,SAAS,WAAW;AACpC;AACA,SAAS,4BAA4B,OAAA,EAA2B;IACvD,OAAA,OAAO,SAAS,uBAAuB;AAChD;AACA,SAAS,8BAA8B,OAAA,EAA2B;IACzD,OAAA,OAAO,SAAS,yBAAyB;AAClD;AACA,SAAS,aAAa,OAAA,EAAwD;IACrE,OAAA,OAAO,SAAS,QAAQ;AACjC;AACA,SAAS,aAAa,OAAA,EAAwD;IACrE,OAAA,OAAO,SAAS,QAAQ;AACjC;AACA,SAAS,8BACP,gBAAA,EACgD;IAC1C,MAAA,cAAc,iBAAiB,OAAA,EAAS;IAC9C,OAAI,eAAe,MAAM,OAAA,CAAQ,WAAW,IACnC;QACL,MAAM;QACN,IAAI,YAAY,GAAA,CAAI,CAAC,IAAA,CAAO;gBAC1B,MAAM;gBACN,OAAO,OAAO,KAAM,WAAW,IAAI,EAAE,KAAA;YAAA,CAAA,CACrC;IAAA,IAGC;QACL,MAAM;IACR;AACF;AAEA,SAAS,8BACP,gBAAA,EACgD;IAC1C,MAAA,cAAc,iBAAiB,OAAA,EAAS;IAC9C,OAAI,eAAe,MAAM,OAAA,CAAQ,WAAW,IACnC;QACL,MAAM;QACN,IAAI,YAAY,GAAA,CAAI,CAAC,IAAA,CAAO;gBAC1B,MAAM;gBACN,OAAO,OAAO,KAAM,WAAW,IAAI,EAAE,KAAA;YAAA,CAAA,CACrC;IAAA,IAGC;QACL,MAAM;IACR;AACF;AAEA,SAAS,iCACPC,UAAAA,EACgD;IAC1C,MAAA,aAAa,qBAAqBA,UAAS;IACjD,OAAI,WAAW,MAAA,KAAW,iJACjB,0BAAA,EAAwB,UAAA,CAAW,CAAC,CAAC,IAGvC;QACL,MAAM;QACN,IAAI,WAAW,GAAA,CAAI,CAAC,WAAS,mKAAA,EAAwB,IAAI,CAAC;IAC5D;AACF;AAGA,SAAS,qBAAqB,IAAA,EAAqC;IAC3D,MAAA,gBAAgB,qBAAqB,IAAI;IAE/C,OAAO,CAAC;WAAO,aAAA,GAAA,IAAA,IAAI,CAAC;eAAG,cAAc,GAAA,CAAI,CAAC,MAAQ,IAAI,IAAI,CAAC;SAAC,CAAC;KAAA;AAC/D;AAEA,SAAS,qBAAqB,IAAA,EAA+C;IAC3E,MAAM,QAAQ,QAAQ,OAAO,KAAK,EAAA,GAAK,CAAC,CAAA;IACxC,OAAI,UAAU,QAAQ,gBAAgB,KAAK,IAAK,IACvC,CAAC;WAAG,qBAAqB,KAAK,IAAI,GAAG;WAAG,KAAK;KAAA,GAG/C;AACT;AAGA,SAAS,aAAa,IAAA,EAA0D;IAC9E,OAAI,YAAY,OACP,KAAK,IAAA,GAAO,aAAa,KAAK,IAAI,EAAE,MAAA,CAAO,KAAK,MAAM,IAAI,KAAK,MAAA,GAGjE,CAAC,CAAA;AACV;AAGA,SAAS,OACP,OAAA,EACA,QAAA,EACS;IACT,IAAI,OAA+D;IACnE,MAAO,MAAM;QACX,IAAI,KAAK,IAAA,KAAS,YAAa,KAAK,IAAA,IAAQ,KAAK,IAAA,CAAK,IAAA,KAAS,UACtD,OAAA,CAAA;QAGT,OAAO,KAAK,IAAA;IAAA;IAEP,OAAA,CAAA;AACT;AAGA,SAAS,SAAS,OAAA,EAAyD;IACzE,IAAI,OAA+D;IACnE,MAAO,MAAM;QACX,IAAI,CAAC,KAAK,IAAA,EACD,OAAA;QAET,OAAO,KAAK,IAAA;IAAA;AAIhB;AAGA,SAAS,mBAAmB,cAAA,EAAqC;IACzD,MAAA,OAAA,aAAA,GAAA,IAAW,IAAsB;IAG9B,SAAA,iBACP,UAAA,EACA,YAAA,EACM;QACF,IAAA,CAAA,KAAK,GAAA,CAAI,UAAU,GAAA;YAKvB,IAFA,KAAK,GAAA,CAAI,UAAU,GAEf,YAAY,YACH,KAAA,MAAA,SAAS,aAAa,UAAU,EAAG;gBACtC,MAAA,OAAO,SAAS,MAAM,IAAI;gBAC5B,IAAA,KAAM,IAAA,KAAS,YAAY;oBAC7B,aAAa,GAAA,CAAI,IAAK;oBACtB;gBAAA;gBAGE,IAAA;gBACA,WAAW,IAAA,CAAM,IAAA,GACnB,iBAAiB,MAAM,IAAA,CAAK,IAAA,CAAM,IAAA,GACzB,cAAc,WAAW,IAAA,IAAA,CAClC,iBAAiB,MAAM,IAAA,CAAK,QAAA,GAAA,CAG1B,mBAAmB,YAAY,mBAAmB,OAAA,KAAA,CAChD,gBAAgB,MAAM,IAAI,IAC5B,MAAM,IAAA,CAAK,EAAA,CAAG,OAAA,CAAQ,CAAC,MAAQ,aAAa,GAAA,CAAI,IAAI,IAAK,CAAC,IAE1D,aAAa,GAAA,CAAI,MAAM,IAAI,CAAA,GAG/B,iBAAiB,MAAM,IAAA,EAAM,YAAY;YAAA;iBAAA,IAElC,QAAQ,YACjB,KAAA,MAAW,QAAQ,WAAW,EAAA,CAC5B,iBAAiB,MAAM,YAAY;QAAA;IAAA;IAInC,MAAA,gBAAA,aAAA,GAAA,IAAoB,IAA6C;IACvE,eAAe,YAAA,CAAa,EAAE,OAAA,CAAQ,CAAC,aAAa;QAC5C,MAAA,aAAa,eAAe,GAAA,CAAI,QAAQ;QAC1C,IAAA,eAAe,KAAA,KAAa,WAAW,IAAA,KAAS,MAClD;QAEI,MAAA,eAAA,aAAA,GAAA,IAAmB,IAAsB;QAE9B,iBAAA,YAAY,YAAY,GACzC,cAAc,GAAA,CAAI,YAAY,YAAY,GAC1C,KAAK,KAAA,CAAM;IAAA,CACZ;IAGK,MAAA,YAAsB,CAAA,CAAA,EAEtB,oBAAA,aAAA,GAAA,IAAwB,OAGxB,UAAU,aAAA,GAAA,IAAI,IAAsB;IAG1C,SAAS,MAAM,IAAA,EAAwB;QAKrC,IAJI,QAAQ,GAAA,CAAI,IAAI,KAIhB,kBAAkB,GAAA,CAAI,IAAI,GAC5B;QAGF,kBAAkB,GAAA,CAAI,IAAI;QACpB,MAAA,OAAO,cAAc,GAAA,CAAI,IAAI;QAC/B,SAAS,KAAA,KACX,KAAK,OAAA,CAAQ,CAAC,MAAQ,MAAM,GAAG,CAAC,GAElC,kBAAkB,MAAA,CAAO,IAAI,GAC7B,QAAQ,GAAA,CAAI,IAAI,GAEX,UAAU,QAAA,CAAS,KAAK,IAAI,KAC/B,UAAU,OAAA,CAAQ,KAAK,IAAI;IAAA;IAIpB,KAAA,MAAA,CAAC,IAAI,CAAA,IAAK,cACnB,MAAM,IAAI;IAGL,OAAA;AACT;ACtmBO,MAAM,WAAW;IACtB,cAAc;IACd,oBAAoB;IACpB,oBAAoB;IACpB,mBAAmB;IACnB,mBAAmB;IACnB,wBAAwB;IACxB,oBAAoB;IACpB,uBAAuB;IACvB,yBAAyB;IACzB,2BAA2B;IAC3B,sCAAsC;IACtC,kCAAkC;IAClC,gBAAgB;IAChB,kBAAkB;IAClB,qBAAqB;IACrB,oCAAoC;IACpC,qCAAqC;IACrC,sBAAsB;IACtB,yBAAyB;IACzB,2BAA2B;IAC3B,oCAAoC;IACpC,6CAA6C;IAC7C,yBAAyB;IACzB,8BAA8B;IAC9B,iCAAiC;IACjC,mCAAmC;IACnC,4BAA4B;IAC5B,uBAAuB;AACzB;AAEA,SAAS,uBACP,QAAA,EACA,OAAA,EACA,MAAA,EACwB;IACxB,IAAI,UAAU,CAAC,OAAO,IAAA,CAAK,QAAQ,EAAE,IAAA,CAAK,CAAC,KAAQ,QAAA,CAAiB,EAAE,CAAA,KAAM,MAAM,GAChF,MAAM,IAAI,MACR,CAAA,yBAAA,EAA4B,MAAM,CAAA,0DAAA,CAAA;IAG/B,OAAA;QACL;QACA;QACA;IACF;AACF;AAEO,MAAM,QAAQ,CAAC,SAAiB,SACrC,uBAAuB,SAAS,SAAS,MAAO,GAErC,UAAU,CAAC,SAAiB,SACvC,uBAAuB,WAAW,SAAS,MAAO;AC1C7C,SAAS,cAAc,KAAA,EAA+D;IACpF,6IAAA,UAAA,EAA0B,MAAM,GAAA,CAAI,CAAC,OAAS,gBAAgB,IAAI,CAAC,CAAC,EAAE,MAAA,CAC3E,CAAC,OAAS,KAAK,QAAA,CAAS,MAAA,GAAS;AAErC;AAEA,SAAS,sCACP,kBAAA,EACA,aAAa,CAAC,yIAAqB,UAAA,EAAI,MAAM,kBAAkB,CAAA,EAC/D;IACO,OAAA,SAAqB,IAAA,EAAW,UAAA,EAA6C;QAClF,MAAM,cAA2B;eAC5B;YACH;gBAAC,MAAM;gBAAQ,MAAM,KAAK,IAAA;gBAAM,MAAM,KAAK,IAAA;YAAI;SAG3C,EAAA,UAAU,WAAW,IAAI,KAAK,CAAC,CAAA,EAE/B,iBAAuC,MAAM,OAAA,CAAQ,OAAO,IAC9D,QAAQ,GAAA,CAAI,CAAC,eAAe;YAC1B,MAAM,kBAA8C;gBAClD,MAAM;gBACN,MAAM;YAEF,GAAA,aAA0B,CAAC;mBAAG;gBAAa,eAAe;aAAA;YACzD,OAAA,gBAAgB,YAAY,UAAiB;QAAA,CACrD,IACD;YACE;gBACE;oBACE,MAAM;oBACN,UAAU;wBAAC,MAAM,CAAA,oBAAA,EAAuB,kBAAkB,CAAA,iBAAA,CAAmB,CAAC;qBAAA;gBAAA;aAChF;SAEJ;QAEG,OAAA;YACL;gBACE,MAAM;gBACN,UAAU,KAAK,SAAA,IAAa,CAAA,CAAA;YAC9B;qJACG,UAAA,EAAQ,cAAc;SAC3B;IACF;AACF;AAEA,MAAM,SAAS,CAAC,MACd,MAAM,OAAA,CAAQ,GAAG,IAAI,MAAO,OAAO,MAAQ,OAAe,CAAC,CAAA,IAAM;QAAC,GAAG;KAAA,EAEjE,oBAAoB,sCAAsC,QAAQ,GAClE,mBAAmB,sCAAsC,QAAQ,GACjE,kBAAkB,sCAAsC,QAAQ,GAChE,mBAAmB,sCAAsC,IAAI,GAC7D,uBAAuB,sCAAsC,MAAM,CAAC,OACxE,QAAQ,OAAO,OAAO,KAAK,EAAE,IAAI,CAAA,CAAA,GAE7B,6BAA6B,sCAAsC,mBAAmB,GACtF,yBAAyB,sCAAsC,IAAI,GACnE,mBAAmB,CAAC,MAAW,WAAkB;WAClD,2BAA2B,MAAM,QAAQ;WACzC,uBAAuB,MAAM,QAAQ;KAC1C;AAEA,SAAS,mBAAmB,IAAA,EAAW,OAAO,EAAA,EAAwB;IAC7D,OAAA;QACL;YACE,MAAM,CAAC;mBAAG;gBAAM;oBAAC,MAAM;oBAAQ,MAAM,KAAK,IAAA;oBAAM,MAAM,KAAK,IAAA;gBAAA,CAAK;aAAA;YAChE,UAAU,KAAK,SAAA,IAAa,CAAA,CAAA;QAAC;KAEjC;AACF;AAEA,SAAS,gBAAgB,IAAA,EAA4B,OAAO,EAAA,EAAwB;IAClF,OAAQ,KAAK,IAAA,EAAM;QACjB,KAAK;YACI,OAAA,kBAAkB,MAAM,IAAI;QAErC,KAAK;YACI,OAAA,kBAAkB,MAAM,IAAI;QAErC,KAAK;YACI,OAAA,iBAAiB,MAAM,IAAI;QAEpC,KAAK;YACI,OAAA,qBAAqB,MAAM,IAAI;QAExC,KAAK;YACI,OAAA,iBAAiB,MAAM,IAAI;QAEpC,KAAK;YACI,OAAA,iBAAiB,MAAM,IAAI;QAEpC,KAAK;YACI,OAAA,gBAAgB,MAAM,IAAI;QAEnC;YACS,OAAA,mBAAmB,MAAM,IAAI;IAAA;AAG1C;AChHO,SAAS,SAASC,MAAAA,EAAY,WAAW,CAAC,IAAW,CAAA,EAAG;IAC7D,MAAM,QAAQA,OAAM,MAAA,CAAO,CAAC,KAAU,SAAc;QAC5C,MAAA,MAAM,SAAS,IAAI;QACzB,OAAK,GAAA,CAAI,GAAG,CAAA,IAAA,CACV,GAAA,CAAI,GAAG,CAAA,GAAI,CAAA,CAAA,GAEb,GAAA,CAAI,GAAG,CAAA,CAAE,IAAA,CAAK,IAAI,GACX;IACT,GAAG,CAAA,CAAE;IAEL,OAAO,OAAO,IAAA,CAAK,KAAK,EACrB,GAAA,CAAI,CAAC,MAAS,KAAA,CAAM,GAAG,CAAA,CAAE,MAAA,GAAS,IAAI,KAAA,CAAM,GAAG,CAAA,GAAI,IAAK,EACxD,MAAA,CAAO,OAAO;AACnB;ACMA,MAAM,eAAwB,CAAC,UAAY,SAUrC,YAAY;IAAC,MAAM;IAAQ,MAAM;AAAA,GAEjC,kBAAkB;IAAC;IAAO;IAAQ,MAAM;CAAA;AAE9B,SAAA,eACd,QAAyB,CAAC,CAAA,EAC1BC,aAA6B,CAAC,CAAA,EAC9B,UAAmB,YAAA,EACnB;IACA,MAAM,oBAAoB,aAAA,GAAA,OAAO,MAAA,CAAO,IAAI,GACtC,WAAW,aAAA,GAAA,OAAO,MAAA,CAAO,IAAI,GAE7BC,iBAAgBD,WAAU,GAAA,CAAI,CAAC,UAAY,QAAQ,IAAI,GAEvD,oBAAoB,gBAAgB,MAAA,CAAOC,cAAa,GAExD,YAAY,MAAM,GAAA,CAAI,CAAC,UAAY,WAAW,QAAQ,IAAI,EAAE,MAAA,CAAO,OAAO;IAEtED,WAAA,OAAA,CAAQ,CAAC,aAAa;QACZ,iBAAA,CAAA,SAAS,IAAI,CAAA,GAAI;IACpC,CAAA,GAED,MAAM,OAAA,CAAQ,CAAC,MAAM,MAAM;QAEzB,QAAA,CAAU,QAAQ,KAAK,IAAA,IAAS,CAAA,UAAA,EAAa,CAAC,EAAE,CAAA,GAAI,CAAC;IAAA,CACtD;IAED,SAAS,QAAQ,QAAA,EAAe;QACvB,OAAA,aAAa,SAChB,YACA,iBAAA,CAAkB,QAAQ,CAAA,IAAK,QAAA,CAAS,QAAQ,CAAA,IAAK;IAAA;IAG3D,MAAM,oJAAiB,UAAA,uIAAK,WAAA,EAAQ,SAAS,SAAS,CAAC,CAAC;IAExD,SAAS,YAAY,QAAA,EAAe;QAC3B,OAAA,eAAe,QAAA,CAAS,QAAQ;IAAA;IAEzC,SAAS,eAAe;QACf,OAAA,UAAU,MAAA,CAAOC,cAAa;IAAA;IAEvC,SAAS,WAAW,QAAA,EAAe;QACjC,OAAO,aAAa,UAAU,kBAAkB,QAAA,CAAS,QAAQ;IAAA;IAGnE,MAAM,YAAY,CAAC,SAAgB,CAAC,SAAc,QACzC,QAAQ,SAAS;gBACtB,OAAO,UAAU,CAAA,CAAK;gBACtB;gBACA;gBACA;gBACA;gBACA;gBACA;YAAA,CACD;IAGO,OAAAD,WAAA,OAAA,CAAQ,CAAC,gBAAgB;QACjC,OAAO,MAAA,CAAO,iBAAA,CAAkB,YAAY,IAAI,CAAA,EAAG,UAAU,WAAW,CAAC;IAC1E,CAAA,GAED,MAAM,OAAA,CAAQ,CAAC,SAAS,MAAM;QACrB,OAAA,MAAA,CACL,QAAA,CAAU,WAAW,QAAQ,IAAA,IAAS,CAAA,UAAA,EAAa,CAAC,EAAE,CAAA,EACtD,UAAU,CAAA,CAAI,EAAE,SAAS,CAAC;IAC5B,CACD,GAEM;QACL,KAAI,QAAA,EAAkB;YACpB,MAAM,MAAM,QAAA,CAAS,QAAQ,CAAA,IAAK,iBAAA,CAAkB,QAAQ,CAAA;YACxD,IAAA,KACK,OAAA;YAET,MAAM,IAAI,MAAM,CAAA,cAAA,EAAiB,QAAQ,EAAE;QAC7C;QACA,KAAI,QAAA,EAA2B;YACtB,OAAA,YAAY,YAAY,YAAY;QAC7C;QACA,eAAyB;YAChB,OAAA,OAAO,IAAA,CAAK,QAAQ;QAC7B;QACA,WAAW;YACT,OAAO,IAAA,CAAK,YAAA,CAAA,EAAe,GAAA,CAAI,IAAA,CAAK,GAAG;QACzC;QACA,SAAS;YACP,OAAO,IAAA,CAAK,QAAA,CAAS;QAAA;IAEzB;AACF;ACtHA,MAAM,YAAY;IAChB;QAAC,MAAM;QAAS,UAAU;QAAS,MAAM;IAAM;IAC/C;QAAC,MAAM;QAAS,UAAU;QAAU,MAAM;IAAM;IAChD;QAAC,MAAM;QAAW,UAAU;QAAW,MAAM;IAAM;IACnD;QAAC,MAAM;QAAY,UAAU;QAAU,MAAM;IAAM;IACnD;QAAC,MAAM;QAAQ,UAAU;QAAU,MAAM;IAAM;IAC/C;QAAC,MAAM;QAAY,UAAU;QAAU,MAAM;IAAM;IACnD;QAAC,MAAM;QAAS,UAAU;QAAU,MAAM;IAAM;IAChD;QAAC,MAAM;QAAQ,UAAU;QAAU,MAAM;IAAM;IAC/C;QAAC,MAAM;QAAY,UAAU;QAAU,MAAM;IAAM;IACnD;QAAC,MAAM;QAAS,UAAU;QAAU,MAAM;IAAM;IAChD;QAAC,MAAM;QAAU,UAAU;QAAU,MAAM;IAAM;IACjD;QAAC,MAAM;QAAU,UAAU;QAAU,MAAM;IAAM;IACjD;QAAC,MAAM;QAAa,UAAU;QAAU,MAAM;IAAM;IACpD;QAAC,MAAM;QAAyB,UAAU;QAAU,MAAM;IAAM;IAChE;QAAC,MAAM;QAA2B,UAAU;QAAU,MAAM;IAAM;IAClE;QAAC,MAAM;QAAQ,UAAU;QAAU,MAAM;IAAM;IAC/C;QAAC,MAAM;QAAQ,UAAU;QAAU,MAAM;IAAM;IAC/C;QAAC,MAAM;QAAU,UAAU;QAAU,MAAM;IAAM;IACjD;QAAC,MAAM;QAAa,UAAU;QAAU,MAAM;IAAM;IACpD;QAAC,MAAM;QAAQ,UAAU;QAAU,MAAM;IAAM;IAC/C;QAAC,MAAM;QAAO,UAAU;QAAU,MAAM;IAAM;CAChD,EAEa,gBAAgB,UAAU,GAAA,CAAI,CAAC,IAAM,EAAE,IAAI;ACpBxC,SAAA,qBAAqB,WAAA,EAAwB,OAAA,EAAkB;IACtE,OAAA,eAAe,aAAa,WAAsB,OAAO;AAClE;ACCA,SAAS,oBAAoB,QAAA,EAAe;IAC1C,OAAO,aAAa,YAAY,aAAa,YAAY,aAAa;AACxE;AAEA,SAAS,aAAa,QAAA,EAAe,IAAA,EAAW;IAC9C,OAAA,CAAQ,OAAO,KAAK,IAAA,IAAS,WAAW,KAAK,IAAA,GAAO,KAAK,IAAA,MAAU;AACrE;AAEA,SAASE,QAAM,CAAA,EAAQ;IACrB,OAAO,CAAA,CAAA,EAAI,CAAC,CAAA,CAAA,CAAA;AACd;AAEA,SAAS,UAAU,GAAA,EAAgB,MAAM,GAAA,EAAK;IACrC,OAAA,IAAI,MAAA,KAAW,IAAI,KAAK;AACjC;AAEA,SAAS,OAAO,KAAA,EAAgB;IAC1B,OAAA,MAAM,OAAA,CAAQ,KAAK,IACd,CAAA,WAAA,EAAc,MAAM,MAAM,CAAA,QAAA,CAAA,GAE/B,OAAO,SAAU,YAAY,UAAU,OAClC,CAAA,iBAAA,gJAAoB,UAAA,EAAa,OAAO,IAAA,CAAK,KAAK,EAAE,GAAA,CAAIA,OAAK,CAAC,CAAC,EAAA,GAEjEA,QAAM,KAAK;AACpB;AAEA,IAAA,QAAe,CAAC,SAAc,mBAAwB;IAEpD,MAAM,YAAY,MAAM,OAAA,CAAQ,QAAQ,EAAE;IAE1C,IAAI,WAAW;QACb,MAAM,UAAU,QAAQ,EAAA,CAAG,MAAA,CAAO,CAAC,MAAW,KAAU,QAAa;YAC/D,IAAA,OAAO,IAAI,IAAA,IAAS,YAAA,kGAAA;YAAA,4EAAA;YAiBpB,IAAI,IAAA,KAAS,IAAI,IAAA,IACjB,cAAc,QAAA,CAAS,IAAI,IAAI,GAE/B,OAAO,KAAK,MAAA,CACV,MACE,CAAA,4EAAA,EAA+E,IAAI,IAAI,CAAA,oEAAA,CAAA,EACvF,SAAS,mCAAA;YAMb,IAAA,IAAI,IAAA,KAAS,YAAY,IAAI,IAAA,IAAQ,eAAe,OAAA,CAAQ,IAAI,IAAI,GACtE,OAAO,KAAK,MAAA,CACV,QACE,CAAA,6EAAA,EAAgF,IAAI,IAAI,CAAA,6GAAA,CAAA,EACxF,SAAS,kCAAA;YAIf,IAAI,IAAI,IAAA,KAAS,SACf,OAAO,KAAK,MAAA,CACV,MACE,kHACA,SAAS,cAAA;YAKX,IAAA,KACK,OAAA;YAGT,MAAM,MAAM,CAAA,MAAA,EAAS,QAAQ,OAAO,SAAS,OAAO,GAAG,CAAA,6BAAA,CAAA;YACvD,OAAO,KAAK,MAAA,CACV,MACE,CAAA,wDAAA,EAA2D,GAAG,CAAA,EAAA,EAAK,GAAG,EAAA,EACtE,SAAS,gBAAA;QAGf,GAAG,EAAE;QAEL,IAAI,QAAQ,MAAA,GAAS,GACZ,OAAA;YACL,GAAG,OAAA;YACH,IAAI,CAAC,CAAA;YACL,WAAW;QACb;IAAA;IAIJ,MAAM,iJAAW,UAAA,EAAQ;QACvB,YACI,SAAS,QAAQ,EAAA,EAAI,CAAC,IAAM,GAAG,EAAE,IAAI,CAAA,CAAA,EAAI,EAAE,IAAI,EAAE,EAAE,GAAA,CAAI,CAAC,QACtD,MACE,CAAA,MAAA,EAAS,MAAM,MAAM,CAAA,+CAAA,EAAkD,KAAA,CAAM,CAAC,CAAA,CAAE,IAAI,CAAA,mGAAA,CAAA,EACpF,SAAS,mBAAA,KAGb,MACE,uFACA,SAAS,gBAAA;KAEhB,GACK,KAAK,YAAY,QAAQ,EAAA,GAAK,EAAA,EAG9B,4BAA4B,GAAG,IAAA,CACnC,CAAC,OAAc,KAAK,IAAA,KAAS,YAAY,OAAO,KAAK,IAAA,GAAS;IAE3C,GAAG,IAAA,CAAK,CAAC,SAAgB,OAAO,IAAA,KAAS,OAAO,KACjD,6BAClB,SAAS,IAAA,CACP,MACE,uJACA,SAAS,gBAAA;IAKT,MAAA,CAAC,gBAAgB,WAAW,CAAA,2IAAI,UAAA,EACpC,IACA,CAAC,SACC,oBAAoB,OAAO,IAAI,KAC/B,oBAAoB,eAAe,OAAA,CAAQ,OAAO,IAAI,GAAG,QAAQ,IAG/D,eAAe,eAAe,MAAA,GAAS,KAAK,YAAY,MAAA,GAAS;IAEvE,IAAI,cAAc;QAChB,MAAM,qBAAqB,eAAe,GAAA,CAAI,CAAC,IAAM,EAAE,IAAI,GACrD,kBAAkB,YAAY,GAAA,CAAI,CAAC,IAAM,EAAE,IAAI;QAC5C,SAAA,IAAA,CACP,MACE,CAAA,sGAAA,EAAyG,UACvG,oBACD,CAAA,gJAAI,UAAA,EAAa,mBAAmB,GAAA,CAAIA,OAAK,CAAC,CAAC,CAAA,gBAAA,EAAmB,UACjE,iBACD,CAAA,EAAI,wJAAA,EAAa,gBAAgB,GAAA,CAAIA,OAAK,CAAC,CAAC,CAAA,CAAA,CAAA,EAC7C,SAAS,gBAAA;IAEb;IAGI,MAAA,OAAO,SAAS,SAAS;IAC/B,OAAI,CAAC,gBAAgB,MAAM,OAAA,CAAQ,IAAI,KAAA,CACT,eAAe,MAAA,GAAS,IAElD,KAAK,OAAA,CAAQ,CAAC,WAAW;QACjB,MAAA,QAAQ,QAAQ,SAAS;QAI/B,IAAI,CAHe,eAAe,IAAA,CAAK,CAAC,gBAC/B,OAAO,UAAU,eAAe,OAAA,CAAQ,cAAc,IAAI,EAAE,QACpE,GACgB;YACf,MAAM,kKAAoB,UAAA,EACxB,eAAe,GAAA,CAAI,CAAC,IAAM,EAAE,IAAA,IAAQ,EAAE,IAAI,GAC1C;gBAAC,aAAa;YAAI;YAEX,SAAA,IAAA,CACP,MACE,CAAA,wCAAA,EAA2C,OACzC,OACD,iCAAA,EAAoC,iBAAiB,CAAA,2CAAA,EAA8C,iBAAiB,CAAA,CAAA,CAAA,EACrH,SAAS,gCAAA;QAEb;IAEH,CAAA,IAED,KAAK,OAAA,CAAQ,CAAC,WAAW;QACjB,MAAA,iBAAiB,OAAO,KAAA,IAAS;QACpB,YAAY,IAAA,CAAK,CAAC,kBACnC,aAAa,gBAAgB,eAAe,MAG5C,SAAS,IAAA,CACP,MACE,CAAA,wCAAA,EAA2C,OACzC,QACD,wCAAA,gJAA2C,UAAA,EAC1C,YACG,GAAA,CAAI,CAAC,IAAM,EAAE,IAAA,IAAQ,EAAE,IAAI,EAC3B,GAAA,CAAI,CAAC,IAAO,MAAM,WAAW,cAAcA,QAAM,CAAC,CAAE,GACvD;YAAC,aAAa;QAAI,IACnB,EACD,SAAS,gCAAA;IAEb,CAEH,CAAA,GAID,SAAS,SAAS,QAAQ,SAAS,SAAS,WAAW,UACzD,SAAS,IAAA,CACP,QACE,sLAKC;QACL,GAAG,OAAA;QACH,IAAI,GAAG,GAAA,CAAI,eAAe,KAAK;QAC/B,WAAW;IACb;AACF;AC9NgB,SAAA,aAAa,IAAA,EAAW,QAAA,EAAe,cAAA,EAAqB;IAC1E,IAAI,cAAc,MAChB,OAAO,KAAK,QAAA,KAAa;IAE3B,MAAM,aAAa,eAAe,OAAA,CAAQ,KAAK,IAAI;IACnD,IAAI,CAAC,YACH,MAAM,IAAI,MAAM,CAAA,8BAAA,EAAiC,KAAK,IAAI,CAAA,sBAAA,CAAwB;IAE7E,OAAA,aAAa,YAAY,UAAU,cAAc;AAC1D;ACFA,MAAM,YAAY,CAAC,QAAgB,MAAM,OAAA,CAAQ,KAAK,IAAI,UAAU,OAAO,OACrEA,UAAQ,CAAC,MAAa,CAAA,CAAA,EAAI,GAAG,CAAA,CAAA,CAAA,EAC7B,cAAc;IAClB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACF,EACM,kBAAkB;IAAC;IAAc,aAAa;CAAA,EAC9C,mBAAmB;IAAC;IAAe;IAAS;IAAS;IAAQ,WAAW;CAAA,EACxE,uBAAuB;IAAC;IAAe;IAAS;IAAS;IAAQ,WAAW;CAAA,EAC5E,kBAAkB;IAAC;IAAS;IAAS;IAAQ,WAAW;CAAA,EACxD,8BAA8B;IAClC;IACA;IACA;IACA;IACA;IACA;CACF;AAEwB,SAAA,kBAAkB,OAAA,EAAc,cAAA,EAAqB;IAC3E,MAAM,WAAW,CAAC,CAAA;IACd,IAAA,SAAS,QAAQ,MAAA,EACjB,QAAQ,QAAQ,KAAA,EAChB,QAAQ,QAAQ,KAAA,EAChB,UAAU,QAAQ,EAAA;IAEtB,MAAM,iBAAiB,OAAO,IAAA,CAAK,OAAO,EAAE,MAAA,CAC1C,CAAC,MAAQ,CAAC,YAAY,QAAA,CAAS,GAAG,KAAK,CAAC,IAAI,UAAA,CAAW,GAAG;IAGxD,OAAA,eAAe,MAAA,GAAS,KAC1B,SAAS,IAAA,CACP,MACE,CAAA,gDAAA,GAAmD,uJAAA,EACjD,eAAe,GAAA,CAAIA,OAAK,IACzB,IAKH,SAAA,CACF,QAAQ,cAAc,QAAQ,KAAA,EAAO,gBAAgB,QAAQ,CAAA,GAG3D,UAAA,CACF,SAAS,eAAe,QAAQ,gBAAgB,QAAQ,CAAA,GAGtD,SAAA,CACF,QAAQ,cAAc,OAAO,gBAAgB,QAAQ,CAAA,GAGnD,WAAA,CACF,UAAU,gBAAgB,SAAS,gBAAgB,QAAQ,CAAA,GAEtD;QACL,sIAAG,UAAA,EAAK,SAAS,cAAc,CAAA;QAC/B;QACA;QACA,MAAM,QAAQ,IAAA,IAAQ,QAAQ,IAAA;QAC9B,IAAI;QACJ,WAAW;IACb;AACF;AAEA,SAAS,cAAc,KAAA,EAAY,cAAA,EAAqB,QAAA,EAAe;IACrE,IAAI,aAAa,MAAM,UAAA,EACnB,cAAc,MAAM,WAAA;IAEpB,IAAA,CAAC,sJAAA,EAAc,KAAK,GACb,OAAA,SAAA,IAAA,CAAK,MAAM,CAAA,6CAAA,EAAgD,UAAU,KAAK,CAAC,EAAE,CAAC,GAChF;IAGT,MAAM,qBAAqB,OAAO,IAAA,CAAK,KAAK,EAAE,MAAA,CAC5C,CAAC,MAAQ,CAAC,gBAAgB,QAAA,CAAS,GAAG,KAAK,CAAC,IAAI,UAAA,CAAW,GAAG;IAG5D,OAAA,mBAAmB,MAAA,GAAS,KAC9B,SAAS,IAAA,CACP,MACE,CAAA,gDAAA,gJAAmD,UAAA,EACjD,mBAAmB,GAAA,CAAIA,OAAK,IAC7B,IAKH,cAAc,CAAC,MAAM,OAAA,CAAQ,UAAU,IACzC,SAAS,IAAA,CACP,MAAM,CAAA,uDAAA,EAA0D,UAAU,UAAU,CAAC,EAAE,KAEhF,cAAA,CACT,WACG,MAAA,CAAO,CAAC,MAAa,CAAC,CAAC,IAAI,WAAW,EACtC,OAAA,CAAQ,CAAC,QAAa;QACrB,IAAI,IAAA,GAAO,IAAI,WAAA,CAAY,IAAA,EAC3B,IAAI,SAAA,GAAY,IAAI,WAAA,CAAY,MAAA;IACjC,CAAA,GACH,aAAa,mBAAmB,YAAY,gBAAgB,QAAQ,CAAA,GAGlE,eAAe,CAAC,MAAM,OAAA,CAAQ,WAAW,IAC3C,SAAS,IAAA,CACP,MAAM,CAAA,wDAAA,EAA2D,UAAU,WAAW,CAAC,EAAE,KAElF,eAAA,CACT,cAAc,oBAAoB,aAAa,gBAAgB,QAAQ,CAAA,GAGlE;QAAC,GAAG,KAAA;QAAO;QAAY;IAAW;AAC3C;AAEA,SAAS,cAAc,KAAA,EAAY,cAAA,EAAqB,QAAA,EAAe;IAChE,OAAA,MAAM,OAAA,CAAQ,KAAK,IAAA,CAKxB,MAAM,OAAA,CAAQ,CAAC,MAAM,UAAU;QACzB,IAAA,6IAAC,UAAA,EAAc,IAAI,GAAG;YACxB,SAAS,IAAA,CAAK,MAAM,CAAA,4BAAA,EAA+B,UAAU,IAAI,CAAC,EAAE,CAAC;YACrE;QAAA;QAGI,MAAA,OAAO,KAAK,KAAA,IAAS,CAAA,CAAA,EAAI,KAAK,EAAA,EAC9B,iBAAiB,OAAO,IAAA,CAAK,IAAI,EAAE,MAAA,CACvC,CAAC,MAAQ,CAAC,gBAAgB,QAAA,CAAS,GAAG,KAAK,CAAC,IAAI,UAAA,CAAW,GAAG;QAG5D,eAAe,MAAA,GAAS,KAC1B,SAAS,IAAA,CACP,MACE,CAAA,kCAAA,EAAqC,IAAI,CAAA,EAAA,gJAAK,UAAA,EAAa,eAAe,GAAA,CAAIA,OAAK,CAAC,CAAC,EAAA,IAKtF,KAAK,KAAA,GAEC,OAAO,KAAK,KAAA,IAAU,WAC/B,SAAS,IAAA,CACP,MACE,CAAA,WAAA,EAAc,KAAK,CAAA,uDAAA,EAA0D,UAC3E,KAAK,KAAA,GACN,KAGK,KAAK,KAAA,IACf,SAAS,IAAA,CAAK,QAAQ,CAAA,UAAA,EAAa,IAAI,CAAA,wCAAA,CAA0C,CAAC,IAVlF,SAAS,IAAA,CAAK,MAAM,CAAA,MAAA,EAAS,KAAK,CAAA,qCAAA,CAAuC,CAAC;IAY7E,CAAA,GACM,KAAA,IAAA,CArCL,SAAS,IAAA,CAAK,MAAM,CAAA,4CAAA,EAA+C,UAAU,KAAK,CAAC,EAAE,CAAC,GAC/E,QAAA;AAqCX;AAEA,SAAS,eAAe,MAAA,EAAa,cAAA,EAAqB,QAAA,EAAe;IAClE,OAAA,MAAM,OAAA,CAAQ,MAAM,IAAA,CAKzB,OAAO,OAAA,CAAQ,CAAC,OAAO,UAAU;QAC3B,IAAA,6IAAC,UAAA,EAAc,KAAK,GAAG;YACzB,SAAS,IAAA,CAAK,MAAM,CAAA,6BAAA,EAAgC,UAAU,KAAK,CAAC,EAAE,CAAC;YACvE;QAAA;QAGI,MAAA,OAAO,MAAM,KAAA,IAAS,CAAA,CAAA,EAAI,KAAK,EAAA,EAC/B,iBAAiB,OAAO,IAAA,CAAK,KAAK,EAAE,MAAA,CACxC,CAAC,MAAQ,CAAC,iBAAiB,QAAA,CAAS,GAAG,KAAK,CAAC,IAAI,UAAA,CAAW,GAAG;QAG7D,eAAe,MAAA,GAAS,KAC1B,SAAS,IAAA,CACP,MACE,CAAA,mCAAA,EAAsC,IAAI,CAAA,EAAA,gJAAK,UAAA,EAAa,eAAe,GAAA,CAAIA,OAAK,CAAC,CAAC,EAAA,IAKvF,MAAM,KAAA,GAEA,OAAO,MAAM,KAAA,IAAU,WAChC,SAAS,IAAA,CACP,MACE,CAAA,OAAA,EAAU,KAAK,CAAA,uDAAA,EAA0D,UACvE,MAAM,KAAA,GACP,KAGK,MAAM,KAAA,IAChB,SAAS,IAAA,CAAK,QAAQ,CAAA,MAAA,EAAS,IAAI,CAAA,wCAAA,CAA0C,CAAC,IAV9E,SAAS,IAAA,CAAK,MAAM,CAAA,OAAA,EAAU,KAAK,CAAA,qCAAA,CAAuC,CAAC,GAYzE,OAAO,MAAM,WAAA,GAAgB,OAAA,CAC/B,SAAS,IAAA,CACP,QACE,+HACA,SAAS,0BAAA,IAIb,MAAM,SAAA,GAAY,MAAM,SAAA,IAAa,MAAM,WAAA,CAAY,MAAA;IAE1D,CAAA,GACM,MAAA,IAAA,CA/CL,SAAS,IAAA,CAAK,MAAM,CAAA,6CAAA,EAAgD,UAAU,MAAM,CAAC,EAAE,CAAC,GACjF,QAAA;AA+CX;AAEA,SAAS,mBAAmB,UAAA,EAAiB,cAAA,EAAqB,QAAA,EAAe;IACpE,OAAA,WAAA,OAAA,CAAQ,CAAC,WAAgB,UAAe;QAC7C,IAAA,CAAC,sJAAA,EAAc,SAAS,GAAG;YAC7B,SAAS,IAAA,CAAK,MAAM,CAAA,kCAAA,EAAqC,UAAU,SAAS,CAAC,EAAE,CAAC;YAChF;QAAA;QAGI,MAAA,OAAO,UAAU,KAAA,IAAS,CAAA,CAAA,EAAI,KAAK,EAAA,EACnC,iBAAiB,OAAO,IAAA,CAAK,SAAS,EAAE,MAAA,CAC5C,CAAC,MAAQ,CAAC,qBAAqB,QAAA,CAAS,GAAG,KAAK,CAAC,IAAI,UAAA,CAAW,GAAG;QAGjE,eAAe,MAAA,GAAS,KAC1B,SAAS,IAAA,CACP,MACE,CAAA,uCAAA,EAA0C,IAAI,CAAA,EAAA,GAAK,uJAAA,EACjD,eAAe,GAAA,CAAIA,OAAK,IACzB,IAKF,UAAU,KAAA,GAEJ,OAAO,UAAU,KAAA,IAAU,WACpC,SAAS,IAAA,CACP,MACE,CAAA,WAAA,EAAc,KAAK,CAAA,uDAAA,EAA0D,UAC3E,UAAU,KAAA,GACX,KAGK,UAAU,KAAA,IACpB,SAAS,IAAA,CAAK,QAAQ,CAAA,UAAA,EAAa,IAAI,CAAA,wCAAA,CAA0C,CAAC,IAVlF,SAAS,IAAA,CAAK,MAAM,CAAA,WAAA,EAAc,KAAK,CAAA,qCAAA,CAAuC,CAAC,GAY7E,OAAO,UAAU,WAAA,GAAgB,OAAA,CACnC,SAAS,IAAA,CACP,QACE,CAAA,WAAA,EAAc,IAAI,CAAA,uHAAA,CAAA,EAClB,SAAS,0BAAA,IAIb,UAAU,IAAA,GAAO,UAAU,IAAA,IAAQ,UAAU,WAAA,CAAY,IAAA,EACzD,UAAU,SAAA,GAAY,UAAU,SAAA,IAAa,UAAU,WAAA,CAAY,MAAA;IAEtE,CAAA,GACM;AACT;AAEA,SAAS,oBAAoB,WAAA,EAAkB,cAAA,EAAqB,QAAA,EAAe;IAC1E,OAAA,YAAY,GAAA,CAAI,CAAC,eAAoB;QACtC,IAAA,KAAC,kJAAA,EAAc,UAAU,GACpB,OAAA;YACL,GAAG,UAAA;YACH,WAAW;gBAAC,MAAM,CAAA,kCAAA,EAAqC,UAAU,UAAU,CAAC,EAAE,CAAC;aAAA;QACjF;QAGF,MAAM,EAAC,SAAA,CAAa,CAAA,GAAA,eAAe,KAAA,CAAM,YAAY,cAAc,GAC7D,aAAa,WAAW,IAAA,IAAQ,eAAe,OAAA,CAAQ,WAAW,IAAI;QAC5E,OAAI,cAAc,CAAC,aAAa,YAAY,UAAU,cAAc,KAClE,UAAU,IAAA,CACR,MACE,CAAA,6BAAA,EAAgC,WAAW,IAAI,CAAA,6CAAA,CAAA,IAKjD,OAAO,WAAW,WAAA,GAAgB,OAAA,CACpC,SAAS,IAAA,CACP,QACE,oIACA,SAAS,0BAAA,IAIb,WAAW,IAAA,GAAO,WAAW,IAAA,IAAQ,WAAW,WAAA,CAAY,IAAA,EACxD,WAAW,WAAA,EAAa,UAAU,CAAC,WAAW,UAAA,EAAY,cAAA,CAC5D,WAAW,UAAA,GAAa,WAAW,UAAA,IAAc,CAAA,GACjD,WAAW,UAAA,CAAW,UAAA,GACpB,WAAW,UAAA,CAAW,UAAA,IAAc,WAAW,WAAA,CAAY,MAAA,CAAA,GAI1D;YAAC,GAAG,UAAA;YAAY;QAAS;IAAA,CACjC;AACH;AAEA,SAAS,gBAAgB,OAAA,EAAc,cAAA,EAAqB,QAAA,EAAe;IACzE,IAAI,CAAC,MAAM,OAAA,CAAQ,OAAO,GAAG;QAC3B,SAAS,IAAA,CAAK,MAAM,CAAA,yCAAA,EAA4C,UAAU,OAAO,CAAC,EAAE,CAAC;QACrF;IAAA;IAGK,OAAA,QAAQ,GAAA,CAAI,CAAC,WAAW;QAC7B,MAAM,EAAC,SAAA,CAAS,CAAA,GAAI,eAAe,KAAA,CAAM,QAAQ,cAAc;QAC3D,IAAA,OAAO,IAAA,KAAS,YAAY,OAAO,IAAA,IAAQ,eAAe,OAAA,CAAQ,OAAO,IAAI,GACxE,OAAA;YACL,GAAG,MAAA;YACH,WAAW;gBACT,QACE,CAAA,6EAAA,EAAgF,OAAO,IAAI,CAAA,6GAAA,CAAA,EAC3F,SAAS,kCAAA;aACX;QAEJ;QAIF,IAAI,OAAO;QACJ,MAAA,QAAQ,CAAC,KAAK,QAAA,EACZ,OAAA,eAAe,OAAA,CAAQ,KAAK,IAAI;QAEnC,MAAA,qBAAqB,cAAc,MAAA,CAAO,CAAC,IAAM,CAAC,4BAA4B,QAAA,CAAS,CAAC,CAAC;QAC/F,OAAA,uDAAA;QAEG,QAAQ,KAAK,QAAA,KAAa,YAAA,+EAAA;QAE3B,mBAAmB,IAAA,CAAK,CAAC,WAAa,aAAa,OAAO,IAAI,IAEvD;YACL,GAAG,MAAA;YACH,WAAW;gBACT,MACE,CAAA,sGAAA,EAAyG,4BAA4B,IAAA,CACnI,QACD,8FAAA,CAAA,EACD,SAAS,mCAAA;aACX;QACF,IAGG;YAAC,GAAG,MAAA;YAAQ;QAAS;IAAA,CAC7B;AACH;AChWgB,SAAA,4BACd,OAAA,EACA,cAAA,EAC0B;IAC1B,IAAI,CAAA,CAAE,YAAY,OAAA,GAChB,OAAO,CAAC,CAAA;IAGV,IAAI,OAAO;IACJ,MAAA,QAAQ,CAAC,KAAK,QAAA,EACZ,OAAA,eAAe,OAAA,CAAQ,KAAK,IAAI;IAGrC,OAAA,QAAQ,KAAK,QAAA,KAAa,WACrB;QAAC,MAAM,gEAAgE,CAAC;KAAA,GAG1E,CAAC,CAAA;AACV;AClBA,MAAM,QAAQ,CAAC,MAAa,CAAA,CAAA,EAAI,GAAG,CAAA,CAAA,CAAA;AAEnB,SAAA,iBAAiB,QAAA,EAAkB,cAAA,EAAqB;IAChE,MAAA,oBAAoB,eAAe,YAAA,CAAa;IAEtD,IAAI,CAAC,UACH,OAAO;QAAC,MAAM,2BAA2B,SAAS,iBAAiB,CAAC;KAAA;IAGtE,IAAI,OAAO,YAAa,UACf,OAAA;QACL,MACE,6DACA,SAAS,iBAAA;KAEb;IAKF,IAAI,CAFY,kBAAkB,QAAA,CAAS,QAAQ,GAErC;QACN,MAAA,cAAc,kBACjB,GAAA,CAAI,CAAC,mBACG;gBAAC,6IAAA,EAAM,UAAU,gBAAgB;gBAAG,gBAAgB;aAC5D,EACA,MAAA,CAAO,CAAC,CAAC,QAAQ,CAAA,GAAW,WAAW,CAAC,EACxC,GAAA,CAAI,CAAC,CAAC,GAAG,IAAI,CAAA,GAAW,IAAI,GAEzB,aACJ,YAAY,MAAA,GAAS,IACjB,CAAA,cAAA,gJAAiBC,UAAAA,EAAS,YAAY,GAAA,CAAI,KAAK,GAAG;YAAC,aAAa;QAAA,CAAK,CAAC,CAAA,CAAA,CAAA,GACtE;QAEN,OAAO;YAAC,MAAM,CAAA,cAAA,EAAiB,QAAQ,CAAA,CAAA,EAAI,UAAU,EAAE,CAAC;SAAA;IAAA;IAE1D,OAAO,CAAC,CAAA;AACV;ACtCO,SAAS,6BAA6B,IAAA,EAAqC;IAChF,MAAM,WAAW,CAAC,CAAA;IAEd,OAAA,MAAM,kBACR,SAAS,IAAA,CACP,QAAQ,8EAA8E,IAItF,MAAM,SAAS,aACjB,SAAS,IAAA,CACP,QAAQ,mFAAmF,IAI3F,MAAM,iBACR,SAAS,IAAA,CACP,QAAQ,4EAA4E,IAIpF,MAAM,SAAS,aACjB,SAAS,IAAA,CACP,QAAQ,8EAA8E,IAItF,MAAM,SAAS,iBACjB,SAAS,IAAA,CACP,QACE,mJAKC;AACT;ACnCA,IAAA,SAAe,CAAC,SAAc,iBAAA,CACrB;QACL,GAAG,OAAA;QACH,WAAW;eACN,iBAAiB,QAAQ,IAAA,EAAM,cAAc;eAC7C,4BAA4B,SAAS,cAAc;eACnD,6BAA6B,OAAO;SACzC,CAAE,MAAA,CAAO,OAAO;IAClB,CAAA;ACNF,SAASC,kBAAgB,OAAA,EAAc;IACrC,OAAI,MAAM,OAAA,CAAQ,QAAQ,EAAE,IACnB,QAAQ,EAAA,GAEV,QAAQ,EAAA,GAAK;QAAC,QAAQ,EAAE;KAAA,GAAI,QAAQ,EAAA;AAC7C;AAEA,MAAM,gBAAgB;AACf,SAAS,mBAAmB,IAAA,EAA6B;IAE9D,OADgB,KAAK,MAAA,IAAU,KAAK,KAAK,WAAA,CAAY,MAAM,QAAQ,cAAc,IAAA,CAAK,IAAI,KAGxF,CAAA,sBAAA,EAAyB,IAAI,CAAA,wMAAA,CAAA;AAEjC;AAEA,IAAA,wBAAe,CAAC,SAAc,mBAAwB;IACpD,MAAM,YAAY,MAAM,OAAA,CAAQ,QAAQ,EAAE,iJAAK,UAAA,EAAc,QAAQ,EAAE,GACjE,eAAeA,kBAAgB,OAAO,GAEtC,gJAAW,WAAA,EAAQ;QACvB,YACI,SAAS,cAAc,CAAC,IAAM,GAAG,EAAE,IAAI,CAAA,CAAA,EAAI,EAAE,IAAI,EAAE,EAAE,GAAA,CAAI,CAAC,QACxD,MACE,CAAA,MAAA,EAAS,MAAM,MAAM,CAAA,+CAAA,EAAkD,KAAA,CAAM,CAAC,CAAA,CAAE,IAAI,CAAA,uGAAA,CAAA,EACpF,SAAS,+BAAA,KAGb,MACE,mJACA,SAAS,+BAAA;KAEhB;IAiCD,IA/BI,aAAa,aAAa,MAAA,KAAW,KACvC,SAAS,IAAA,CACP,MACE,gHACA,SAAS,+BAAA,IAKf,aAAa,OAAA,CAAQ,CAAC,qBAA0B,UAAe;QACxD,oBAAoB,IAAA,IACvB,SAAS,IAAA,CACP,MACE,CAAA,6BAAA,EAAgC,KAAK,CAAA,8EAAA,CAAA,EACrC,SAAS,+BAAA,gJAKV,UAAA,EAAc,oBAAoB,OAAO,KAC5C,SAAS,IAAA,CACP,MACE,CAAA,yDAAA,EACE,oBAAoB,IAAA,IAAQ,gBAC9B,CAAA,CAAA,CAAA,EACA,SAAS,+BAAA;IAIhB,CAAA,GAEG,OAAO,QAAQ,OAAA,IAAY,UAAU;QACjC,MAAA,oBAAoB,mBAAmB,QAAQ,OAAO;QACxD,sBAAsB,CAAA,KACxB,SAAS,IAAA,CAAK,MAAM,mBAAmB,SAAS,+BAA+B,CAAC;IAEpF,OACW,SAAA,IAAA,CACP,MACE,sDACA,SAAS,+BAAA;IAKf,OAAI,QAAQ,SAAA,IAAa,OAAO,QAAQ,SAAA,IAAc,cACpD,SAAS,IAAA,CACP,MACE,wIACA,SAAS,+BAAA,IAKf,SAAS,IAAA,CAAK,GAAGC,kBAAgB,OAAO,CAAC,GAElC;QACL,GAAG,OAAA;QACH,WAAW;IACb;AACF;AAEA,SAASA,kBAAgB,OAAA,EAAwC;IAC/D,MAAM,EAAC,OAAA,CAAA,CAAA,GAAW,SACZ,WAAW,CAAC,CAAA;IAalB,OAXA,SAAS,IAAA,IACJ;QAAC;QAAU,cAAc;KAAA,CACzB,MAAA,CAAO,CAAC,MAAQ,OAAO,OAAO,EAC9B,GAAA,CAAI,CAAC,MACJ,MACE,CAAA,EAAA,EAAK,GAAG,CAAA,0EAAA,EAA6E,GAAG,CAAA,GAAA,CAAA,EACxF,SAAS,kCAAA,KAKZ,sJAIA,UAAA,EAAc,OAAO,IAStB,OAAO,QAAQ,MAAA,IAAW,cAAc,OAAO,QAAQ,YAAA,GAAiB,MACnE,SAAS,MAAA,CACd,MACE,0JACA,SAAS,2CAAA,KAKX,OAAO,QAAQ,MAAA,IAAW,cAAe,CAAC,QAAQ,MAAA,IAAU,CAAC,QAAQ,YAAA,GAChE,WAGL,OAAO,QAAQ,MAAA,IAAW,WACrB,SAAS,MAAA,CACd,MAAM,CAAA,yCAAA,EAA4C,OAAO,QAAQ,MAAM,EAAE,KAIzE,OAAO,QAAQ,YAAA,GAAiB,OAAe,6IAAC,UAAA,EAAc,QAAQ,YAAY,IAC7E,SAAS,MAAA,CAAO,MAAM,2CAA6C,CAAC,IAGzE,QAAQ,YAAA,GACH,SAAS,MAAA,CACd,OAAO,IAAA,CAAK,QAAQ,YAAY,EAC7B,MAAA,CAAO,CAAC,MAAQ,IAAI,UAAA,CAAW,IAAI,KAAK,IAAI,UAAA,CAAW,GAAG,CAAC,EAC3D,GAAA,CAAI,CAAC,MAAQ,MAAM,CAAA,0DAAA,EAA6D,GAAG,CAAA,EAAA,CAAI,CAAC,KAIxF,WAvCE,SAAS,MAAA,CACd,MACE,wDACA,SAAS,yBAAA,KAPN;AA4CX;AClKA,MAAM,eAAe;AAEd,SAAS,gBAAgB,KAAA,EAAY;IAG1C,OAFa,OAAO,SAGT,cACR,OAAO,OAAO,YAAa,YAAY,aAAa,IAAA,CAAK,OAAO,OAAO,QAAQ,CAAC;AAErF;ACJO,SAAS,kBAAkB,OAAA,EAAwC;IACxE,MAAM,aAAa,gBAAgB,UAAU,QAAQ,UAAA,GAAa,CAAA;IAClE,IAAI,CAAC,YACH,OAAO,CAAC,CAAA;IAGV,MAAM,WAAqC,CAAC,CAAA;IAE5C,OAAI,WAAW,KAAA,IAAS,CAAC,gBAAgB,WAAW,KAAK,KACvD,SAAS,IAAA,CACP,QACE,CAAA,yHAAA,iJAA4H,UAAA,EAC1H,WAAW,KAAA,EACZ,wHAAA,CAAA,IAKH,WAAW,KAAA,IAAS,CAAC,gBAAgB,WAAW,KAAK,KACvD,SAAS,IAAA,CACP,QACE,CAAA,yHAAA,iJAA4H,UAAA,EAC1H,WAAW,KAAA,EACZ,wHAAA,CAAA,IAKH,WAAW,IAAA,IAAQ,CAAC,gBAAgB,WAAW,IAAI,KACrD,SAAS,IAAA,CACP,QACE,CAAA,wHAAA,EAA2H,yJAAA,EACzH,WAAW,IAAA,EACZ,uHAAA,CAAA,IAKH,WAAW,OAAA,IAAW,CAAC,gBAAgB,WAAW,OAAO,KAC3D,SAAS,IAAA,CACP,QACE,CAAA,2HAAA,iJAA8H,UAAA,EAC5H,WAAW,OAAA,EACZ,0HAAA,CAAA,IAKA;AACT;AChDA,MAAM,iBAAiB,4BACjB,wBAAwB;AAa9B,SAAS,kBAAkB,IAAA,EAAuB;IAC5C,OAAA,OAAO,QAAS,WACX;QACL,MACE,CAAA,kCAAA,iJAAqC,UAAA,EAAQ,IAAI,CAAC,CAAA,CAAA,CAAA,EAClD,SAAS,yBAAA;KACX,GAGA,KAAK,UAAA,CAAW,GAAG,IACd;QACL,MACE,CAAA,oBAAA,EAAuB,IAAI,CAAA,oFAAA,CAAA,EAC3B,SAAS,yBAAA;KACX,GAIC,eAAe,IAAA,CAAK,IAAI,IAUxB,sBAAsB,IAAA,CAAK,IAAI,IAS7B,EAAA,GARE;QACL,QACE;QAGF,SAAS,yBAAA;KAAA,GAfJ;QACL,MACE,CAAA,qBAAA,EAAwB,IAAI,CAAA,6IAAA,EAAgJ,OAC1K,gBACD,EAAA,CAAA,EACD,SAAS,yBAAA;KAEb;AAYJ;AAEgB,SAAA,cAAc,KAAA,EAAY,eAAA,EAAsB;IAC1D,IAAA,4IAAC,WAAA,EAAc,KAAK,GACf,OAAA;QACL,MACE,CAAA,+DAAA,iJAAkE,UAAA,EAAQ,KAAK,CAAC,EAAA,EAChF,SAAS,oCAAA;KAEb;IAGF,MAAM,WAAW,CAAC,CAAA;IACT,OAAA,SAAA,IAAA,IACH,UAAU,QACV,kBAAkB,MAAM,IAAI,IAC5B;QAAC,MAAM,sBAAsB,SAAS,yBAAyB,CAAC;KAAA,GAEtE,SAAS,IAAA,CAAK,GAAG,kBAAkB,KAAK,CAAC,GAClC;AACT;AAEA,SAAS,mBAAmBN,MAAAA,EAAiD;IAC3E,MAAM,QAAwC,CAAC;IACzC,OAAAA,OAAA,OAAA,CAAQ,CAAC,UAAU;QAClB,KAAA,CAAM,MAAM,IAAI,CAAA,IAAA,CACnB,KAAA,CAAM,MAAM,IAAI,CAAA,GAAI,CAAA,CAAA,GAEtB,KAAA,CAAM,MAAM,IAAI,CAAA,CAAE,IAAA,CAAK,KAAK;IAAA,CAC7B,GACM,OAAO,IAAA,CAAK,KAAK,EACrB,GAAA,CAAI,CAAC,YAAe,KAAA,CAAM,SAAS,CAAA,CAAE,MAAA,GAAS,IAAI,KAAA,CAAM,SAAS,CAAA,GAAI,IAAK,EAC1E,MAAA,CAAO,OAAO;AACnB;AAEO,SAAS,eAAe,MAAA,EAAa,UAAU;IAAC,YAAY,CAAA;AAAA,CAAA,EAAQ;IACzE,MAAM,WAAW,CAAC,CAAA;IAEd,IAAA,CADkB,MAAM,OAAA,CAAQ,MAAM,GAEjC,OAAA;QACL,MACE,CAAA,+DAAA,EAAkE,OAAO,MAAM,CAAA,CAAA,CAAA,EAC/E,SAAS,qBAAA;KAEb;IAGI,MAAA,kBAAkB,OAAO,MAAA,CAAO,CAAC,QAAU,OAAO,MAAM,IAAA,IAAS,QAAQ;IAE/E,mBAAmB,eAAe,EAAE,OAAA,CAAQ,CAAC,UAAU;QAC5C,SAAA,IAAA,CACP,MACE,CAAA,MAAA,EAAS,MAAO,MAAM,CAAA,mBAAA,EAAsB,KAAA,CAAO,CAAC,CAAA,CAAE,IAAI,CAAA,WAAA,CAAA,EAC1D,SAAS,uBAAA;IAGd,CAAA,GAEG,OAAO,MAAA,KAAW,KAAK,CAAC,QAAQ,UAAA,IAClC,SAAS,IAAA,CAAK,MAAM,yCAAyC,SAAS,qBAAqB,CAAC;IAG9F,MAAM,wBAAwB,OAC3B,MAAA,CAAO,CAAC,QAAU,MAAM,IAAA,KAAS,OAAO,EACxC,GAAA,CAAI,CAAC,QAAU,CAAA,CAAA,EAAI,MAAM,IAAI,CAAA,CAAA,CAAG;IAE/B,IAAA,sBAAsB,MAAA,GAAS,GAAG;QAC9B,MAAA,YAAY,sBAAsB,IAAA,CAAK,IAAI;QACxC,SAAA,IAAA,CACP,MACE,CAAA,kCAAA,EAAqC,SAAS,CAAA,qDAAA,CAAA,EAC9C,SAAS,qBAAA;IAEb;IAGK,OAAA;AACT;AAEO,SAAS,gBAAgB,OAAA,EAAwB;IACjD,OAAA,sJAAA,EAAc,OAAO,IAItB,OAAO,QAAQ,OAAA,GAAY,OAAe,OAAO,QAAQ,OAAA,IAAY,aAChE;QACL,MACE,CAAA,gEAAA,EAAmE,OAAO,QAAQ,OAAO,CAAA,CAAA,CAAA;KAC3F,GAIC,QAAQ,MAAA,IAIR,qJAAA,EAAc,QAAQ,MAAM,IAQ1B,OAAO,IAAA,CAAK,QAAQ,MAAM,EAAE,MAAA,CAAO,CAAC,MAAW,MAC7C,OAAO,QAAQ,MAAA,CAAQ,GAAG,CAAA,IAAM,WACnC,OACA,KAAK,MAAA,CACH,MACE,CAAA,SAAA,EAAY,GAAG,CAAA,qDAAA,EAAwD,OAAO,QAC3E,MAAA,CAAQ,GAAG,CAAC,CAAA,CAAA,CAAA,IAGtB,CAAE,CAAA,IAhBI;QACL,MACE,CAAA,8DAAA,EAAiE,OAAO,QAAQ,OAAO,CAAA,CAAA,CAAA;KACzF,GAPK,CAAA,CAAA,GAZA;QAAC,MAAM,CAAA,uDAAA,EAA0D,OAAO,OAAO,CAAA,CAAA,CAAG,CAAC;KAAA;AAiC9F;AAEA,IAAA,SAAe,CAAC,SAAc,mBAAwB;IACpD,IAAI,WAAW,eAAe,QAAQ,MAAM,GAExC,UAAU,QAAQ,OAAA;IACtB,IAAI,SAAS;QACL,MAAA,gBAAgB,gBAAgB,QAAQ,OAAO;QACrD,WAAW,SAAS,MAAA,CAAO,aAAa,GACxC,UAAU,cAAc,IAAA,CAAK,CAAC,MAAa,IAAI,QAAA,KAAa,OAAO,IAAI,CAAK,IAAA;IAAA;IAI5E,OAAA,QAAQ,IAAA,KAAS,cACjB,QAAQ,IAAA,KAAS,YACjB,OAAO,QAAQ,YAAA,GAAiB,OAEhC,SAAS,IAAA,CACP,MAAM,sFAAsF,IAIzF;QACL,GAAG,OAAA;QACH;QACA,QAAA,CAAS,MAAM,OAAA,CAAQ,QAAQ,MAAM,IAAI,QAAQ,MAAA,GAAS,CAAA,CAAA,EAAI,GAAA,CAAI,CAAC,OAAY,UAAe;YAC5F,MAAM,EAAC,IAAA,EAAM,GAAG,cAAA,GAAgB,OAC1B,EAAC,SAAA,EAAW,GAAG,UAAS,CAAA,GAAI,eAAe,KAAA,CAAM,cAAc,KAAK;YACnE,OAAA;gBACL;gBACA,GAAG,SAAA;gBACH,WAAW,cAAc,KAAqB,EAAE,MAAA,CAAO,aAAa,CAAE,CAAA;YACxE;QAAA,CACD;QACD,WAAW;IACb;AACF,GC3MA,kBAAe,CAAC,gBAAqB,mBAAwB;IACrD,MAAA,UAAU,OAAO,gBAAgB,cAAc,GAC/C,EAAC,YAAA,EAAc,aAAA,EAAA,GAAiB;IAEd,OAAA,OAAO,eAAiB,OACzB,6IAAC,UAAA,EAAc,YAAY,KAAK,OAAO,gBAAiB,cAC7E,QAAQ,SAAA,CAAU,IAAA,CAChB,MAAM,yEAAyE,IAI/E,OAAO,gBAAkB,OAC3B,QAAQ,SAAA,CAAU,IAAA,CAAK,MAAM,+DAA+D,CAAC,GAGxF;AACT,GClBA,OAAe,CAAC,SAAc,mBAAwB;IACpD,MAAM,WAAW,CAAA,CAAA,EACX,SAAS,QAAQ,MAAA;IAEnB,UACF,SAAS,IAAA,CAAK,GAAG,eAAe,QAAQ;QAAC,YAAY,CAAA;IAAI,CAAC,CAAC;IAG7D,MAAM,oBAAoB,MAAM,OAAA,CAAQ,MAAM,IAC1C,QAAQ,OAAO,CAAC,QAAU,MAAM,IAAA,KAAS,OAAO,IAChD,CAAC,CAAA;IAEL,OACE,QAAQ,OAAA,IACR,OAAO,QAAQ,OAAA,CAAQ,QAAA,GAAa,OACpC,CAAC,MAAM,OAAA,CAAQ,QAAQ,OAAA,CAAQ,QAAQ,IAEvC,SAAS,IAAA,CACP,MACE,wEACA,SAAS,4BAAA,KAGJ,kBAAkB,MAAA,GAAS,KACpC,SAAS,IAAA,CAAK,MAAM,6DAA6D,CAAC,GAG7E;QACL,GAAG,OAAA;QACH,QAAA,CAAS,MAAM,OAAA,CAAQ,MAAM,IAAI,SAAS,CAAA,CAAA,EAAI,GAAA,CAAI,CAAC,OAAO,UAAU;YAClE,MAAM,EAAC,IAAA,EAAM,GAAG,cAAA,GAAgB,OAC1B,EAAC,SAAA,EAAW,GAAG,UAAS,CAAA,GAAI,eAAe,KAAA,CAAM,cAAc,KAAK;YACnE,OAAA;gBACL;gBACA,GAAG,SAAA;gBACH,WAAW,cAAc,KAAqB,EAAE,MAAA,CAAO,aAAa,CAAE,CAAA;YACxE;QAAA,CACD;QACD,WAAW;IACb;AACF;ACrCA,SAASK,kBAAgB,OAAA,EAAc;IACrC,OAAI,MAAM,OAAA,CAAQ,QAAQ,EAAE,IACnB,QAAQ,EAAA,GAEV,QAAQ,EAAA,GAAK;QAAC,QAAQ,EAAE;KAAA,GAAI,QAAQ,EAAA;AAC7C;AAEO,SAAS,oBAAoB,YAAA,EAAqC;IACvE,OAAK,eAGD,gBAAgB,mBAAmB,gBAAgB,YAC9C,kEAEF,CAAA,IALE;AAMX;AAEgB,SAAA,kBAAkB,YAAA,EAAsB,UAAA,EAAmC;IACzF,OAAK,aAGD,iBAAiB,YACL,WAAW,KAAA,CAAM,GAAG,EACxB,MAAA,KAAW,IACZ,4FAEF,CAAA,IAEL,iBAAiB,kBACZ,CAAA,IAEF,CAAA,+CAAA,EAAkD,YAAY,EAAA,GAZ5D;AAaX;AAEA,IAAA,0BAAe,CAAC,SAAc,mBAAwB;IACpD,MAAM,YAAY,MAAM,OAAA,CAAQ,QAAQ,EAAE,iJAAK,UAAA,EAAc,QAAQ,EAAE,GACjE,eAAeA,kBAAgB,OAAO,GAEtC,YAAW,+IAAA,EAAQ;QACvB,YACI,SAAS,cAAc,CAAC,IAAM,GAAG,EAAE,IAAI,CAAA,CAAA,EAAI,EAAE,IAAI,EAAE,EAAE,GAAA,CAAI,CAAC,QACxD,MACE,CAAA,MAAA,EAAS,MAAM,MAAM,CAAA,+CAAA,EAAkD,KAAA,CAAM,CAAC,CAAA,CAAE,IAAI,CAAA,uGAAA,CAAA,EACpF,SAAS,iCAAA,KAGb,MACE,qJACA,SAAS,iCAAA;KAEhB;IAiCD,IA/BI,aAAa,aAAa,MAAA,KAAW,KACvC,SAAS,IAAA,CACP,MACE,kHACA,SAAS,iCAAA,IAKf,aAAa,OAAA,CAAQ,CAAC,qBAA0B,UAAe;QACxD,oBAAoB,IAAA,IACvB,SAAS,IAAA,CACP,MACE,CAAA,6BAAA,EAAgC,KAAK,CAAA,8EAAA,CAAA,EACrC,SAAS,iCAAA,gJAKV,UAAA,EAAc,oBAAoB,OAAO,KAC5C,SAAS,IAAA,CACP,MACE,CAAA,yDAAA,EACE,oBAAoB,IAAA,IAAQ,gBAC9B,CAAA,CAAA,CAAA,EACA,SAAS,iCAAA;IAIhB,CAAA,GAEG,OAAO,QAAQ,YAAA,IAAiB,UAAU;QACtC,MAAA,aAAa,oBAAoB,QAAQ,YAAY;QACvD,eAAe,CAAA,KACjB,SAAS,IAAA,CAAK,MAAM,YAAY,SAAS,iCAAiC,CAAC;IAE/E,OACW,SAAA,IAAA,CACP,MACE,6DACA,SAAS,iCAAA;IAKX,IAAA,OAAO,QAAQ,UAAA,IAAe,UAAU;QAC1C,MAAM,oBAAoB,kBAAkB,QAAQ,YAAA,EAAc,QAAQ,UAAU;QAChF,sBAAsB,CAAA,KACxB,SAAS,IAAA,CAAK,MAAM,mBAAmB,SAAS,iCAAiC,CAAC;IAEtF,OACW,SAAA,IAAA,CACP,MACE,2DACA,SAAS,iCAAA;IAKf,OAAI,QAAQ,SAAA,IAAa,OAAO,QAAQ,SAAA,IAAc,cACpD,SAAS,IAAA,CACP,MACE,0IACA,SAAS,iCAAA,IAKf,SAAS,IAAA,CAAK,GAAGC,kBAAgB,OAAO,CAAC,GAElC;QACL,GAAG,OAAA;QACH,WAAW;IACb;AACF;AAEA,SAASA,kBAAgB,OAAA,EAAwC;IAC/D,MAAM,EAAC,OAAA,CAAA,CAAA,GAAW,SACZ,WAAW,CAAC,CAAA;IAalB,OAXA,SAAS,IAAA,IACJ;QAAC;QAAU,cAAc;KAAA,CACzB,MAAA,CAAO,CAAC,MAAQ,OAAO,OAAO,EAC9B,GAAA,CAAI,CAAC,MACJ,MACE,CAAA,EAAA,EAAK,GAAG,CAAA,0EAAA,EAA6E,GAAG,CAAA,GAAA,CAAA,EACxF,SAAS,kCAAA,KAKZ,cAIA,kJAAA,EAAc,OAAO,IAStB,OAAO,QAAQ,MAAA,IAAW,cAAc,OAAO,QAAQ,YAAA,GAAiB,MACnE,SAAS,MAAA,CACd,MACE,0JACA,SAAS,2CAAA,KAKX,OAAO,QAAQ,MAAA,IAAW,cAAe,CAAC,QAAQ,MAAA,IAAU,CAAC,QAAQ,YAAA,GAChE,WAGL,OAAO,QAAQ,MAAA,IAAW,WACrB,SAAS,MAAA,CACd,MAAM,CAAA,yCAAA,EAA4C,OAAO,QAAQ,MAAM,EAAE,KAIzE,OAAO,QAAQ,YAAA,GAAiB,OAAe,6IAAC,UAAA,EAAc,QAAQ,YAAY,IAC7E,SAAS,MAAA,CAAO,MAAM,2CAA6C,CAAC,IAGzE,QAAQ,YAAA,GACH,SAAS,MAAA,CACd,OAAO,IAAA,CAAK,QAAQ,YAAY,EAC7B,MAAA,CAAO,CAAC,MAAQ,IAAI,UAAA,CAAW,IAAI,KAAK,IAAI,UAAA,CAAW,GAAG,CAAC,EAC3D,GAAA,CAAI,CAAC,MAAQ,MAAM,CAAA,0DAAA,EAA6D,GAAG,CAAA,EAAA,CAAI,CAAC,KAIxF,WAvCE,SAAS,MAAA,CACd,MACE,wDACA,SAAS,yBAAA,KAPN;AA4CX;AC/LA,MAAM,WAAW;IAAC;IAAc;IAAY,UAAU;CAAA;AAEtD,IAAA,QAAe,CAAC,SAAc,mBAAwB;IACpD,MAAM,WAAW,CAAA,CAAA,EACX,SAAS,QAAQ,MAAA;IAEnB,UACF,SAAS,IAAA,CAAK,GAAG,eAAe,QAAQ;QAAC,YAAY,CAAA;IAAI,CAAC,CAAC;IAG7D,IAAI,UAAU,QAAQ,OAAA;IACtB,MAAM,WAAW,SAAS,UACpB,kBAAkB,MAAM,OAAA,CAAQ,QAAQ,IAC1C,SAAS,MAAA,CAAO,CAAC,OAAS,SAAS,QAAA,CAAS,IAAI,CAAC,IACjD,EAAA,EAEE,oBAAoB;QAAC;QAAS;QAAW,MAAM;KAAA,EAE/C,wBAAwB,MAAM,OAAA,CAAQ,MAAM,IAC9C,QAAQ,OAAO,CAAC,QAAU,kBAAkB,QAAA,CAAS,MAAM,IAAI,CAAC,IAChE,CAAC,CAAA;IAED,OAAA,OAAO,WAAa,OAAe,CAAC,MAAM,OAAA,CAAQ,QAAQ,IAC5D,SAAS,IAAA,CACP,MACE,yEACA,SAAS,4BAAA,KAGJ,gBAAgB,MAAA,GAAS,IAAA,CAClC,SAAS,IAAA,CACP,QACE,CAAA,qFAAA,EAAwF,gBAAgB,IAAA,CACtG,OACD,IAGL,UAAU;QAAC,GAAG,OAAA;QAAS,UAAU,SAAU,MAAA,CAAO,CAAC,OAAS,CAAC,SAAS,QAAA,CAAS,IAAI,CAAC;IAAA,CAAA,IAC3E,sBAAsB,MAAA,GAAS,KACxC,SAAS,IAAA,CACP,MACE,CAAA,YAAA,EAAe,kBAAkB,IAAA,CAC/B,QACD,8CAAA,CAAA,IAKA;QACL,GAAG,OAAA;QACH;QACA,QAAA,CAAS,MAAM,OAAA,CAAQ,MAAM,IAAI,SAAS,CAAA,CAAA,EAAI,GAAA,CAAI,CAAC,OAAO,UAAU;YAClE,MAAM,EAAC,IAAA,EAAM,GAAG,cAAA,GAAgB,OAC1B,EAAC,SAAA,EAAW,GAAG,UAAS,CAAA,GAAI,eAAe,KAAA,CAAM,cAAc,KAAK;YACnE,OAAA;gBACL;gBACA,GAAG,SAAA;gBACH,WAAW,cAAc,KAAqB,EAAE,MAAA,CAAO,aAAa,CAAE,CAAA;YACxE;QAAA,CACD;QACD,WAAW;IACb;AACF;AC3DA,SAAS,gBAAgB,OAAA,EAAc;IACrC,OAAI,MAAM,OAAA,CAAQ,QAAQ,EAAE,IACnB,QAAQ,EAAA,GAEV,QAAQ,EAAA,GAAK;QAAC,QAAQ,EAAE;KAAA,GAAI,QAAQ,EAAA;AAC7C;AAEA,IAAA,YAAe,CAAC,SAAc,mBAAwB;IACpD,MAAM,YAAY,MAAM,OAAA,CAAQ,QAAQ,EAAE,iJAAK,UAAA,EAAc,QAAQ,EAAE,GACjE,eAAe,gBAAgB,OAAO,GAEtC,iJAAW,UAAA,EAAQ;QACvB,YACI,SAAS,cAAc,CAAC,IAAM,GAAG,EAAE,IAAI,CAAA,CAAA,EAAI,EAAE,IAAI,EAAE,EAAE,GAAA,CAAI,CAAC,QACxD,MACE,CAAA,MAAA,EAAS,MAAM,MAAM,CAAA,+CAAA,EAAkD,KAAA,CAAM,CAAC,CAAA,CAAE,IAAI,CAAA,uGAAA,CAAA,EACpF,SAAS,oBAAA,KAGb,MACE,qIACA,SAAS,oBAAA;KAEhB;IAED,OAAI,aAAa,aAAa,MAAA,KAAW,KACvC,SAAS,IAAA,CACP,MACE,gGACA,SAAS,oBAAA,IAKf,SAAS,IAAA,CAAK,GAAG,gBAAgB,OAAO,CAAC,GAElC;QACL,GAAG,OAAA;QACH,IAAA,CAAK,YAAY,eAAe,CAAI,CAAA,EAAA,GAAA,CAAI,eAAe,KAAK;QAC5D,WAAW;IACb;AACF;AAEA,SAAS,gBAAgB,OAAA,EAAwC;IAC/D,MAAM,EAAC,OAAA,CAAA,CAAA,GAAW,SACZ,WAAW,CAAC,CAAA;IAalB,OAXA,SAAS,IAAA,IACJ;QAAC;QAAU,cAAc;KAAA,CACzB,MAAA,CAAO,CAAC,MAAQ,OAAO,OAAO,EAC9B,GAAA,CAAI,CAAC,MACJ,MACE,CAAA,EAAA,EAAK,GAAG,CAAA,0EAAA,EAA6E,GAAG,CAAA,GAAA,CAAA,EACxF,SAAS,kCAAA,KAKZ,cAIA,kJAAA,EAAc,OAAO,IAStB,OAAO,QAAQ,MAAA,IAAW,cAAc,OAAO,QAAQ,YAAA,GAAiB,MACnE,SAAS,MAAA,CACd,MACE,0JACA,SAAS,2CAAA,KAKX,OAAO,QAAQ,MAAA,IAAW,cAAe,CAAC,QAAQ,MAAA,IAAU,CAAC,QAAQ,YAAA,GAChE,WAGL,OAAO,QAAQ,MAAA,IAAW,WACrB,SAAS,MAAA,CACd,MAAM,CAAA,yCAAA,EAA4C,OAAO,QAAQ,MAAM,EAAE,KAIzE,OAAO,QAAQ,YAAA,GAAiB,OAAe,6IAAC,UAAA,EAAc,QAAQ,YAAY,IAC7E,SAAS,MAAA,CAAO,MAAM,2CAA6C,CAAC,IAGzE,QAAQ,YAAA,GACH,SAAS,MAAA,CACd,OAAO,IAAA,CAAK,QAAQ,YAAY,EAC7B,MAAA,CAAO,CAAC,MAAQ,IAAI,UAAA,CAAW,IAAI,KAAK,IAAI,UAAA,CAAW,GAAG,CAAC,EAC3D,GAAA,CAAI,CAAC,MAAQ,MAAM,CAAA,0DAAA,EAA6D,GAAG,CAAA,EAAA,CAAI,CAAC,KAIxF,WAvCE,SAAS,MAAA,CACd,MACE,wDACA,SAAS,yBAAA,KAPN;AA4CX;AC1GA,IAAA,WAAe,CAAC,SAAc,mBAAwB;IAC9C,MAAA,UAAU,CAAA,CAAQ,QAAQ,IAAA;IAChC,IAAI,CAAC,WAAW,OAAO,IAAA,CAAK,OAAO,EAAE,MAAA,KAAW,GAEvC,OAAA;QACL,GAAG,OAAA;QACH,WAAW;YACT,MACE,kGACA,SAAS,YAAA;SACX;IAEJ;IAGF,MAAM,WAAW,CAAC,CAAA;IACd,OAAA,mBAAmB,OAAO,IAC5B,SAAS,IAAA,CACP,MACE,kIACA,SAAS,kBAAA,KAGH,UAED,eAAe,UAAA,CAAW,QAAQ,IAAI,KAC/C,SAAS,IAAA,CACP,MACE,CAAA,oBAAA,EAAuB,QAAQ,IAAI,CAAA,qBAAA,CAAA,EACnC,SAAS,kBAAA,KALb,SAAS,IAAA,CAAK,MAAM,qBAAqB,SAAS,iBAAiB,CAAC,GAUlE,eAAe,WAAA,CAAY,QAAQ,IAAI,KACzC,SAAS,IAAA,CACP,MACE,CAAA,qCAAA,EAAwC,QAAQ,IAAI,CAAA,mCAAA,CAAA,IAK1D,SAAS,IAAA,CAAK,GAAG,kBAAkB,OAAO,CAAC,GAEvC,WAAW,WAAW,OAAO,QAAQ,KAAA,IAAU,YACjD,SAAS,IAAA,CAAK,QAAQ,+BAA+B,SAAS,kBAAkB,CAAC,GAE5E;QACL,GAAG,OAAA;QACH,WAAW;IACb;AACF;AAEA,SAAS,mBAAmB,OAAA,EAAc;IACjC,OAAA,CAAC,QAAQ,IAAA,IAAQ,QAAQ,OAAA,IAAA,CAAY,QAAQ,OAAA,CAAQ,IAAA,IAAQ,QAAQ,OAAA,CAAQ,KAAA;AACtF;ACxDA,IAAA,OAAe,CAAC,SAAc,mBAAwB;IACpD,MAAM,WAAW,CAAC,CAAA;IAElB,OAAI,QAAQ,OAAA,IAAW,QAAQ,OAAA,CAAQ,SAAA,IAAA,CACrC,SAAS,IAAA,CACP,QACE,mEACA,SAAS,uBAAA,IAIb,QAAQ,OAAA,CAAQ,OAAA,GAAU,QAAQ,OAAA,CAAQ,SAAA,GAGrC;QACL,GAAG,OAAA;QACH,WAAW;IACb;AACF;ACLA,MAAM,eAAe;IACnB;IACA;IACA;IACA;IACA;IAAA,OACAC;IACA,UAAU;IACV;IACA;IACA;AACF,GAEM,iBAAiB,CAAC,iBAAwB,CAAC,YAAA,CAAoB;YACnE,MAAM,CAAA,sBAAA,EAAyB,eAAe,KAAK,CAAA,CAAA,CAAA;YACnD,GAAG,SAAA;YACH,WAAW,CAAA,CAAA;QACb,CAAA;AAEA,SAAS,QAAA,GAAW,QAAA,EAAe;IAC1B,OAAA,CAAC,YAAiB,iBAChB,SAAS,MAAA,CACd,CAAC,QAAa,YAAiB;YACvB,MAAA,MAAM,QAAQ,QAAQ,cAAc;YACnC,OAAA;gBACL,GAAG,GAAA;gBACH,WAAW,OAAO,SAAA,CAAU,MAAA,CAAO,IAAI,SAAS;YAClD;QACF,GACA;YAAC,WAAW,CAAC,CAAA;YAAG,GAAG,UAAA;QAAU;AAGnC;AAKO,SAAS,eAAe,WAAA,EAAsB;IACnD,OAAO,qBAAqB,aAAa,CAAC,WAAW,mBAAmB;QAChE,MAAA,cACH,aAAa,UAAU,IAAA,IAAS,YAAA,CAAqB,UAAU,IAAI,CAAA,IACpE,eAAe,cAAc;QAE/B,OAAI,eAAe,MAAA,GACV,QAAQ,UAAU,QAAQ,WAAW,EAAE,WAAW,cAAc,IAGlE,QAAQ,QAAQ,WAAW,EAAE,WAAW,cAAc;IAAA,CAC9D;AACH","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26],"debugId":null}},
    {"offset": {"line": 1362, "column": 0}, "map": {"version":3,"file":"index.mjs","sources":["file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/constants.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/any.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/utils.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/array.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/preview/deprecationUtils.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/preview/JSONStringifyHuman.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/preview/fallbackPrepare.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/preview/portableText.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/preview/guessPreviewConfig.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/preview/createPreviewGetter.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/blocks/defaults.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/blocks/block.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/blocks/span.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/preview/primitivePreview.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/boolean.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/crossDatasetReference.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/date.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/datetime.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/ordering/guessOrderingConfig.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/searchConfig/normalize.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/object.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/document.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/email.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/file.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/globalDocumentReference.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/image/fieldDefs.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/image.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/number.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/reference.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/string.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/text.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/types/url.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/legacy/Schema.ts","file:///Users/toma/Programming/Projects/sunarte/sunarte-tomagnet-multilang/node_modules/%40sanity/schema/src/_exports/index.ts"],"sourcesContent":["export const DEFAULT_OVERRIDEABLE_FIELDS = [\n  'jsonType',\n  'type',\n  'name',\n  'title',\n  'description',\n  'options',\n  'fieldsets',\n  'validation',\n  'readOnly',\n  'hidden',\n  'components',\n  'diffComponent',\n  'initialValue',\n  'deprecated',\n]\n","import {omit, pick} from 'lodash'\n\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst ANY_CORE = {\n  name: 'any',\n  type: null,\n  jsonType: 'any',\n}\n\nexport const AnyType = {\n  get() {\n    return ANY_CORE\n  },\n  extend(subTypeDef: any, extendMember: any) {\n    const parsed = Object.assign(pick(ANY_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: ANY_CORE,\n      of: subTypeDef.of.map((fieldDef: any) => {\n        return {\n          name: fieldDef.name,\n          type: extendMember(omit(fieldDef, 'name')),\n        }\n      }),\n    })\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          if (extensionDef.of) {\n            throw new Error('Cannot override `of` property of subtypes of \"array\"')\n          }\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","interface Config {\n  enumerable?: boolean\n  writable?: boolean\n}\nexport function lazyGetter(target: any, key: any, getter: any, config: Config = {}) {\n  Object.defineProperty(target, key, {\n    configurable: true,\n    enumerable: config.enumerable !== false,\n    get() {\n      const val = getter()\n      Object.defineProperty(target, key, {\n        value: val,\n        writable: Boolean(config.writable),\n        configurable: false,\n      })\n      return val\n    },\n  })\n  return target\n}\n\n//\n// const o = lazyGetter({}, 'expensive', function() {\n//   console.log('doing expensive calculations')\n//   return 'RESULT OF EXPENSIVE'\n// })\n//\n// console.log(o.expensive)\n// console.log(o.expensive)\n// console.log(o.expensive)\n","import {pick} from 'lodash'\n\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\nimport {lazyGetter} from './utils'\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst ARRAY_CORE = {\n  name: 'array',\n  type: null,\n  jsonType: 'array',\n  of: [],\n}\n\nexport const ArrayType = {\n  get() {\n    return ARRAY_CORE\n  },\n  extend(subTypeDef: any, createMemberType: any) {\n    const parsed = Object.assign(pick(ARRAY_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: ARRAY_CORE,\n    })\n    lazyGetter(parsed, 'of', () => {\n      return subTypeDef.of.map((ofTypeDef: any) => {\n        return createMemberType(ofTypeDef)\n      })\n    })\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          if (extensionDef.of) {\n            throw new Error('Cannot override `of` property of subtypes of \"array\"')\n          }\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","export function warnIfPreviewOnOptions(type: any) {\n  if (type.options && type.options.preview) {\n    // eslint-disable-next-line no-console\n    console.warn(`Heads up! The preview config is no longer defined on \"options\", but instead on the type/field itself.\nPlease move {options: {preview: ...}} to {..., preview: ...} on the type/field definition of \"${type.name}\".\n`)\n  }\n}\n\nexport function warnIfPreviewHasFields(type: any) {\n  const preview = type.preview || (type.options || {}).preview\n  if (preview && 'fields' in preview) {\n    // eslint-disable-next-line no-console\n    console.warn(`Heads up! \"preview.fields\" should be renamed to \"preview.select\". Please update the preview config for \"${type.name}\".\n`)\n  }\n}\n","import {pick} from 'lodash'\n\nfunction isEmpty(object: any) {\n  for (const key in object) {\n    if (object.hasOwnProperty(key)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction _stringify(value: any, options: any, depth: any): any {\n  if (depth > options.maxDepth) {\n    return '...'\n  }\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return '[empty]'\n    }\n    const capLength = Math.max(value.length - options.maxBreadth)\n    const asString: any = value\n      .slice(0, options.maxBreadth)\n      .map((item, index) => _stringify(item, options, depth + 1))\n      .concat(capLength > 0 ? `…+${capLength}` : [])\n      .join(', ')\n\n    return depth === 0 ? asString : `[${asString}]`\n  }\n  if (typeof value === 'object' && value !== null) {\n    const keys = Object.keys(value).filter(\n      (key) => !options.ignoreKeys.includes(key) && typeof value[key] !== 'undefined',\n    )\n\n    if (isEmpty(pick(value, keys))) {\n      return '{empty}'\n    }\n\n    const asString = keys\n      .slice(0, options.maxBreadth)\n      .map((key) => `${key}: ${_stringify(value[key], options, depth + 1)}`)\n      .join(', ')\n\n    return depth === 0 ? asString : `{${asString}}`\n  }\n  const asString = String(value)\n  return asString === '' ? '\"\"' : asString\n}\n\nexport default function stringify(\n  value: any,\n  options: {maxDepth?: number; maxBreadth?: number; ignoreKeys?: string[]} = {},\n) {\n  const opts = {\n    maxDepth: 'maxDepth' in options ? options.maxDepth : 2,\n    maxBreadth: 'maxBreadth' in options ? options.maxBreadth : 2,\n    ignoreKeys: 'ignoreKeys' in options ? options.ignoreKeys : [],\n  }\n  return _stringify(value, opts, 0)\n}\n","import {pick} from 'lodash'\n\nimport stringify from './JSONStringifyHuman'\n\nconst OPTIONS = {\n  maxEntries: 2,\n  maxDepth: 2,\n  maxBreadth: 2,\n  ignoreKeys: ['_id', '_type', '_key', '_ref'],\n}\n\nexport function createFallbackPrepare(fieldNames: any) {\n  return (value: any) => ({\n    title: stringify(pick(value, fieldNames), OPTIONS),\n  })\n}\n","type FieldDef = {\n  type: string\n  name: string\n  of?: {type: string}[]\n}\n\nexport function isBlockField(field: FieldDef): boolean {\n  return (\n    (field.type === 'array' && field.of && field.of.some((member) => member.type === 'block')) ||\n    false\n  )\n}\n","import arrify from 'arrify'\nimport {isUndefined, omitBy} from 'lodash'\n\nimport {createFallbackPrepare} from './fallbackPrepare'\nimport {isBlockField} from './portableText'\n\nconst TITLE_CANDIDATES = ['title', 'name', 'label', 'heading', 'header', 'caption']\nconst DESCRIPTION_CANDIDATES = ['description', ...TITLE_CANDIDATES]\n\nfunction fieldHasReferenceTo(fieldDef: any, refType: any) {\n  return arrify(fieldDef.to || []).some((memberTypeDef: any) => memberTypeDef.type === refType)\n}\n\nfunction isImageAssetField(fieldDef: any) {\n  return fieldHasReferenceTo(fieldDef, 'sanity.imageAsset')\n}\n\nfunction resolveImageAssetPath(typeDef: any) {\n  const fields = typeDef.fields || []\n  const imageAssetField = fields.find(isImageAssetField)\n  if (imageAssetField) {\n    return imageAssetField.name\n  }\n  const fieldWithImageAsset = fields.find((fieldDef: any) =>\n    (fieldDef.fields || []).some(isImageAssetField),\n  )\n\n  return fieldWithImageAsset ? `${fieldWithImageAsset.name}.asset` : undefined\n}\n\nfunction isFileAssetField(fieldDef: any) {\n  return fieldHasReferenceTo(fieldDef, 'sanity.fileAsset')\n}\n\nfunction resolveFileAssetPath(typeDef: any) {\n  const fields = typeDef.fields || []\n  const assetField = fields.find(isFileAssetField)\n  if (assetField) {\n    return assetField.name\n  }\n  const fieldWithFileAsset = fields.find((fieldDef: any) =>\n    (fieldDef.fields || []).some(isFileAssetField),\n  )\n  return fieldWithFileAsset ? `${fieldWithFileAsset.name}.asset` : undefined\n}\n\nexport default function guessPreviewFields(rawObjectTypeDef: any) {\n  const objectTypeDef = {fields: [], ...rawObjectTypeDef}\n\n  const stringFieldNames = objectTypeDef.fields\n    .filter((field: any) => field.type === 'string')\n    .map((field: any) => field.name)\n\n  const blockFieldNames = objectTypeDef.fields.filter(isBlockField).map((field: any) => field.name)\n\n  // Check if we have fields with names that is listed in candidate fields\n  let titleField = TITLE_CANDIDATES.find(\n    (candidate) => stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate),\n  )\n\n  let descField = DESCRIPTION_CANDIDATES.find(\n    (candidate) =>\n      candidate !== titleField &&\n      (stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate)),\n  )\n\n  if (!titleField) {\n    // Pick first defined string field\n    titleField = stringFieldNames[0] || blockFieldNames[0]\n    // Pick next as desc\n    descField = stringFieldNames[1] || blockFieldNames[1]\n  }\n\n  const mediaField = objectTypeDef.fields.find((field: any) => field.type === 'image')\n\n  const imageAssetPath = resolveImageAssetPath(objectTypeDef)\n\n  if (!titleField) {\n    const fileAssetPath = resolveFileAssetPath(objectTypeDef)\n    if (fileAssetPath) {\n      titleField = `${fileAssetPath}.originalFilename`\n    }\n    if (imageAssetPath) {\n      titleField = `${imageAssetPath}.originalFilename`\n    }\n  }\n\n  if (!titleField && !imageAssetPath) {\n    // last resort, pick all fields and concat them\n    const fieldNames = objectTypeDef.fields.map((field: any) => field.name)\n    const fieldMapping = fieldNames.reduce((acc: any, fieldName: any) => {\n      acc[fieldName] = fieldName\n      return acc\n    }, {})\n\n    return {\n      select: fieldMapping,\n      prepare: createFallbackPrepare(fieldNames),\n    }\n  }\n\n  const select = omitBy(\n    {\n      title: titleField,\n      description: descField,\n      media: mediaField ? mediaField.name : imageAssetPath,\n    },\n    isUndefined,\n  )\n\n  return {\n    select: select,\n  }\n}\n","import {pick} from 'lodash'\n\nimport {warnIfPreviewHasFields, warnIfPreviewOnOptions} from './deprecationUtils'\nimport guessPreviewConfig from './guessPreviewConfig'\n\nfunction parseSelection(selection: any) {\n  return selection.reduce((acc: any, field: any) => {\n    acc[field] = field\n    return acc\n  }, {})\n}\n\nfunction parsePreview(preview: any) {\n  if (!preview) {\n    return preview\n  }\n  const select = preview.select || preview.fields || {}\n  if (Array.isArray(select)) {\n    return {\n      ...pick(preview, ['prepare', 'component']),\n      select: parseSelection(select),\n    }\n  }\n  return {\n    ...pick(preview, ['prepare', 'component']),\n    select,\n  }\n}\n\nexport default function createPreviewGetter(objectTypeDef: any) {\n  return function previewGetter() {\n    warnIfPreviewOnOptions(objectTypeDef)\n    warnIfPreviewHasFields(objectTypeDef)\n    const preview = parsePreview(objectTypeDef.preview || (objectTypeDef.options || {}).preview)\n    return preview || guessPreviewConfig(objectTypeDef)\n  }\n}\n","export const DEFAULT_LINK_ANNOTATION = {\n  type: 'object',\n  name: 'link',\n  title: 'Link',\n  i18nTitleKey: 'inputs.portable-text.annotation.link',\n  options: {\n    modal: {type: 'popover'},\n  },\n  fields: [\n    {\n      name: 'href',\n      type: 'url',\n      title: 'Link',\n      description: 'A valid web, email, phone, or relative link.',\n      validation: (Rule: any) =>\n        Rule.uri({\n          scheme: ['http', 'https', 'tel', 'mailto'],\n          allowRelative: true,\n        }),\n    },\n  ],\n}\n\nexport const DEFAULT_TEXT_FIELD = {\n  type: 'text',\n  name: 'text',\n  title: 'Text',\n}\n\nexport const DEFAULT_MARKS_FIELD = {\n  name: 'marks',\n  type: 'array',\n  of: [{type: 'string'}],\n  title: 'Marks',\n}\n\nexport const LIST_TYPES = {\n  bullet: {\n    title: 'Bulleted list',\n    value: 'bullet',\n    i18nTitleKey: 'inputs.portable-text.list-type.bullet',\n  },\n  numbered: {\n    title: 'Numbered list',\n    value: 'number',\n    i18nTitleKey: 'inputs.portable-text.list-type.number',\n  },\n}\n\nexport const DEFAULT_LIST_TYPES = [LIST_TYPES.bullet, LIST_TYPES.numbered]\n\nexport const BLOCK_STYLES = {\n  normal: {title: 'Normal', value: 'normal', i18nTitleKey: 'inputs.portable-text.style.normal'},\n  h1: {title: 'Heading 1', value: 'h1', i18nTitleKey: 'inputs.portable-text.style.h1'},\n  h2: {title: 'Heading 2', value: 'h2', i18nTitleKey: 'inputs.portable-text.style.h2'},\n  h3: {title: 'Heading 3', value: 'h3', i18nTitleKey: 'inputs.portable-text.style.h3'},\n  h4: {title: 'Heading 4', value: 'h4', i18nTitleKey: 'inputs.portable-text.style.h4'},\n  h5: {title: 'Heading 5', value: 'h5', i18nTitleKey: 'inputs.portable-text.style.h5'},\n  h6: {title: 'Heading 6', value: 'h6', i18nTitleKey: 'inputs.portable-text.style.h6'},\n  blockquote: {\n    title: 'Quote',\n    value: 'blockquote',\n    i18nTitleKey: 'inputs.portable-text.style.quote',\n  },\n}\n\nexport const DEFAULT_BLOCK_STYLES = [\n  BLOCK_STYLES.normal,\n  BLOCK_STYLES.h1,\n  BLOCK_STYLES.h2,\n  BLOCK_STYLES.h3,\n  BLOCK_STYLES.h4,\n  BLOCK_STYLES.h5,\n  BLOCK_STYLES.h6,\n  BLOCK_STYLES.blockquote,\n]\n\nexport const DECORATOR_STRONG = {\n  title: 'Strong',\n  value: 'strong',\n  i18nTitleKey: 'inputs.portable-text.decorator.strong',\n}\nexport const DECORATOR_EMPHASIS = {\n  title: 'Italic',\n  value: 'em',\n  i18nTitleKey: 'inputs.portable-text.decorator.emphasis',\n}\nexport const DECORATOR_CODE = {\n  title: 'Code',\n  value: 'code',\n  i18nTitleKey: 'inputs.portable-text.decorator.code',\n}\nexport const DECORATOR_UNDERLINE = {\n  title: 'Underline',\n  value: 'underline',\n  i18nTitleKey: 'inputs.portable-text.decorator.underline',\n}\nexport const DECORATOR_STRIKE = {\n  title: 'Strike',\n  value: 'strike-through',\n  i18nTitleKey: 'inputs.portable-text.decorator.strike-through',\n}\n\nexport const DECORATORS = {\n  strong: DECORATOR_STRONG,\n  em: DECORATOR_EMPHASIS,\n  code: DECORATOR_CODE,\n  underline: DECORATOR_UNDERLINE,\n  strikeThrough: DECORATOR_STRIKE,\n}\n\nexport const DEFAULT_DECORATORS = [\n  DECORATORS.strong,\n  DECORATORS.em,\n  DECORATORS.code,\n  DECORATORS.underline,\n  DECORATORS.strikeThrough,\n]\n","import {pick} from 'lodash'\n\nimport createPreviewGetter from '../../preview/createPreviewGetter'\nimport {lazyGetter} from '../utils'\nimport {\n  BLOCK_STYLES,\n  DEFAULT_BLOCK_STYLES,\n  DEFAULT_DECORATORS,\n  DEFAULT_LINK_ANNOTATION,\n  DEFAULT_LIST_TYPES,\n  DEFAULT_MARKS_FIELD,\n  DEFAULT_TEXT_FIELD,\n} from './defaults'\n\nconst INHERITED_FIELDS = [\n  'type',\n  'name',\n  'title',\n  'jsonType',\n  'description',\n  'options',\n  'fieldsets',\n  'icon',\n]\n\nconst BLOCK_CORE = {\n  name: 'block',\n  title: 'Block',\n  type: null,\n  jsonType: 'object',\n}\n\nconst DEFAULT_OPTIONS = {}\n\nexport const BlockType = {\n  get() {\n    return BLOCK_CORE\n  },\n  extend(subTypeDef: any, extendMember: any) {\n    const options = {...(subTypeDef.options || DEFAULT_OPTIONS)}\n\n    const {marks, styles, lists, of, ...rest} = subTypeDef\n\n    const childrenField = createChildrenField(marks, of)\n    const styleField = createStyleField(styles)\n    const listItemField = createListItemField(lists)\n\n    const markDefsField = {\n      name: 'markDefs',\n      title: 'Mark definitions',\n      type: 'array',\n      of: marks?.annotations || DEFAULT_ANNOTATIONS,\n    }\n\n    const levelField = {\n      name: 'level',\n      title: 'Indentation',\n      type: 'number',\n    }\n\n    // NOTE: if you update this (EVEN THE ORDER OF FIELDS) you _NEED TO_ also\n    // update `BlockSchemaType`, `isBlockSchemaType` and similar in `@sanity/types`\n    const fields = [childrenField, styleField, listItemField, markDefsField, levelField].concat(\n      subTypeDef.fields || [],\n    )\n\n    const parsed = Object.assign(pick(BLOCK_CORE, INHERITED_FIELDS), rest, {\n      type: BLOCK_CORE,\n      options: options,\n    })\n\n    lazyGetter(parsed, 'fields', () => {\n      return fields.map((fieldDef) => {\n        const {name, ...type} = fieldDef\n        return {\n          name: name,\n          type: extendMember(type),\n        }\n      })\n    })\n\n    lazyGetter(parsed, 'preview', createPreviewGetter(subTypeDef))\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          if (extensionDef.fields) {\n            throw new Error('Cannot override `fields` of subtypes of \"block\"')\n          }\n          const current = Object.assign({}, parent, pick(extensionDef, INHERITED_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n\nfunction ensureNormalStyle(styles: any) {\n  return styles.some((style: any) => style.value === 'normal')\n    ? styles\n    : [BLOCK_STYLES.normal, ...styles]\n}\n\nfunction createStyleField(styles: any) {\n  return {\n    name: 'style',\n    title: 'Style',\n    type: 'string',\n    options: {\n      list: ensureNormalStyle(styles || DEFAULT_BLOCK_STYLES),\n    },\n  }\n}\n\nfunction createListItemField(lists: any) {\n  return {\n    name: 'listItem',\n    title: 'List type',\n    type: 'string',\n    options: {\n      list: lists || DEFAULT_LIST_TYPES,\n    },\n  }\n}\n\nconst DEFAULT_ANNOTATIONS = [DEFAULT_LINK_ANNOTATION]\n\nfunction createChildrenField(marks: any, of = []) {\n  return {\n    name: 'children',\n    title: 'Content',\n    type: 'array',\n    of: [\n      {\n        type: 'span',\n        fields: [DEFAULT_TEXT_FIELD, DEFAULT_MARKS_FIELD],\n        annotations: marks && marks.annotations ? marks.annotations : DEFAULT_ANNOTATIONS,\n        decorators: marks && marks.decorators ? marks.decorators : DEFAULT_DECORATORS,\n      },\n      ...of.filter((memberType: any) => memberType.type !== 'span'),\n    ],\n  }\n}\n","import {pick} from 'lodash'\n\nimport createPreviewGetter from '../../preview/createPreviewGetter'\nimport {lazyGetter} from '../utils'\n\nconst INHERITED_FIELDS = [\n  'type',\n  'name',\n  'title',\n  'jsonType',\n  'description',\n  'options',\n  'fieldsets',\n  'icon',\n]\n\nconst SPAN_CORE = {\n  name: 'span',\n  title: 'Span',\n  type: null,\n  jsonType: 'object',\n}\n\nconst MARKS_FIELD = {\n  name: 'marks',\n  title: 'Marks',\n  type: 'array',\n  of: [{type: 'string'}],\n}\n\nconst TEXT_FIELD = {\n  name: 'text',\n  title: 'Text',\n  type: 'string',\n}\n\nconst DEFAULT_OPTIONS = {}\n\nexport const SpanType = {\n  get() {\n    return SPAN_CORE\n  },\n  extend(subTypeDef: any, extendMember: any) {\n    const options = {...(subTypeDef.options || DEFAULT_OPTIONS)}\n\n    const {annotations = [], marks = []} = subTypeDef\n\n    // NOTE: if you update this please also update `SpanSchemaType` in`@sanity/types`\n    const fields = [MARKS_FIELD, TEXT_FIELD]\n\n    const parsed = Object.assign(pick(SPAN_CORE, INHERITED_FIELDS), subTypeDef, {\n      type: SPAN_CORE,\n      options: options,\n    })\n\n    lazyGetter(parsed, 'fields', () => {\n      return fields.map((fieldDef) => {\n        const {name, ...type} = fieldDef\n        return {\n          name: name,\n          type: extendMember(type),\n        }\n      })\n    })\n\n    lazyGetter(parsed, 'annotations', () => annotations.map(extendMember))\n    lazyGetter(parsed, 'marks', () => marks.map(extendMember))\n\n    lazyGetter(parsed, 'preview', createPreviewGetter(subTypeDef))\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          if (extensionDef.fields) {\n            throw new Error('Cannot override `fields` of subtypes of \"span\"')\n          }\n          const current = Object.assign({}, parent, pick(extensionDef, INHERITED_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","export default {\n  prepare: (val: any) => ({title: String(val)}),\n}\n","import {pick} from 'lodash'\n\nimport primitivePreview from '../preview/primitivePreview'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst BOOLEAN_CORE = {\n  name: 'boolean',\n  title: 'Boolean',\n  type: null,\n  jsonType: 'boolean',\n}\n\nexport const BooleanType = {\n  get() {\n    return BOOLEAN_CORE\n  },\n  extend(subTypeDef: any) {\n    const parsed = Object.assign(pick(BOOLEAN_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: BOOLEAN_CORE,\n      preview: primitivePreview,\n    })\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import arrify from 'arrify'\nimport {capitalize, pick} from 'lodash'\n\nimport {resolveSearchConfigForBaseFieldPaths} from '../searchConfig/resolve'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\nimport {lazyGetter} from './utils'\n\nexport const REF_FIELD = {\n  name: '_ref',\n  title: 'Referenced document ID',\n  type: 'string',\n}\n\nexport const WEAK_FIELD = {\n  name: '_weak',\n  title: 'Weak reference marker',\n  type: 'boolean',\n}\n\nconst DATASET_FIELD = {\n  name: '_dataset',\n  title: 'Target dataset',\n  type: 'string',\n}\n\nconst PROJECT_ID_FIELD = {\n  name: '_projectId',\n  title: 'Target project ID',\n  type: 'string',\n  hidden: true,\n}\n\nconst REFERENCE_FIELDS = [REF_FIELD, WEAK_FIELD, DATASET_FIELD, PROJECT_ID_FIELD]\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst CROSS_DATASET_REFERENCE_CORE = {\n  name: 'crossDatasetReference',\n  type: null,\n  jsonType: 'object',\n}\n\nfunction humanize(arr: any, conjunction: any) {\n  const len = arr.length\n  if (len === 1) {\n    return arr[0]\n  }\n  const first = arr.slice(0, len - 1)\n  const last = arr[len - 1]\n  return `${first.join(', ')} ${conjunction} ${last}`\n}\n\nfunction buildTitle(type: any) {\n  if (!type.to || type.to.length === 0) {\n    return 'Cross dataset Reference'\n  }\n  return `Cross dataset reference to ${humanize(\n    arrify(type.to).map((toType: any) => toType.title || capitalize(toType.type)),\n    'or',\n  ).toLowerCase()}`\n}\n\nexport const CrossDatasetReferenceType = {\n  get() {\n    return CROSS_DATASET_REFERENCE_CORE\n  },\n  extend(subTypeDef: any, createMemberType: any) {\n    if (!subTypeDef.to) {\n      throw new Error(\n        `Missing \"to\" field in cross dataset reference definition. Check the type ${subTypeDef.name}`,\n      )\n    }\n    const parsed = Object.assign(\n      pick(CROSS_DATASET_REFERENCE_CORE, OVERRIDABLE_FIELDS),\n      subTypeDef,\n      {\n        type: CROSS_DATASET_REFERENCE_CORE,\n      },\n    )\n\n    lazyGetter(parsed, 'fields', () => {\n      return REFERENCE_FIELDS.map((fieldDef) => {\n        const {name, ...type} = fieldDef\n        return {\n          name: name,\n          type: createMemberType(type),\n        }\n      })\n    })\n\n    lazyGetter(parsed, 'to', () => {\n      return arrify(subTypeDef.to).map((toType: any) => {\n        return {\n          ...toType,\n          // eslint-disable-next-line camelcase\n          __experimental_search: resolveSearchConfigForBaseFieldPaths(toType),\n        }\n      })\n    })\n\n    lazyGetter(parsed, 'title', () => subTypeDef.title || buildTitle(parsed))\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          if (extensionDef.of) {\n            throw new Error('Cannot override `of` of subtypes of \"reference\"')\n          }\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import {pick} from 'lodash'\n\nimport primitivePreview from '../preview/primitivePreview'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst DATE_CORE = {\n  name: 'date',\n  title: 'Datetime',\n  type: null,\n  jsonType: 'string',\n}\n\nexport const DateType = {\n  get() {\n    return DATE_CORE\n  },\n  extend(subTypeDef: any) {\n    const parsed = Object.assign(pick(DATE_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: DATE_CORE,\n      preview: primitivePreview,\n    })\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import {pick} from 'lodash'\n\nimport primitivePreview from '../preview/primitivePreview'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst DATETIME_CORE = {\n  name: 'datetime',\n  title: 'Datetime',\n  type: null,\n  jsonType: 'string',\n}\n\nexport const DateTimeType = {\n  get() {\n    return DATETIME_CORE\n  },\n  extend(subTypeDef: any) {\n    const parsed = Object.assign(pick(DATETIME_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: DATETIME_CORE,\n      preview: primitivePreview,\n    })\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import {type SortOrdering} from '@sanity/types'\nimport {capitalize, startCase} from 'lodash'\n\nconst CANDIDATES = ['title', 'name', 'label', 'heading', 'header', 'caption', 'description']\n\nconst PRIMITIVES = ['string', 'boolean', 'number']\n\nconst isPrimitive = (field: any) => PRIMITIVES.includes(field.type)\n\nexport default function guessOrderingConfig(objectTypeDef: any): SortOrdering[] {\n  let candidates = CANDIDATES.filter((candidate) =>\n    objectTypeDef.fields.some((field: any) => isPrimitive(field) && field.name === candidate),\n  )\n\n  // None of the candidates were found, fallback to all fields\n  if (candidates.length === 0) {\n    candidates = objectTypeDef.fields.filter(isPrimitive).map((field: any) => field.name)\n  }\n\n  return candidates.map(\n    (name): SortOrdering => ({\n      name: name,\n      i18n: {\n        title: {key: `default-orderings.${name}`, ns: 'studio'},\n      },\n      title: capitalize(startCase(name)),\n      by: [{field: name, direction: 'asc'}],\n    }),\n  )\n}\n","import {isPlainObject, toPath} from 'lodash'\n\nexport function normalizeSearchConfigs(configs: any) {\n  if (!Array.isArray(configs)) {\n    throw new Error(\n      'The search config of a document type must be an array of search config objects',\n    )\n  }\n  return configs.map((conf) => {\n    if (conf === 'defaults') {\n      return conf\n    }\n    if (!isPlainObject(conf)) {\n      throw new Error('Search config must be an object of {path: string, weight: number}')\n    }\n    return {\n      weight: 'weight' in conf ? conf.weight : 1,\n      path: toPath(conf.path),\n      mapWith: typeof conf.mapWith === 'string' ? conf.mapWith : undefined,\n    }\n  })\n}\n","import {\n  type FieldGroup,\n  type FieldGroupDefinition,\n  type Fieldset,\n  type FieldsetDefinition,\n  type ObjectDefinition,\n  type ObjectField,\n} from '@sanity/types'\nimport {castArray, flatMap, pick, startCase} from 'lodash'\n\nimport guessOrderingConfig from '../ordering/guessOrderingConfig'\nimport createPreviewGetter from '../preview/createPreviewGetter'\nimport {normalizeSearchConfigs} from '../searchConfig/normalize'\nimport {resolveSearchConfig} from '../searchConfig/resolve'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\nimport {lazyGetter} from './utils'\n\nconst OVERRIDABLE_FIELDS = [\n  ...DEFAULT_OVERRIDEABLE_FIELDS,\n  'orderings',\n  '__experimental_search',\n  'blockEditor',\n  'icon',\n]\n\nexport const ObjectType = {\n  get() {\n    return {\n      name: 'object',\n      title: 'Object',\n      type: null,\n      jsonType: 'object',\n    }\n  },\n  extend(rawSubTypeDef: any, createMemberType: any) {\n    const subTypeDef = {fields: [], ...rawSubTypeDef}\n\n    const options = {...(subTypeDef.options || {})}\n    const parsed = Object.assign(pick(this.get(), OVERRIDABLE_FIELDS), subTypeDef, {\n      type: this.get(),\n      title: subTypeDef.title || (subTypeDef.name ? startCase(subTypeDef.name) : 'Object'),\n      options: options,\n      orderings: subTypeDef.orderings || guessOrderingConfig(subTypeDef),\n      fields: subTypeDef.fields.map((fieldDef: any) => {\n        const {name, fieldset, group, ...rest} = fieldDef\n\n        const compiledField = {\n          name,\n          group,\n          fieldset,\n        }\n\n        return lazyGetter(compiledField, 'type', () => {\n          return createMemberType({\n            ...rest,\n            title: fieldDef.title || startCase(name),\n          })\n        })\n      }),\n    })\n\n    lazyGetter(parsed, 'fieldsets', () => {\n      return createFieldsets(subTypeDef, parsed.fields)\n    })\n\n    lazyGetter(parsed, 'groups', () => {\n      return createFieldsGroups(subTypeDef, parsed.fields)\n    })\n\n    lazyGetter(parsed, 'preview', createPreviewGetter(subTypeDef))\n\n    lazyGetter(\n      parsed,\n      '__experimental_search',\n      () => {\n        const userProvidedSearchConfig = subTypeDef.__experimental_search\n          ? normalizeSearchConfigs(subTypeDef.__experimental_search)\n          : null\n\n        if (userProvidedSearchConfig) {\n          return userProvidedSearchConfig.map((entry) =>\n            entry === 'defaults' ? normalizeSearchConfigs(subTypeDef) : entry,\n          )\n        }\n        return resolveSearchConfig(parsed)\n      },\n      {\n        enumerable: false,\n      },\n    )\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          if (extensionDef.fields) {\n            throw new Error('Cannot override `fields` of subtypes of \"object\"')\n          }\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            title:\n              extensionDef.title ||\n              subTypeDef.title ||\n              (subTypeDef.name ? startCase(subTypeDef.name) : 'Object'),\n            type: parent,\n          })\n          lazyGetter(current, '__experimental_search', () => parent.__experimental_search)\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n\nexport function createFieldsets(typeDef: ObjectDefinition, fields: ObjectField[]): Fieldset[] {\n  const fieldsetsByName: Record<string, FieldsetDefinition & {fields: ObjectField[]}> = {}\n\n  for (const fieldset of typeDef.fieldsets || []) {\n    if (fieldsetsByName[fieldset.name]) {\n      throw new Error(\n        `Duplicate fieldset name \"${fieldset.name}\" found for type '${\n          typeDef.title ? typeDef.title : startCase(typeDef.name)\n        }'`,\n      )\n    }\n\n    fieldsetsByName[fieldset.name] = {title: startCase(fieldset.name), ...fieldset, fields: []}\n  }\n\n  const fieldsets = new Set<Fieldset>()\n\n  for (const field of fields) {\n    if (!field.fieldset) {\n      fieldsets.add({single: true, field})\n      continue\n    }\n\n    const fieldset = fieldsetsByName[field.fieldset]\n    if (!fieldset) {\n      throw new Error(\n        `Fieldset '${field.fieldset}' is not defined in schema for type '${typeDef.name}'`,\n      )\n    }\n\n    fieldset.fields.push(field)\n\n    // The Set will prevent duplicates\n    fieldsets.add(fieldset)\n  }\n\n  return Array.from(fieldsets)\n}\n\nfunction createFieldsGroups(typeDef: ObjectDefinition, fields: ObjectField[]): FieldGroup[] {\n  const groupsByName: Record<string, FieldGroupDefinition & {fields: ObjectField[]}> = {}\n\n  let numDefaultGroups = 0\n  for (const group of typeDef.groups || []) {\n    if (groupsByName[group.name]) {\n      throw new Error(\n        `Duplicate group name \"${group.name}\" found for type '${\n          typeDef.title ? typeDef.title : startCase(typeDef.name)\n        }'`,\n      )\n    }\n\n    groupsByName[group.name] = {title: startCase(group.name), ...group, fields: []}\n\n    if (group.default && ++numDefaultGroups > 1) {\n      // Throw if you have multiple default field groups defined\n      throw new Error(\n        `More than one field group defined as default for type '${\n          typeDef.title ? typeDef.title : startCase(typeDef.name)\n        }' - only 1 is supported`,\n      )\n    }\n  }\n\n  fields.forEach((field) => {\n    const fieldGroupNames = castArray(field.group || [])\n    if (fieldGroupNames.length === 0) {\n      return\n    }\n\n    fieldGroupNames.forEach((fieldGroupName) => {\n      const currentGroup = groupsByName[fieldGroupName]\n\n      if (!currentGroup) {\n        throw new Error(\n          `Field group '${fieldGroupName}' is not defined in schema for type '${\n            typeDef.title ? typeDef.name : startCase(typeDef.name)\n          }'`,\n        )\n      }\n\n      currentGroup.fields.push(field)\n    })\n  })\n\n  return flatMap(groupsByName).filter((group) => group.fields.length > 0)\n}\n","import {ObjectType} from './object'\n\nconst DOCUMENT_CORE = {\n  name: 'document',\n  title: 'Document',\n  type: null,\n  jsonType: 'object',\n}\n\nexport const DocumentType = {\n  get() {\n    return DOCUMENT_CORE\n  },\n  extend: ObjectType.extend,\n}\n","import {pick} from 'lodash'\n\nimport primitivePreview from '../preview/primitivePreview'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst EMAIL_CORE = {\n  name: 'email',\n  title: 'Email',\n  type: null,\n  jsonType: 'string',\n}\n\nexport const EmailType = {\n  get() {\n    return EMAIL_CORE\n  },\n  extend(subTypeDef: any) {\n    const parsed = Object.assign(pick(EMAIL_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: EMAIL_CORE,\n      preview: primitivePreview,\n    })\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import {pick, startCase} from 'lodash'\n\nimport createPreviewGetter from '../preview/createPreviewGetter'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\nimport {createFieldsets} from './object'\nimport {lazyGetter} from './utils'\n\nexport const ASSET_FIELD = {\n  name: 'asset',\n  type: 'reference',\n  to: {type: 'sanity.fileAsset'},\n}\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst FILE_CORE = {\n  name: 'file',\n  title: 'File',\n  type: null,\n  jsonType: 'object',\n}\n\nconst DEFAULT_OPTIONS = {\n  accept: '',\n}\n\nexport const FileType = {\n  get() {\n    return FILE_CORE\n  },\n  extend(rawSubTypeDef: any, createMemberType: any) {\n    const options = {...(rawSubTypeDef.options || DEFAULT_OPTIONS)}\n\n    const fields = [ASSET_FIELD, ...(rawSubTypeDef.fields || [])]\n\n    const subTypeDef = {...rawSubTypeDef, fields}\n\n    const parsed = Object.assign(pick(FILE_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: FILE_CORE,\n      title: subTypeDef.title || (subTypeDef.name ? startCase(subTypeDef.name) : FILE_CORE.title),\n      options: options,\n      fields: subTypeDef.fields.map((fieldDef: any) => {\n        const {name, fieldset, ...rest} = fieldDef\n\n        const compiledField = {\n          name,\n          fieldset,\n          isCustomized: Boolean(rawSubTypeDef.fields),\n        }\n\n        return lazyGetter(compiledField, 'type', () => {\n          return createMemberType({\n            ...rest,\n            title: fieldDef.title || startCase(name),\n          })\n        })\n      }),\n    })\n\n    lazyGetter(parsed, 'fieldsets', () => {\n      return createFieldsets(subTypeDef, parsed.fields)\n    })\n\n    lazyGetter(parsed, 'preview', createPreviewGetter(Object.assign({}, subTypeDef, {fields})))\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          if (extensionDef.fields) {\n            throw new Error('Cannot override `fields` of subtypes of \"file\"')\n          }\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import arrify from 'arrify'\nimport {pick} from 'lodash'\n\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\nimport {lazyGetter} from './utils'\n\nexport const REF_FIELD = {\n  name: '_ref',\n  title: 'Referenced document ID',\n  type: 'string',\n}\n\nexport const WEAK_FIELD = {\n  name: '_weak',\n  title: 'Weak reference',\n  type: 'boolean',\n}\n\nconst REFERENCE_FIELDS = [REF_FIELD, WEAK_FIELD]\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst GLOBAL_DOCUMENT_REFERENCE_CORE = {\n  name: 'globalDocumentReference',\n  title: 'Global Document Reference',\n  type: null,\n  jsonType: 'object',\n}\n\nfunction humanize(arr: any, conjunction: any) {\n  const len = arr.length\n  if (len === 1) {\n    return arr[0]\n  }\n  const first = arr.slice(0, len - 1)\n  const last = arr[len - 1]\n  return `${first.join(', ')} ${conjunction} ${last}`\n}\n\nfunction buildTitle(type: any) {\n  if (!type.to || type.to.length === 0) {\n    return 'Global Document Reference'\n  }\n  return `Global Document Reference to ${humanize(\n    arrify(type.to).map((toType: any) => toType.title),\n    'or',\n  ).toLowerCase()}`\n}\n\nexport const GlobalDocumentReferenceType = {\n  get() {\n    return GLOBAL_DOCUMENT_REFERENCE_CORE\n  },\n  extend(subTypeDef: any, createMemberType: any) {\n    if (!subTypeDef.to) {\n      throw new Error(\n        `Missing \"to\" field in global document reference definition. Check the type ${subTypeDef.name}`,\n      )\n    }\n    const parsed = Object.assign(\n      pick(GLOBAL_DOCUMENT_REFERENCE_CORE, OVERRIDABLE_FIELDS),\n      subTypeDef,\n      {\n        type: GLOBAL_DOCUMENT_REFERENCE_CORE,\n      },\n    )\n\n    lazyGetter(parsed, 'fields', () => {\n      return REFERENCE_FIELDS.map((fieldDef) => {\n        const {name, ...type} = fieldDef\n        return {\n          name: name,\n          type: createMemberType(type),\n        }\n      })\n    })\n\n    lazyGetter(parsed, 'to', () => {\n      return arrify(subTypeDef.to).map((toType: any) => {\n        return {\n          ...toType,\n        }\n      })\n    })\n\n    lazyGetter(parsed, 'title', () => subTypeDef.title || buildTitle(parsed))\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          if (extensionDef.of) {\n            throw new Error('Cannot override `of` of subtypes of \"globalDocumentReference\"')\n          }\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","export const ASSET_FIELD = {\n  name: 'asset',\n  type: 'reference',\n  to: [{type: 'sanity.imageAsset'}],\n}\n\nexport const HOTSPOT_FIELD = {\n  name: 'hotspot',\n  type: 'sanity.imageHotspot',\n}\n\nexport const CROP_FIELD = {\n  name: 'crop',\n  type: 'sanity.imageCrop',\n}\n","import {pick, startCase} from 'lodash'\n\nimport createPreviewGetter from '../preview/createPreviewGetter'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\nimport {ASSET_FIELD, CROP_FIELD, HOTSPOT_FIELD} from './image/fieldDefs'\nimport {createFieldsets} from './object'\nimport {lazyGetter} from './utils'\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst IMAGE_CORE = {\n  name: 'image',\n  title: 'Image',\n  type: null,\n  jsonType: 'object',\n}\n\nconst DEFAULT_OPTIONS = {}\n\nexport const ImageType = {\n  get() {\n    return IMAGE_CORE\n  },\n  extend(rawSubTypeDef: any, createMemberType: any) {\n    const options = {...(rawSubTypeDef.options || DEFAULT_OPTIONS)}\n\n    let hotspotFields = [HOTSPOT_FIELD, CROP_FIELD]\n    if (!options.hotspot) {\n      hotspotFields = hotspotFields.map((field) => ({...field, hidden: true}))\n    }\n\n    const fields = [ASSET_FIELD, ...hotspotFields, ...(rawSubTypeDef.fields || [])]\n    const subTypeDef = {...rawSubTypeDef, fields}\n\n    const parsed = Object.assign(pick(this.get(), OVERRIDABLE_FIELDS), subTypeDef, {\n      type: IMAGE_CORE,\n      title: subTypeDef.title || (subTypeDef.name ? startCase(subTypeDef.name) : IMAGE_CORE.title),\n      options: options,\n      fields: subTypeDef.fields.map((fieldDef: any) => {\n        const {name, fieldset, ...rest} = fieldDef\n\n        const compiledField = {\n          name,\n          fieldset,\n          isCustomized: Boolean(rawSubTypeDef.fields),\n        }\n\n        return lazyGetter(compiledField, 'type', () => {\n          return createMemberType({\n            ...rest,\n            title: fieldDef.title || startCase(name),\n          })\n        })\n      }),\n    })\n\n    lazyGetter(parsed, 'fieldsets', () => {\n      return createFieldsets(subTypeDef, parsed.fields)\n    })\n\n    lazyGetter(parsed, 'preview', createPreviewGetter(Object.assign({}, subTypeDef, {fields})))\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          if (extensionDef.fields) {\n            throw new Error('Cannot override `fields` of subtypes of \"image\"')\n          }\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import {pick} from 'lodash'\n\nimport primitivePreview from '../preview/primitivePreview'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst NUMBER_CORE = {\n  name: 'number',\n  title: 'Number',\n  type: null,\n  jsonType: 'number',\n}\n\nexport const NumberType = {\n  get() {\n    return NUMBER_CORE\n  },\n  extend(subTypeDef: any) {\n    const parsed = Object.assign(pick(NUMBER_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: NUMBER_CORE,\n      preview: primitivePreview,\n    })\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import arrify from 'arrify'\nimport {pick} from 'lodash'\n\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\nimport {createFieldsets} from './object'\nimport {lazyGetter} from './utils'\n\nexport const REF_FIELD = {\n  name: '_ref',\n  title: 'Referenced document ID',\n  type: 'string',\n}\n\nexport const WEAK_FIELD = {\n  name: '_weak',\n  title: 'Weak reference',\n  type: 'boolean',\n}\n\nconst REFERENCE_FIELDS = [REF_FIELD, WEAK_FIELD]\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst REFERENCE_CORE = {\n  name: 'reference',\n  title: 'Reference',\n  type: null,\n  jsonType: 'object',\n}\n\nfunction humanize(arr: any, conjunction: any) {\n  const len = arr.length\n  if (len === 1) {\n    return arr[0]\n  }\n  const first = arr.slice(0, len - 1)\n  const last = arr[len - 1]\n  return `${first.join(', ')} ${conjunction} ${last}`\n}\n\nfunction buildTitle(type: any) {\n  if (!type.to || type.to.length === 0) {\n    return 'Reference'\n  }\n  return `Reference to ${humanize(\n    arrify(type.to).map((toType: any) => toType.title),\n    'or',\n  ).toLowerCase()}`\n}\n\nexport const ReferenceType = {\n  get() {\n    return REFERENCE_CORE\n  },\n  extend(subTypeDef: any, createMemberType: any) {\n    if (!subTypeDef.to) {\n      throw new Error(\n        `Missing \"to\" field in reference definition. Check the type ${subTypeDef.name}`,\n      )\n    }\n    const parsed = Object.assign(pick(REFERENCE_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: REFERENCE_CORE,\n    })\n\n    lazyGetter(parsed, 'fields', () => {\n      return REFERENCE_FIELDS.map((fieldDef) => {\n        const {name, ...type} = fieldDef\n        return {\n          name: name,\n          type: createMemberType(type),\n        }\n      })\n    })\n\n    lazyGetter(parsed, 'fieldsets', () => {\n      return createFieldsets(subTypeDef, parsed.fields)\n    })\n\n    lazyGetter(parsed, 'to', () => {\n      return arrify(subTypeDef.to).map((toType: any) => createMemberType(toType))\n    })\n\n    lazyGetter(parsed, 'title', () => subTypeDef.title || buildTitle(parsed))\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          if (extensionDef.of) {\n            throw new Error('Cannot override `of` of subtypes of \"reference\"')\n          }\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import {pick} from 'lodash'\n\nimport primitivePreview from '../preview/primitivePreview'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst STRING_CORE = {\n  name: 'string',\n  title: 'String',\n  type: null,\n  jsonType: 'string',\n}\n\nexport const StringType = {\n  get() {\n    return STRING_CORE\n  },\n  extend(subTypeDef: any) {\n    const parsed = Object.assign(pick(STRING_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: STRING_CORE,\n      preview: primitivePreview,\n    })\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import {pick} from 'lodash'\n\nimport primitivePreview from '../preview/primitivePreview'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS, 'rows']\n\nconst TEXT_CORE = {\n  name: 'text',\n  title: 'Text',\n  type: null,\n  jsonType: 'string',\n}\n\nexport const TextType = {\n  get() {\n    return TEXT_CORE\n  },\n  extend(subTypeDef: any) {\n    const parsed = Object.assign(pick(TEXT_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: TEXT_CORE,\n      preview: primitivePreview,\n    })\n\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import {pick} from 'lodash'\n\nimport primitivePreview from '../preview/primitivePreview'\nimport {DEFAULT_OVERRIDEABLE_FIELDS} from './constants'\n\nconst OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS]\n\nconst URL_CORE = {\n  name: 'url',\n  title: 'Url',\n  type: null,\n  jsonType: 'string',\n}\n\nexport const UrlType = {\n  get() {\n    return URL_CORE\n  },\n  extend(subTypeDef: any) {\n    const parsed = Object.assign(pick(URL_CORE, OVERRIDABLE_FIELDS), subTypeDef, {\n      type: URL_CORE,\n      preview: primitivePreview,\n    })\n    return subtype(parsed)\n\n    function subtype(parent: any) {\n      return {\n        get() {\n          return parent\n        },\n        extend: (extensionDef: any) => {\n          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {\n            type: parent,\n          })\n          return subtype(current)\n        },\n      }\n    }\n  },\n}\n","import * as types from './types'\n\nfunction compileRegistry(schemaDef: any) {\n  const registry = Object.assign(Object.create(null), types)\n\n  const defsByName = schemaDef.types.reduce((acc: any, def: any) => {\n    if (acc[def.name]) {\n      throw new Error(`Duplicate type name added to schema: ${def.name}`)\n    }\n    acc[def.name] = def\n    return acc\n  }, {})\n\n  schemaDef.types.forEach(add)\n\n  return registry\n\n  function ensure(typeName: any) {\n    if (!registry[typeName]) {\n      if (!defsByName[typeName]) {\n        throw new Error(`Unknown type: ${typeName}`)\n      }\n      add(defsByName[typeName])\n    }\n  }\n\n  function extendMember(memberDef: any) {\n    ensure(memberDef.type)\n    return registry[memberDef.type].extend(memberDef, extendMember).get()\n  }\n\n  function add(typeDef: any) {\n    ensure(typeDef.type)\n    if (registry[typeDef.name]) {\n      return\n    }\n    registry[typeDef.name] = registry[typeDef.type].extend(typeDef, extendMember)\n  }\n}\n\n/**\n * @beta\n */\nexport class Schema {\n  _original: {name: string; types: any[]}\n  _registry: {[typeName: string]: any}\n\n  static compile(schemaDef: any): Schema {\n    return new Schema(schemaDef)\n  }\n\n  constructor(schemaDef: any) {\n    this._original = schemaDef\n    this._registry = compileRegistry(schemaDef)\n  }\n\n  get name(): string {\n    return this._original.name\n  }\n\n  get(name: string): any {\n    return this._registry[name] && this._registry[name].get()\n  }\n\n  has(name: string): boolean {\n    return name in this._registry\n  }\n\n  getTypeNames(): string[] {\n    return Object.keys(this._registry)\n  }\n}\n\n/**\n * @deprecated Use `import {Schema} from \"@sanity/schema\"` instead\n */\nexport class DeprecatedDefaultSchema extends Schema {\n  static compile(schemaDef: any): Schema {\n    return new DeprecatedDefaultSchema(schemaDef)\n  }\n\n  constructor(schemaDef: any) {\n    super(schemaDef)\n\n    const stack = new Error(\n      'The default export of `@sanity/schema` is deprecated. Use `import {Schema} from \"@sanity/schema\"` instead.',\n    ).stack!.replace(/^Error/, 'Warning')\n\n    // eslint-disable-next-line no-console\n    console.warn(stack)\n  }\n}\n","import {DeprecatedDefaultSchema, Schema as NamedSchema} from '../legacy/Schema'\n\nexport default DeprecatedDefaultSchema\nexport const Schema = NamedSchema\nexport {type SchemaValidationResult} from '../sanity/typedefs'\n"],"names":["OVERRIDABLE_FIELDS","asString","guessPreviewConfig","INHERITED_FIELDS","DEFAULT_OPTIONS","REF_FIELD","WEAK_FIELD","REFERENCE_FIELDS","humanize","buildTitle","ASSET_FIELD","Schema","NamedSchema"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33],"debugId":null}}]
}