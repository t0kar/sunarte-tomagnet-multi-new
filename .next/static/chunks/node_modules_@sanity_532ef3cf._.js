(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@sanity_532ef3cf._.js", {

"[project]/node_modules/@sanity/types/lib/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "defineArrayMember": (()=>defineArrayMember),
    "defineField": (()=>defineField),
    "defineType": (()=>defineType),
    "isArrayOfBlocksSchemaType": (()=>isArrayOfBlocksSchemaType),
    "isArrayOfObjectsSchemaType": (()=>isArrayOfObjectsSchemaType),
    "isArrayOfPrimitivesSchemaType": (()=>isArrayOfPrimitivesSchemaType),
    "isArraySchemaType": (()=>isArraySchemaType),
    "isBlockChildrenObjectField": (()=>isBlockChildrenObjectField),
    "isBlockListObjectField": (()=>isBlockListObjectField),
    "isBlockSchemaType": (()=>isBlockSchemaType),
    "isBlockStyleObjectField": (()=>isBlockStyleObjectField),
    "isBooleanSchemaType": (()=>isBooleanSchemaType),
    "isCreateIfNotExistsMutation": (()=>isCreateIfNotExistsMutation),
    "isCreateMutation": (()=>isCreateMutation),
    "isCreateOrReplaceMutation": (()=>isCreateOrReplaceMutation),
    "isCreateSquashedMutation": (()=>isCreateSquashedMutation),
    "isCrossDatasetReference": (()=>isCrossDatasetReference),
    "isCrossDatasetReferenceSchemaType": (()=>isCrossDatasetReferenceSchemaType),
    "isDeleteMutation": (()=>isDeleteMutation),
    "isDeprecatedSchemaType": (()=>isDeprecatedSchemaType),
    "isDeprecationConfiguration": (()=>isDeprecationConfiguration),
    "isDocumentSchemaType": (()=>isDocumentSchemaType),
    "isFileSchemaType": (()=>isFileSchemaType),
    "isGlobalDocumentReference": (()=>isGlobalDocumentReference),
    "isImage": (()=>isImage),
    "isImageSchemaType": (()=>isImageSchemaType),
    "isIndexSegment": (()=>isIndexSegment),
    "isIndexTuple": (()=>isIndexTuple),
    "isKeySegment": (()=>isKeySegment),
    "isKeyedObject": (()=>isKeyedObject),
    "isNumberSchemaType": (()=>isNumberSchemaType),
    "isObjectSchemaType": (()=>isObjectSchemaType),
    "isPatchMutation": (()=>isPatchMutation),
    "isPortableTextListBlock": (()=>isPortableTextListBlock),
    "isPortableTextSpan": (()=>isPortableTextSpan),
    "isPortableTextTextBlock": (()=>isPortableTextTextBlock),
    "isPrimitiveSchemaType": (()=>isPrimitiveSchemaType),
    "isReference": (()=>isReference),
    "isReferenceSchemaType": (()=>isReferenceSchemaType),
    "isSanityDocument": (()=>isSanityDocument),
    "isSearchStrategy": (()=>isSearchStrategy),
    "isSlug": (()=>isSlug),
    "isSpanSchemaType": (()=>isSpanSchemaType),
    "isStringSchemaType": (()=>isStringSchemaType),
    "isTitledListValue": (()=>isTitledListValue),
    "isTypedObject": (()=>isTypedObject),
    "isValidationError": (()=>isValidationError),
    "isValidationErrorMarker": (()=>isValidationErrorMarker),
    "isValidationInfo": (()=>isValidationInfo),
    "isValidationInfoMarker": (()=>isValidationInfoMarker),
    "isValidationWarning": (()=>isValidationWarning),
    "isValidationWarningMarker": (()=>isValidationWarningMarker),
    "searchStrategies": (()=>searchStrategies),
    "typed": (()=>typed)
});
function isObject(obj) {
    return typeof obj == "object" && obj !== null && !Array.isArray(obj);
}
function isReference(reference) {
    return isObject(reference) && typeof reference._ref == "string";
}
function isImage(value) {
    return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith("image-");
}
function isCrossDatasetReference(reference) {
    return isObject(reference) && typeof reference._ref == "string" && typeof reference._dataset == "string" && typeof reference._projectId == "string";
}
function isSanityDocument(document) {
    return isObject(document) && typeof document._id == "string" && typeof document._type == "string";
}
function isTypedObject(obj) {
    return isObject(obj) && typeof obj._type == "string";
}
function isKeyedObject(obj) {
    return isObject(obj) && typeof obj._key == "string";
}
function isGlobalDocumentReference(reference) {
    return !isObject(reference) || typeof reference._ref != "string" ? !1 : reference._ref.split(":").length === 3;
}
function isValidationErrorMarker(marker) {
    return marker.level === "error";
}
function isValidationWarningMarker(marker) {
    return marker.level === "warning";
}
function isValidationInfoMarker(marker) {
    return marker.level === "info";
}
function isCreateMutation(mutation) {
    return "create" in mutation;
}
function isCreateIfNotExistsMutation(mutation) {
    return "createIfNotExists" in mutation;
}
function isCreateOrReplaceMutation(mutation) {
    return "createOrReplace" in mutation;
}
function isDeleteMutation(mutation) {
    return "delete" in mutation;
}
function isPatchMutation(mutation) {
    return "patch" in mutation;
}
const reKeySegment = /_key\s*==\s*['"](.*)['"]/, reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment == "number" || typeof segment == "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
    return typeof segment == "string" ? reKeySegment.test(segment.trim()) : typeof segment == "object" && "_key" in segment;
}
function isIndexTuple(segment) {
    if (typeof segment == "string" && reIndexTuple.test(segment)) return !0;
    if (!Array.isArray(segment) || segment.length !== 2) return !1;
    const [from, to] = segment;
    return (typeof from == "number" || from === "") && (typeof to == "number" || to === "");
}
function isRecord$1(value) {
    return !!value && (typeof value == "object" || typeof value == "function");
}
function isPortableTextTextBlock(value) {
    return isRecord$1(value) && typeof value._type == "string" && // block types can be named, so expect anything here.
    Array.isArray(value.children) && value.children.every((child)=>isRecord$1(child)) && ("markDefs" in value ? Array.isArray(value.markDefs) && value.markDefs.every((def)=>isRecord$1(def)) : !0) && ("style" in value ? typeof value.style == "string" : !0);
}
function isPortableTextSpan(value) {
    return isRecord$1(value) && value._type === "span" && typeof value.text == "string" && ("marks" in value ? Array.isArray(value.marks) && value.marks.every((mark)=>typeof mark == "string") : !0);
}
function isPortableTextListBlock(value) {
    return isPortableTextTextBlock(value) && "listItem" in value && typeof value.listItem == "string" && "level" in value && Number.isInteger(value.level);
}
function isRecord(value) {
    return !!value && (typeof value == "object" || typeof value == "function");
}
function isDocumentSchemaType(type) {
    if (!isObjectSchemaType(type)) return !1;
    let current = type;
    for(; current;){
        if (current.name === "document") return !0;
        current = current.type;
    }
    return !1;
}
function isObjectSchemaType(type) {
    return isRecord(type) ? type.jsonType === "object" : !1;
}
function isArraySchemaType(type) {
    return isRecord(type) ? type.jsonType === "array" : !1;
}
function isArrayOfBlocksSchemaType(type) {
    return isArraySchemaType(type) && type.of.some((memberType)=>isBlockSchemaType(memberType));
}
function isArrayOfObjectsSchemaType(type) {
    return isArraySchemaType(type) && type.of.every((memberType)=>isObjectSchemaType(memberType));
}
function isArrayOfPrimitivesSchemaType(type) {
    return isArraySchemaType(type) && type.of.every((memberType)=>isPrimitiveSchemaType(memberType));
}
function isBooleanSchemaType(type) {
    return isRecord(type) ? type.jsonType === "boolean" : !1;
}
function isStringSchemaType(type) {
    return isRecord(type) ? type.jsonType === "string" : !1;
}
function isNumberSchemaType(type) {
    return isRecord(type) ? type.jsonType === "number" : !1;
}
function isPrimitiveSchemaType(type) {
    return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);
}
function isReferenceSchemaType(type) {
    return isRecord(type) && (type.name === "reference" || isReferenceSchemaType(type.type));
}
function isImageSchemaType(type) {
    return isRecord(type) && (type.name === "image" || isImageSchemaType(type.type));
}
function isFileSchemaType(type) {
    return isRecord(type) && (type.name === "file" || isFileSchemaType(type.type));
}
function isDeprecatedSchemaType(type) {
    return isRecord(type) ? typeof type.deprecated < "u" : !1;
}
function isDeprecationConfiguration(type) {
    return isRecord(type) ? typeof type.deprecated < "u" : !1;
}
function isCrossDatasetReferenceSchemaType(type) {
    return isRecord(type) && (type.name === "crossDatasetReference" || isCrossDatasetReferenceSchemaType(type.type));
}
function isTitledListValue(item) {
    return typeof item == "object" && item !== null && "title" in item && "value" in item;
}
function isSpanSchemaType(type) {
    return isRecord(type) ? Array.isArray(type.annotations) && Array.isArray(type.decorators) : !1;
}
function isBlockSchemaType(type) {
    if (!isRecord(type) || !Array.isArray(type.fields)) return !1;
    const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField), maybeStyle = type.fields.find(isBlockStyleObjectField), maybeList = type.fields.find(isBlockListObjectField);
    return isBlockChildrenObjectField(maybeSpanChildren) && isBlockStyleObjectField(maybeStyle) && isBlockListObjectField(maybeList);
}
function isBlockStyleObjectField(field) {
    return !isRecord(field) || field.name !== "style" ? !1 : isRecord(field.type) && field.type.jsonType === "string";
}
function isBlockListObjectField(field) {
    return !isRecord(field) || field.name !== "listItem" ? !1 : isRecord(field.type) && field.type.jsonType === "string";
}
function isBlockChildrenObjectField(field) {
    return !isRecord(field) || field.name !== "children" || !isArraySchemaType(field.type) ? !1 : field.type.of.some(isSpanSchemaType);
}
function defineType(schemaDefinition, defineOptions) {
    return schemaDefinition;
}
function defineField(schemaField, defineOptions) {
    return schemaField;
}
function defineArrayMember(arrayOfSchema, defineOptions) {
    return arrayOfSchema;
}
function typed(input) {
    return input;
}
const searchStrategies = [
    "groqLegacy",
    "groq2024"
];
function isSearchStrategy(maybeSearchStrategy) {
    return searchStrategies.includes(maybeSearchStrategy);
}
function isSlug(thing) {
    return isObject(thing) && typeof thing.current == "string";
}
function isCreateSquashedMutation(mutation) {
    return "createSquashed" in mutation;
}
function isValidationError(node) {
    return node.level === "error";
}
function isValidationWarning(node) {
    return node.level === "warning";
}
function isValidationInfo(node) {
    return node.level === "info";
}
;
 //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/@sanity/util/lib/paths.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "FOCUS_TERMINATOR": (()=>FOCUS_TERMINATOR),
    "_resolveKeyedPath": (()=>_resolveKeyedPath),
    "fromString": (()=>fromString),
    "get": (()=>get),
    "hasFocus": (()=>hasFocus),
    "hasItemFocus": (()=>hasItemFocus),
    "isEqual": (()=>isEqual),
    "isExpanded": (()=>isExpanded),
    "isSegmentEqual": (()=>isSegmentEqual),
    "numEqualSegments": (()=>numEqualSegments),
    "pathFor": (()=>pathFor),
    "resolveKeyedPath": (()=>resolveKeyedPath),
    "startsWith": (()=>startsWith),
    "toString": (()=>toString),
    "trimChildPath": (()=>trimChildPath),
    "trimLeft": (()=>trimLeft),
    "trimRight": (()=>trimRight)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/types/lib/index.mjs [app-client] (ecmascript)");
;
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/, EMPTY_PATH = [], FOCUS_TERMINATOR = "$", GROQ_DATA_TYPE_VALUES = [
    "true",
    "false",
    "null"
];
function get(obj, path, defaultVal) {
    const select = typeof path == "string" ? fromString(path) : path;
    if (!Array.isArray(select)) throw new Error("Path must be an array or a string");
    let acc = obj;
    for(let i = 0; i < select.length; i++){
        const segment = select[i];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexSegment"])(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc[segment];
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc.find((item)=>item._key === segment._key);
        }
        if (typeof segment == "string" && (acc = typeof acc == "object" && acc !== null ? acc[segment] : void 0), typeof acc > "u") return defaultVal;
    }
    return acc;
}
const pathsMemo = /* @__PURE__ */ new Map();
function pathFor(path) {
    if (path.length === 0) return EMPTY_PATH;
    const asString = toString(path);
    return pathsMemo.has(asString) ? pathsMemo.get(asString) : (pathsMemo.set(asString, path), Object.freeze(path), path);
}
function isEqual(path, otherPath) {
    return path.length === otherPath.length && path.every((segment, i)=>isSegmentEqual(segment, otherPath[i]));
}
function numEqualSegments(path, otherPath) {
    const length = Math.min(path.length, otherPath.length);
    for(let i = 0; i < length; i++)if (!isSegmentEqual(path[i], otherPath[i])) return i;
    return length;
}
function isSegmentEqual(segmentA, segmentB) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(segmentA) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(segmentB) ? segmentA._key === segmentB._key : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexSegment"])(segmentA) ? Number(segmentA) === Number(segmentB) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexTuple"])(segmentA) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexTuple"])(segmentB) ? segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1] : segmentA === segmentB;
}
function hasFocus(focusPath, path) {
    const withoutTerminator = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;
    return isEqual(withoutTerminator, path);
}
function hasItemFocus(focusPath, item) {
    return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);
}
function isExpanded(segment, focusPath) {
    const [head, ...tail] = focusPath;
    return tail.length > 0 && isSegmentEqual(segment, head);
}
function startsWith(prefix, path) {
    return prefix.every((segment, i)=>isSegmentEqual(segment, path[i]));
}
function trimLeft(prefix, path) {
    if (prefix.length === 0 || path.length === 0) return path;
    const [prefixHead, ...prefixTail] = prefix, [pathHead, ...pathTail] = path;
    return isSegmentEqual(prefixHead, pathHead) ? pathFor(trimLeft(prefixTail, pathTail)) : path;
}
function trimRight(suffix, path) {
    const sufLen = suffix.length, pathLen = path.length;
    if (sufLen === 0 || pathLen === 0) return path;
    let i = 0;
    for(; i < sufLen && i < pathLen && isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1]);)i++;
    return pathFor(path.slice(0, pathLen - i));
}
function trimChildPath(path, childPath) {
    return startsWith(path, childPath) ? trimLeft(path, childPath) : EMPTY_PATH;
}
function toString(path) {
    if (!Array.isArray(path)) throw new Error("Path is not an array");
    return path.reduce((target, segment, i)=>{
        const isHead = i === 0;
        if (typeof segment == "number") return `${target}[${segment}]`;
        if (typeof segment == "string") return isHead ? segment : GROQ_DATA_TYPE_VALUES.includes(segment) ? `${target}["${segment}"]` : `${target}.${segment}`;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(segment) && segment._key) return `${target}[_key=="${segment._key}"]`;
        if (Array.isArray(segment)) {
            const [from, to] = segment;
            return `${target}[${from}:${to}]`;
        }
        throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
    }, "");
}
function _resolveKeyedPath(value, path) {
    if (path.length === 0) return path;
    const [next, ...rest] = path;
    if (typeof next == "number") {
        if (!Array.isArray(value) || !(next in value)) return [];
        const item = value[next];
        return [
            typeof item?._key == "string" ? {
                _key: item._key
            } : next,
            ..._resolveKeyedPath(item, rest)
        ];
    }
    const nextVal = get(value, [
        next
    ]);
    return [
        next,
        ..._resolveKeyedPath(nextVal, rest)
    ];
}
function resolveKeyedPath(value, path) {
    if (!Array.isArray(path)) throw new Error("Path is not an array");
    return pathFor(_resolveKeyedPath(value, path));
}
function fromString(path) {
    if (typeof path != "string") throw new Error("Path is not a string");
    const segments = path.match(rePropName);
    if (!segments) throw new Error("Invalid path string");
    return segments.map(normalizePathSegment);
}
function normalizePathSegment(segment) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexSegment"])(segment) ? normalizeIndexSegment(segment) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(segment) ? normalizeKeySegment(segment) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexTuple"])(segment) ? normalizeIndexTupleSegment(segment) : segment;
}
function normalizeIndexSegment(segment) {
    return Number(segment.replace(/[^\d]/g, ""));
}
function normalizeKeySegment(segment) {
    return {
        _key: segment.match(reKeySegment)[1]
    };
}
function normalizeIndexTupleSegment(segment) {
    const [from, to] = segment.split(":").map((seg)=>seg === "" ? seg : Number(seg));
    return [
        from,
        to
    ];
}
;
 //# sourceMappingURL=paths.mjs.map
}}),
"[project]/node_modules/@sanity/util/lib/legacyDateFormat.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DEFAULT_DATE_FORMAT": (()=>DEFAULT_DATE_FORMAT),
    "DEFAULT_TIME_FORMAT": (()=>DEFAULT_TIME_FORMAT),
    "format": (()=>format),
    "parse": (()=>parse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$moment$2f$moment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/moment/moment.js [app-client] (ecmascript)");
;
const DEFAULT_DATE_FORMAT = "YYYY-MM-DD", DEFAULT_TIME_FORMAT = "HH:mm";
function format(input, format2, useUTC = !1) {
    return useUTC ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$moment$2f$moment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].utc(input).format(format2) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$moment$2f$moment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(input).format(format2);
}
function parse(dateString, format2) {
    const parsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$moment$2f$moment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(dateString, format2, !0);
    return parsed.isValid() ? {
        isValid: !0,
        date: parsed.toDate()
    } : {
        isValid: !1,
        error: `Invalid date. Must be on the format "${format2}"`
    };
}
;
 //# sourceMappingURL=legacyDateFormat.mjs.map
}}),
"[project]/node_modules/@sanity/util/lib/content.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "isDeepEmpty": (()=>isDeepEmpty),
    "isEmpty": (()=>isEmpty),
    "isEmptyArray": (()=>isEmptyArray),
    "isEmptyObject": (()=>isEmptyObject),
    "isShallowEmptyObject": (()=>isShallowEmptyObject),
    "randomKey": (()=>randomKey),
    "resolveTypeName": (()=>resolveTypeName)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-random-values-esm/index.mjs [app-client] (ecmascript)");
;
var hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function isDeepEmptyObject(value) {
    for(const key in value)if (!(key === "_type" || key === "_key") && hasOwn(value, key) && !isDeepEmpty(value[key])) return !1;
    return !0;
}
function isDeepEmptyArray(value) {
    for(let i = 0; i < value.length; i++)if (!isDeepEmpty(value[i])) return !1;
    return !0;
}
function isDeepEmpty(value) {
    if (value == null) return !0;
    const type = typeof value;
    return Array.isArray(value) ? isDeepEmptyArray(value) : type === "object" ? isDeepEmptyObject(value) : !1;
}
const isEmptyArray = isDeepEmptyArray, isEmpty = isDeepEmpty, isEmptyObject = isDeepEmptyObject;
function isShallowEmptyObject(value) {
    for(const key in value)if (!(key === "_type" || key === "_key") && hasOwn(value, key) && value[key] !== void 0) return !1;
    return !0;
}
const getByteHexTable = /* @__PURE__ */ (()=>{
    let table;
    return ()=>{
        if (table) return table;
        table = [];
        for(let i = 0; i < 256; ++i)table[i] = (i + 256).toString(16).slice(1);
        return table;
    };
})();
function whatwgRNG(length = 16) {
    const rnds8 = new Uint8Array(length);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rnds8), rnds8;
}
function randomKey(length) {
    const table = getByteHexTable();
    return whatwgRNG(length).reduce((str, n)=>str + table[n], "").slice(0, length);
}
const toString = Object.prototype.toString;
function resolveJSType(val) {
    switch(toString.call(val)){
        case "[object Function]":
            return "function";
        case "[object Date]":
            return "date";
        case "[object RegExp]":
            return "regexp";
        case "[object Arguments]":
            return "arguments";
        case "[object Array]":
            return "array";
        case "[object String]":
            return "string";
    }
    if (typeof val == "object" && val && typeof val.length == "number") try {
        if (typeof val.callee == "function") return "arguments";
    } catch (ex) {
        if (ex instanceof TypeError) return "arguments";
    }
    return val === null ? "null" : val === void 0 ? "undefined" : val && val.nodeType === 1 ? "element" : val === Object(val) ? "object" : typeof val;
}
function resolveTypeName(value) {
    const jsType = resolveJSType(value);
    if (jsType !== "object") return jsType;
    const obj = value;
    return "_type" in obj && obj._type || jsType;
}
;
 //# sourceMappingURL=content.mjs.map
}}),
"[project]/node_modules/@sanity/util/lib/concurrency-limiter.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ConcurrencyLimiter": (()=>ConcurrencyLimiter)
});
class ConcurrencyLimiter {
    constructor(max){
        this.max = max;
    }
    current = 0;
    resolvers = [];
    /**
   * Indicates when a slot for a new operation is ready.
   * If under the limit, it resolves immediately; otherwise, it waits until a slot is free.
   */ ready = ()=>this.max === 1 / 0 ? Promise.resolve() : this.current < this.max ? (this.current++, Promise.resolve()) : new Promise((resolve)=>{
            this.resolvers.push(resolve);
        });
    /**
   * Releases a slot, decrementing the current count of operations if nothing is in the queue.
   * If there are operations waiting, it allows the next one in the queue to proceed.
   */ release = ()=>{
        if (this.max === 1 / 0) return;
        const nextResolver = this.resolvers.shift();
        if (nextResolver) {
            nextResolver();
            return;
        }
        this.current = Math.max(0, this.current - 1);
    };
}
;
 //# sourceMappingURL=concurrency-limiter.mjs.map
}}),
"[project]/node_modules/@sanity/util/lib/client.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createClientConcurrencyLimiter": (()=>createClientConcurrencyLimiter)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/from.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$switchMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/switchMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$finalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/finalize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$util$2f$lib$2f$concurrency$2d$limiter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/util/lib/concurrency-limiter.mjs [app-client] (ecmascript)");
;
;
function createClientConcurrencyLimiter(maxConcurrency) {
    const limiter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$util$2f$lib$2f$concurrency$2d$limiter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConcurrencyLimiter"](maxConcurrency);
    function wrapClient(client) {
        return new Proxy(client, {
            get: (target, property)=>{
                switch(property){
                    case "fetch":
                        return async (...args)=>{
                            await limiter.ready();
                            try {
                                return await target.fetch(...args);
                            } finally{
                                limiter.release();
                            }
                        };
                    case "clone":
                        return (...args)=>wrapClient(target.clone(...args));
                    case "config":
                        return (...args)=>{
                            const result = target.config(...args);
                            return args[0] ? wrapClient(result) : result;
                        };
                    case "withConfig":
                        return (...args)=>wrapClient(target.withConfig(...args));
                    case "observable":
                        return wrapObservableClient(target.observable);
                    default:
                        return target[property];
                }
            }
        });
    }
    function wrapObservableClient(observableSanityClient) {
        return new Proxy(observableSanityClient, {
            get: (target, property)=>{
                switch(property){
                    case "fetch":
                        return (...args)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(limiter.ready()).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$switchMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["switchMap"])(()=>target.fetch(...args)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$finalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finalize"])(()=>limiter.release()));
                    case "clone":
                        return (...args)=>wrapObservableClient(target.clone(...args));
                    case "config":
                        return (...args)=>{
                            const result = target.config(...args);
                            return args[0] ? wrapObservableClient(result) : result;
                        };
                    case "withConfig":
                        return (...args)=>wrapObservableClient(target.withConfig(...args));
                    default:
                        return target[property];
                }
            }
        });
    }
    return wrapClient;
}
;
 //# sourceMappingURL=client.mjs.map
}}),
"[project]/node_modules/@sanity/color/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "COLOR_HUES": (()=>COLOR_HUES),
    "COLOR_TINTS": (()=>COLOR_TINTS),
    "black": (()=>black),
    "blue": (()=>blue),
    "buildTints": (()=>buildTints),
    "color": (()=>color),
    "config": (()=>config),
    "cyan": (()=>cyan),
    "darken": (()=>darken),
    "gray": (()=>gray),
    "green": (()=>green),
    "hexToRgb": (()=>hexToRgb),
    "hslToRgb": (()=>hslToRgb),
    "hues": (()=>hues),
    "limit": (()=>limit),
    "magenta": (()=>magenta),
    "orange": (()=>orange),
    "purple": (()=>purple),
    "red": (()=>red),
    "rgbToHex": (()=>rgbToHex),
    "rgbToHsl": (()=>rgbToHsl),
    "screen": (()=>screen),
    "white": (()=>white),
    "yellow": (()=>yellow)
});
const COLOR_HUES = [
    "gray",
    "blue",
    "purple",
    "magenta",
    "red",
    "orange",
    "yellow",
    "green",
    "cyan"
], COLOR_TINTS = [
    "50",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900",
    "950"
];
function hslToRgb(hsl) {
    const h = hsl[0], s = hsl[1] / 100, l = hsl[2] / 100, k = (n)=>(n + h / 30) % 12, a = s * Math.min(l, 1 - l), f = (n)=>l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
    return [
        255 * f(0),
        255 * f(8),
        255 * f(4)
    ];
}
function rgbToHex([r, g, b]) {
    const _r = Math.round(r), _g = Math.round(g), _b = Math.round(b);
    return "#" + ((1 << 24) + (_r << 16) + (_g << 8) + _b).toString(16).slice(1);
}
function buildTints(options) {
    const { hueKey, color: color2 } = options;
    return COLOR_TINTS.reduce((acc, tintKey)=>{
        const tint = Number(tintKey), rgb = hslToRgb(color2.tints[tintKey].hsl), hex = rgbToHex([
            Math.round(rgb[0]),
            Math.round(rgb[1]),
            Math.round(rgb[2])
        ]);
        return acc[tintKey] = {
            title: `${hueKey.slice(0, 1).toUpperCase()}${hueKey.slice(1)} ${tint}`,
            hex
        }, acc;
    }, {});
}
const black = {
    title: "Black",
    hex: "#0d0e12"
}, white = {
    title: "White",
    hex: "#ffffff"
}, gray = {
    50: {
        title: "Gray 50",
        hex: "#f6f6f8"
    },
    100: {
        title: "Gray 100",
        hex: "#eeeef1"
    },
    200: {
        title: "Gray 200",
        hex: "#e3e4e8"
    },
    300: {
        title: "Gray 300",
        hex: "#bbbdc9"
    },
    400: {
        title: "Gray 400",
        hex: "#9499ad"
    },
    500: {
        title: "Gray 500",
        hex: "#727892"
    },
    600: {
        title: "Gray 600",
        hex: "#515870"
    },
    700: {
        title: "Gray 700",
        hex: "#383d51"
    },
    800: {
        title: "Gray 800",
        hex: "#252837"
    },
    900: {
        title: "Gray 900",
        hex: "#1b1d27"
    },
    950: {
        title: "Gray 950",
        hex: "#13141b"
    }
}, blue = {
    50: {
        title: "Blue 50",
        hex: "#f5f8ff"
    },
    100: {
        title: "Blue 100",
        hex: "#e5edff"
    },
    200: {
        title: "Blue 200",
        hex: "#dbe5ff"
    },
    300: {
        title: "Blue 300",
        hex: "#a8bfff"
    },
    400: {
        title: "Blue 400",
        hex: "#7595ff"
    },
    500: {
        title: "Blue 500",
        hex: "#556bfc"
    },
    600: {
        title: "Blue 600",
        hex: "#4043e7"
    },
    700: {
        title: "Blue 700",
        hex: "#2927aa"
    },
    800: {
        title: "Blue 800",
        hex: "#192457"
    },
    900: {
        title: "Blue 900",
        hex: "#161a41"
    },
    950: {
        title: "Blue 950",
        hex: "#101228"
    }
}, purple = {
    50: {
        title: "Purple 50",
        hex: "#f8f5ff"
    },
    100: {
        title: "Purple 100",
        hex: "#f1ebff"
    },
    200: {
        title: "Purple 200",
        hex: "#ece1fe"
    },
    300: {
        title: "Purple 300",
        hex: "#ccb1fc"
    },
    400: {
        title: "Purple 400",
        hex: "#b087f7"
    },
    500: {
        title: "Purple 500",
        hex: "#8f57ef"
    },
    600: {
        title: "Purple 600",
        hex: "#721fe5"
    },
    700: {
        title: "Purple 700",
        hex: "#4c1a9e"
    },
    800: {
        title: "Purple 800",
        hex: "#2f1862"
    },
    900: {
        title: "Purple 900",
        hex: "#23173f"
    },
    950: {
        title: "Purple 950",
        hex: "#181128"
    }
}, magenta = {
    50: {
        title: "Magenta 50",
        hex: "#fef6f9"
    },
    100: {
        title: "Magenta 100",
        hex: "#fde8ef"
    },
    200: {
        title: "Magenta 200",
        hex: "#fcdee9"
    },
    300: {
        title: "Magenta 300",
        hex: "#f7abc5"
    },
    400: {
        title: "Magenta 400",
        hex: "#f0709b"
    },
    500: {
        title: "Magenta 500",
        hex: "#e72767"
    },
    600: {
        title: "Magenta 600",
        hex: "#b11651"
    },
    700: {
        title: "Magenta 700",
        hex: "#7c1342"
    },
    800: {
        title: "Magenta 800",
        hex: "#4b1130"
    },
    900: {
        title: "Magenta 900",
        hex: "#341325"
    },
    950: {
        title: "Magenta 950",
        hex: "#1f0f14"
    }
}, red = {
    50: {
        title: "Red 50",
        hex: "#fff6f5"
    },
    100: {
        title: "Red 100",
        hex: "#ffe7e5"
    },
    200: {
        title: "Red 200",
        hex: "#ffdedc"
    },
    300: {
        title: "Red 300",
        hex: "#fdada5"
    },
    400: {
        title: "Red 400",
        hex: "#f77769"
    },
    500: {
        title: "Red 500",
        hex: "#ef4434"
    },
    600: {
        title: "Red 600",
        hex: "#cc2819"
    },
    700: {
        title: "Red 700",
        hex: "#8b2018"
    },
    800: {
        title: "Red 800",
        hex: "#4d1714"
    },
    900: {
        title: "Red 900",
        hex: "#321615"
    },
    950: {
        title: "Red 950",
        hex: "#1e1011"
    }
}, orange = {
    50: {
        title: "Orange 50",
        hex: "#fff7f0"
    },
    100: {
        title: "Orange 100",
        hex: "#ffeadb"
    },
    200: {
        title: "Orange 200",
        hex: "#ffddc7"
    },
    300: {
        title: "Orange 300",
        hex: "#ffb685"
    },
    400: {
        title: "Orange 400",
        hex: "#ff8e42"
    },
    500: {
        title: "Orange 500",
        hex: "#fa6400"
    },
    600: {
        title: "Orange 600",
        hex: "#b14802"
    },
    700: {
        title: "Orange 700",
        hex: "#7c3404"
    },
    800: {
        title: "Orange 800",
        hex: "#461e07"
    },
    900: {
        title: "Orange 900",
        hex: "#32160b"
    },
    950: {
        title: "Orange 950",
        hex: "#21120d"
    }
}, yellow = {
    50: {
        title: "Yellow 50",
        hex: "#fefae1"
    },
    100: {
        title: "Yellow 100",
        hex: "#fcf3bb"
    },
    200: {
        title: "Yellow 200",
        hex: "#f9e994"
    },
    300: {
        title: "Yellow 300",
        hex: "#f7d455"
    },
    400: {
        title: "Yellow 400",
        hex: "#f9bc15"
    },
    500: {
        title: "Yellow 500",
        hex: "#d28a04"
    },
    600: {
        title: "Yellow 600",
        hex: "#965908"
    },
    700: {
        title: "Yellow 700",
        hex: "#653a0b"
    },
    800: {
        title: "Yellow 800",
        hex: "#3b220c"
    },
    900: {
        title: "Yellow 900",
        hex: "#271a11"
    },
    950: {
        title: "Yellow 950",
        hex: "#181410"
    }
}, green = {
    50: {
        title: "Green 50",
        hex: "#e7fef5"
    },
    100: {
        title: "Green 100",
        hex: "#c5fce8"
    },
    200: {
        title: "Green 200",
        hex: "#a9f9dc"
    },
    300: {
        title: "Green 300",
        hex: "#59f3ba"
    },
    400: {
        title: "Green 400",
        hex: "#0ff0a1"
    },
    500: {
        title: "Green 500",
        hex: "#04b97a"
    },
    600: {
        title: "Green 600",
        hex: "#01794f"
    },
    700: {
        title: "Green 700",
        hex: "#015133"
    },
    800: {
        title: "Green 800",
        hex: "#023120"
    },
    900: {
        title: "Green 900",
        hex: "#06231a"
    },
    950: {
        title: "Green 950",
        hex: "#071715"
    }
}, cyan = {
    50: {
        title: "Cyan 50",
        hex: "#e7fefe"
    },
    100: {
        title: "Cyan 100",
        hex: "#c5fcfc"
    },
    200: {
        title: "Cyan 200",
        hex: "#96f8f8"
    },
    300: {
        title: "Cyan 300",
        hex: "#62efef"
    },
    400: {
        title: "Cyan 400",
        hex: "#18e2e2"
    },
    500: {
        title: "Cyan 500",
        hex: "#04b8be"
    },
    600: {
        title: "Cyan 600",
        hex: "#037782"
    },
    700: {
        title: "Cyan 700",
        hex: "#024950"
    },
    800: {
        title: "Cyan 800",
        hex: "#042f34"
    },
    900: {
        title: "Cyan 900",
        hex: "#072227"
    },
    950: {
        title: "Cyan 950",
        hex: "#0d181c"
    }
}, hues = {
    gray,
    blue,
    purple,
    magenta,
    red,
    orange,
    yellow,
    green,
    cyan
}, color = {
    black,
    white,
    ...hues
}, config = {
    black: {
        title: "Black",
        hsl: [
            225,
            16,
            6
        ]
    },
    white: {
        title: "White",
        hsl: [
            0,
            0,
            100
        ]
    },
    gray: {
        title: "Gray",
        tints: {
            50: {
                title: "Gray 50",
                hsl: [
                    240,
                    12,
                    97
                ]
            },
            100: {
                title: "Gray 100",
                hsl: [
                    240,
                    10,
                    94
                ]
            },
            200: {
                title: "Gray 200",
                hsl: [
                    231,
                    10,
                    90
                ]
            },
            300: {
                title: "Gray 300",
                hsl: [
                    232,
                    11,
                    76
                ]
            },
            400: {
                title: "Gray 400",
                hsl: [
                    228,
                    13,
                    63
                ]
            },
            500: {
                title: "Gray 500",
                hsl: [
                    229,
                    13,
                    51
                ]
            },
            600: {
                title: "Gray 600",
                hsl: [
                    228,
                    16,
                    38
                ]
            },
            700: {
                title: "Gray 700",
                hsl: [
                    229,
                    18,
                    27
                ]
            },
            800: {
                title: "Gray 800",
                hsl: [
                    229,
                    19,
                    18
                ]
            },
            900: {
                title: "Gray 900",
                hsl: [
                    228,
                    19,
                    13
                ]
            },
            950: {
                title: "Gray 950",
                hsl: [
                    233,
                    17,
                    9
                ]
            }
        }
    },
    blue: {
        title: "Blue",
        tints: {
            50: {
                title: "Blue 50",
                hsl: [
                    222,
                    100,
                    98
                ]
            },
            100: {
                title: "Blue 100",
                hsl: [
                    222,
                    100,
                    95
                ]
            },
            200: {
                title: "Blue 200",
                hsl: [
                    223,
                    100,
                    93
                ]
            },
            300: {
                title: "Blue 300",
                hsl: [
                    224,
                    100,
                    83
                ]
            },
            400: {
                title: "Blue 400",
                hsl: [
                    226,
                    100,
                    73
                ]
            },
            500: {
                title: "Blue 500",
                hsl: [
                    232,
                    96,
                    66
                ]
            },
            600: {
                title: "Blue 600",
                hsl: [
                    239,
                    78,
                    58
                ]
            },
            700: {
                title: "Blue 700",
                hsl: [
                    241,
                    63,
                    41
                ]
            },
            800: {
                title: "Blue 800",
                hsl: [
                    230,
                    55,
                    22
                ]
            },
            900: {
                title: "Blue 900",
                hsl: [
                    234,
                    49,
                    17
                ]
            },
            950: {
                title: "Blue 950",
                hsl: [
                    235,
                    43,
                    11
                ]
            }
        }
    },
    purple: {
        title: "Purple",
        tints: {
            50: {
                title: "Purple 50",
                hsl: [
                    260,
                    95,
                    98
                ]
            },
            100: {
                title: "Purple 100",
                hsl: [
                    260,
                    98,
                    96
                ]
            },
            200: {
                title: "Purple 200",
                hsl: [
                    263,
                    96,
                    94
                ]
            },
            300: {
                title: "Purple 300",
                hsl: [
                    262,
                    92,
                    84
                ]
            },
            400: {
                title: "Purple 400",
                hsl: [
                    262,
                    88,
                    75
                ]
            },
            500: {
                title: "Purple 500",
                hsl: [
                    262,
                    83,
                    64
                ]
            },
            600: {
                title: "Purple 600",
                hsl: [
                    265,
                    79,
                    51
                ]
            },
            700: {
                title: "Purple 700",
                hsl: [
                    263,
                    72,
                    36
                ]
            },
            800: {
                title: "Purple 800",
                hsl: [
                    258,
                    60,
                    24
                ]
            },
            900: {
                title: "Purple 900",
                hsl: [
                    257,
                    46,
                    17
                ]
            },
            950: {
                title: "Purple 950",
                hsl: [
                    260,
                    41,
                    11
                ]
            }
        }
    },
    magenta: {
        title: "Magenta",
        tints: {
            50: {
                title: "Magenta 50",
                hsl: [
                    340,
                    82,
                    98
                ]
            },
            100: {
                title: "Magenta 100",
                hsl: [
                    339,
                    83,
                    95
                ]
            },
            200: {
                title: "Magenta 200",
                hsl: [
                    339,
                    83,
                    93
                ]
            },
            300: {
                title: "Magenta 300",
                hsl: [
                    340,
                    82,
                    82
                ]
            },
            400: {
                title: "Magenta 400",
                hsl: [
                    340,
                    81,
                    69
                ]
            },
            500: {
                title: "Magenta 500",
                hsl: [
                    340,
                    80,
                    53
                ]
            },
            600: {
                title: "Magenta 600",
                hsl: [
                    337,
                    78,
                    39
                ]
            },
            700: {
                title: "Magenta 700",
                hsl: [
                    333,
                    73,
                    28
                ]
            },
            800: {
                title: "Magenta 800",
                hsl: [
                    328,
                    63,
                    18
                ]
            },
            900: {
                title: "Magenta 900",
                hsl: [
                    327,
                    46,
                    14
                ]
            },
            950: {
                title: "Magenta 950",
                hsl: [
                    341,
                    35,
                    9
                ]
            }
        }
    },
    red: {
        title: "Red",
        tints: {
            50: {
                title: "Red 50",
                hsl: [
                    5,
                    100,
                    98
                ]
            },
            100: {
                title: "Red 100",
                hsl: [
                    4,
                    100,
                    95
                ]
            },
            200: {
                title: "Red 200",
                hsl: [
                    4,
                    98,
                    93
                ]
            },
            300: {
                title: "Red 300",
                hsl: [
                    5,
                    95,
                    82
                ]
            },
            400: {
                title: "Red 400",
                hsl: [
                    6,
                    90,
                    69
                ]
            },
            500: {
                title: "Red 500",
                hsl: [
                    5,
                    85,
                    57
                ]
            },
            600: {
                title: "Red 600",
                hsl: [
                    5,
                    78,
                    45
                ]
            },
            700: {
                title: "Red 700",
                hsl: [
                    4,
                    70,
                    32
                ]
            },
            800: {
                title: "Red 800",
                hsl: [
                    3,
                    58,
                    19
                ]
            },
            900: {
                title: "Red 900",
                hsl: [
                    2,
                    41,
                    14
                ]
            },
            950: {
                title: "Red 950",
                hsl: [
                    356,
                    30,
                    9
                ]
            }
        }
    },
    orange: {
        title: "Orange",
        tints: {
            50: {
                title: "Orange 50",
                hsl: [
                    28,
                    100,
                    97
                ]
            },
            100: {
                title: "Orange 100",
                hsl: [
                    25,
                    100,
                    93
                ]
            },
            200: {
                title: "Orange 200",
                hsl: [
                    24,
                    100,
                    89
                ]
            },
            300: {
                title: "Orange 300",
                hsl: [
                    24,
                    100,
                    76
                ]
            },
            400: {
                title: "Orange 400",
                hsl: [
                    24,
                    100,
                    63
                ]
            },
            500: {
                title: "Orange 500",
                hsl: [
                    24,
                    100,
                    49
                ]
            },
            600: {
                title: "Orange 600",
                hsl: [
                    24,
                    98,
                    35
                ]
            },
            700: {
                title: "Orange 700",
                hsl: [
                    24,
                    94,
                    25
                ]
            },
            800: {
                title: "Orange 800",
                hsl: [
                    22,
                    82,
                    15
                ]
            },
            900: {
                title: "Orange 900",
                hsl: [
                    17,
                    65,
                    12
                ]
            },
            950: {
                title: "Orange 950",
                hsl: [
                    14,
                    43,
                    9
                ]
            }
        }
    },
    yellow: {
        title: "Yellow",
        tints: {
            50: {
                title: "Yellow 50",
                hsl: [
                    51,
                    94,
                    94
                ]
            },
            100: {
                title: "Yellow 100",
                hsl: [
                    52,
                    91,
                    86
                ]
            },
            200: {
                title: "Yellow 200",
                hsl: [
                    50,
                    90,
                    78
                ]
            },
            300: {
                title: "Yellow 300",
                hsl: [
                    47,
                    91,
                    65
                ]
            },
            400: {
                title: "Yellow 400",
                hsl: [
                    44,
                    95,
                    53
                ]
            },
            500: {
                title: "Yellow 500",
                hsl: [
                    39,
                    96,
                    42
                ]
            },
            600: {
                title: "Yellow 600",
                hsl: [
                    34,
                    90,
                    31
                ]
            },
            700: {
                title: "Yellow 700",
                hsl: [
                    31,
                    80,
                    22
                ]
            },
            800: {
                title: "Yellow 800",
                hsl: [
                    28,
                    66,
                    14
                ]
            },
            900: {
                title: "Yellow 900",
                hsl: [
                    24,
                    40,
                    11
                ]
            },
            950: {
                title: "Yellow 950",
                hsl: [
                    24,
                    20,
                    8
                ]
            }
        }
    },
    green: {
        title: "Green",
        tints: {
            50: {
                title: "Green 50",
                hsl: [
                    157,
                    89,
                    95
                ]
            },
            100: {
                title: "Green 100",
                hsl: [
                    158,
                    89,
                    88
                ]
            },
            200: {
                title: "Green 200",
                hsl: [
                    158,
                    87,
                    82
                ]
            },
            300: {
                title: "Green 300",
                hsl: [
                    158,
                    86,
                    65
                ]
            },
            400: {
                title: "Green 400",
                hsl: [
                    159,
                    88,
                    50
                ]
            },
            500: {
                title: "Green 500",
                hsl: [
                    159,
                    96,
                    37
                ]
            },
            600: {
                title: "Green 600",
                hsl: [
                    159,
                    98,
                    24
                ]
            },
            700: {
                title: "Green 700",
                hsl: [
                    158,
                    98,
                    16
                ]
            },
            800: {
                title: "Green 800",
                hsl: [
                    158,
                    91,
                    10
                ]
            },
            900: {
                title: "Green 900",
                hsl: [
                    162,
                    72,
                    8
                ]
            },
            950: {
                title: "Green 950",
                hsl: [
                    172,
                    51,
                    6
                ]
            }
        }
    },
    cyan: {
        title: "Cyan",
        tints: {
            50: {
                title: "Cyan 50",
                hsl: [
                    180,
                    92,
                    95
                ]
            },
            100: {
                title: "Cyan 100",
                hsl: [
                    180,
                    91,
                    88
                ]
            },
            200: {
                title: "Cyan 200",
                hsl: [
                    180,
                    87,
                    78
                ]
            },
            300: {
                title: "Cyan 300",
                hsl: [
                    180,
                    81,
                    66
                ]
            },
            400: {
                title: "Cyan 400",
                hsl: [
                    180,
                    81,
                    49
                ]
            },
            500: {
                title: "Cyan 500",
                hsl: [
                    182,
                    96,
                    38
                ]
            },
            600: {
                title: "Cyan 600",
                hsl: [
                    185,
                    96,
                    26
                ]
            },
            700: {
                title: "Cyan 700",
                hsl: [
                    185,
                    95,
                    16
                ]
            },
            800: {
                title: "Cyan 800",
                hsl: [
                    187,
                    86,
                    11
                ]
            },
            900: {
                title: "Cyan 900",
                hsl: [
                    188,
                    68,
                    9
                ]
            },
            950: {
                title: "Cyan 950",
                hsl: [
                    196,
                    37,
                    8
                ]
            }
        }
    }
};
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!result) throw new Error("input is not valid hex");
    return [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
    ];
}
function rgbToHsl([r, g, b]) {
    r /= 255, g /= 255, b /= 255;
    const cmin = Math.min(r, g, b), cmax = Math.max(r, g, b), delta = cmax - cmin;
    let h = 0, s = 0, l = 0;
    return delta == 0 ? h = 0 : cmax == r ? h = (g - b) / delta % 6 : cmax == g ? h = (b - r) / delta + 2 : h = (r - g) / delta + 4, h = Math.round(h * 60), h < 0 && (h += 360), l = (cmax + cmin) / 2, s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1)), s = +(s * 100).toFixed(0), l = +(l * 100).toFixed(0), [
        h,
        s,
        l
    ];
}
function clamp(num) {
    return Math.max(Math.min(num, 255), 0);
}
function darkenChannel(backdrop, source) {
    return Math.min(backdrop, source);
}
function darken(b, s) {
    return [
        Math.round(clamp(darkenChannel(b[0] / 255, s[0] / 255) * 255)),
        Math.round(clamp(darkenChannel(b[1] / 255, s[1] / 255) * 255)),
        Math.round(clamp(darkenChannel(b[2] / 255, s[2] / 255) * 255))
    ];
}
function interpolate(min, max, val) {
    const size = max - min;
    return min + size * val;
}
function limit(darkest, lightest, source) {
    const r = Math.round(interpolate(darkest[0], lightest[0], source[0] / 255)), g = Math.round(interpolate(darkest[1], lightest[1], source[1] / 255)), b = Math.round(interpolate(darkest[2], lightest[2], source[2] / 255));
    return [
        r,
        g,
        b
    ];
}
function screenChannel(backdrop, source) {
    return backdrop + source - backdrop * source;
}
function screen(b, s) {
    return [
        Math.round(clamp(screenChannel(b[0] / 255, s[0] / 255) * 255)),
        Math.round(clamp(screenChannel(b[1] / 255, s[1] / 255) * 255)),
        Math.round(clamp(screenChannel(b[2] / 255, s[2] / 255) * 255))
    ];
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/client/dist/_chunks-es/stegaClean.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "C": (()=>C),
    "stegaClean": (()=>stegaClean),
    "vercelStegaCleanAll": (()=>vercelStegaCleanAll)
});
var s = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 8290,
    4: 8291,
    5: 8288,
    6: 65279,
    7: 8289,
    8: 119155,
    9: 119156,
    a: 119157,
    b: 119158,
    c: 119159,
    d: 119160,
    e: 119161,
    f: 119162
}, c = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 65279
}, u = new Array(4).fill(String.fromCodePoint(c[0])).join("");
function E(t) {
    let e = JSON.stringify(t);
    return `${u}${Array.from(e).map((r)=>{
        let n = r.charCodeAt(0);
        if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);
        return Array.from(n.toString(4).padStart(4, "0")).map((o)=>String.fromCodePoint(c[o])).join("");
    }).join("")}`;
}
function I(t) {
    return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\d+(?:[-:\/]\d+){2}(?:T\d+(?:[-:\/]\d+){1,2}(\.\d+)?Z?)?/.test(t) ? !1 : !!Date.parse(t);
}
function T(t) {
    try {
        new URL(t, t.startsWith("/") ? "https://acme.com" : void 0);
    } catch  {
        return !1;
    }
    return !0;
}
function C(t, e, r = "auto") {
    return r === !0 || r === "auto" && (I(t) || T(t)) ? t : `${t}${E(e)}`;
}
Object.fromEntries(Object.entries(c).map((t)=>t.reverse()));
Object.fromEntries(Object.entries(s).map((t)=>t.reverse()));
var S = `${Object.values(s).map((t)=>`\\u{${t.toString(16)}}`).join("")}`, f = new RegExp(`[${S}]{4,}`, "gu");
function _(t) {
    var e;
    return {
        cleaned: t.replace(f, ""),
        encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || ""
    };
}
function O(t) {
    return t && JSON.parse(_(JSON.stringify(t)).cleaned);
}
function stegaClean(result) {
    return O(result);
}
const vercelStegaCleanAll = stegaClean;
;
 //# sourceMappingURL=stegaClean.js.map
}}),
"[project]/node_modules/@sanity/client/dist/index.browser.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BasePatch": (()=>BasePatch),
    "BaseTransaction": (()=>BaseTransaction),
    "ChannelError": (()=>ChannelError),
    "ClientError": (()=>ClientError),
    "ConnectionFailedError": (()=>ConnectionFailedError),
    "CorsOriginError": (()=>CorsOriginError),
    "DisconnectError": (()=>DisconnectError),
    "MessageError": (()=>MessageError),
    "MessageParseError": (()=>MessageParseError),
    "ObservablePatch": (()=>ObservablePatch),
    "ObservableSanityClient": (()=>ObservableSanityClient),
    "ObservableTransaction": (()=>ObservableTransaction),
    "Patch": (()=>Patch),
    "SanityClient": (()=>SanityClient),
    "ServerError": (()=>ServerError),
    "Transaction": (()=>Transaction),
    "connectEventSource": (()=>connectEventSource),
    "createClient": (()=>createClient),
    "default": (()=>deprecatedCreateClient),
    "requester": (()=>requester),
    "validateApiPerspective": (()=>validateApiPerspective)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$it$2f$dist$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-it/dist/index.browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$it$2f$dist$2f$middleware$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/get-it/dist/middleware.browser.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/Observable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$defer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/defer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$isObservable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/util/isObservable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/from.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$catchError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/catchError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$throwError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/throwError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$timer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/timer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$tap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/tap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$finalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/finalize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$share$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/share.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/merge.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/empty.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$stegaClean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/client/dist/_chunks-es/stegaClean.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$combineLatestWith$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/filter.js [app-client] (ecmascript)");
;
;
;
;
;
;
class ClientError extends Error {
    response;
    statusCode = 400;
    responseBody;
    details;
    constructor(res){
        const props = extractErrorProps(res);
        super(props.message), Object.assign(this, props);
    }
}
class ServerError extends Error {
    response;
    statusCode = 500;
    responseBody;
    details;
    constructor(res){
        const props = extractErrorProps(res);
        super(props.message), Object.assign(this, props);
    }
}
function extractErrorProps(res) {
    const body = res.body, props = {
        response: res,
        statusCode: res.statusCode,
        responseBody: stringifyBody(body, res),
        message: "",
        details: void 0
    };
    if (body.error && body.message) return props.message = `${body.error} - ${body.message}`, props;
    if (isMutationError(body) || isActionError(body)) {
        const allItems = body.error.items || [], items = allItems.slice(0, 5).map((item)=>item.error?.description).filter(Boolean);
        let itemsStr = items.length ? `:
- ${items.join(`
- `)}` : "";
        return allItems.length > 5 && (itemsStr += `
...and ${allItems.length - 5} more`), props.message = `${body.error.description}${itemsStr}`, props.details = body.error, props;
    }
    return body.error && body.error.description ? (props.message = body.error.description, props.details = body.error, props) : (props.message = body.error || body.message || httpErrorMessage(res), props);
}
function isMutationError(body) {
    return isPlainObject(body) && isPlainObject(body.error) && body.error.type === "mutationError" && typeof body.error.description == "string";
}
function isActionError(body) {
    return isPlainObject(body) && isPlainObject(body.error) && body.error.type === "actionError" && typeof body.error.description == "string";
}
function isPlainObject(obj) {
    return typeof obj == "object" && obj !== null && !Array.isArray(obj);
}
function httpErrorMessage(res) {
    const statusMessage = res.statusMessage ? ` ${res.statusMessage}` : "";
    return `${res.method}-request to ${res.url} resulted in HTTP ${res.statusCode}${statusMessage}`;
}
function stringifyBody(body, res) {
    return (res.headers["content-type"] || "").toLowerCase().indexOf("application/json") !== -1 ? JSON.stringify(body, null, 2) : body;
}
class CorsOriginError extends Error {
    projectId;
    addOriginUrl;
    constructor({ projectId: projectId2 }){
        super("CorsOriginError"), this.name = "CorsOriginError", this.projectId = projectId2;
        const url = new URL(`https://sanity.io/manage/project/${projectId2}/api`);
        if (typeof location < "u") {
            const { origin } = location;
            url.searchParams.set("cors", "add"), url.searchParams.set("origin", origin), this.addOriginUrl = url, this.message = `The current origin is not allowed to connect to the Live Content API. Add it here: ${url}`;
        } else this.message = `The current origin is not allowed to connect to the Live Content API. Change your configuration here: ${url}`;
    }
}
const httpError = {
    onResponse: (res)=>{
        if (res.statusCode >= 500) throw new ServerError(res);
        if (res.statusCode >= 400) throw new ClientError(res);
        return res;
    }
};
function printWarnings() {
    const seen = {};
    return {
        onResponse: (res)=>{
            const warn = res.headers["x-sanity-warning"], warnings = Array.isArray(warn) ? warn : [
                warn
            ];
            for (const msg of warnings)!msg || seen[msg] || (seen[msg] = !0, console.warn(msg));
            return res;
        }
    };
}
function defineHttpRequest(envMiddleware2) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$it$2f$dist$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getIt"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$it$2f$dist$2f$middleware$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["retry"])({
            shouldRetry
        }),
        ...envMiddleware2,
        printWarnings(),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$it$2f$dist$2f$middleware$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["jsonRequest"])(),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$it$2f$dist$2f$middleware$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["jsonResponse"])(),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$it$2f$dist$2f$middleware$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["progress"])(),
        httpError,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$it$2f$dist$2f$middleware$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["observable"])({
            implementation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"]
        })
    ]);
}
function shouldRetry(err, attempt, options) {
    if (options.maxRetries === 0) return !1;
    const isSafe = options.method === "GET" || options.method === "HEAD", isQuery = (options.uri || options.url).startsWith("/data/query"), isRetriableResponse = err.response && (err.response.statusCode === 429 || err.response.statusCode === 502 || err.response.statusCode === 503);
    return (isSafe || isQuery) && isRetriableResponse ? !0 : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$it$2f$dist$2f$middleware$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["retry"].shouldRetry(err, attempt, options);
}
const BASE_URL = "https://www.sanity.io/help/";
function generateHelpUrl(slug) {
    return BASE_URL + slug;
}
const VALID_ASSET_TYPES = [
    "image",
    "file"
], VALID_INSERT_LOCATIONS = [
    "before",
    "after",
    "replace"
], dataset = (name)=>{
    if (!/^(~[a-z0-9]{1}[-\w]{0,63}|[a-z0-9]{1}[-\w]{0,63})$/.test(name)) throw new Error("Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters");
}, projectId = (id)=>{
    if (!/^[-a-z0-9]+$/i.test(id)) throw new Error("`projectId` can only contain only a-z, 0-9 and dashes");
}, validateAssetType = (type)=>{
    if (VALID_ASSET_TYPES.indexOf(type) === -1) throw new Error(`Invalid asset type: ${type}. Must be one of ${VALID_ASSET_TYPES.join(", ")}`);
}, validateObject = (op, val)=>{
    if (val === null || typeof val != "object" || Array.isArray(val)) throw new Error(`${op}() takes an object of properties`);
}, validateDocumentId = (op, id)=>{
    if (typeof id != "string" || !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(id) || id.includes("..")) throw new Error(`${op}(): "${id}" is not a valid document ID`);
}, requireDocumentId = (op, doc)=>{
    if (!doc._id) throw new Error(`${op}() requires that the document contains an ID ("_id" property)`);
    validateDocumentId(op, doc._id);
}, validateInsert = (at, selector, items)=>{
    const signature = "insert(at, selector, items)";
    if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {
        const valid = VALID_INSERT_LOCATIONS.map((loc)=>`"${loc}"`).join(", ");
        throw new Error(`${signature} takes an "at"-argument which is one of: ${valid}`);
    }
    if (typeof selector != "string") throw new Error(`${signature} takes a "selector"-argument which must be a string`);
    if (!Array.isArray(items)) throw new Error(`${signature} takes an "items"-argument which must be an array`);
}, hasDataset = (config)=>{
    if (!config.dataset) throw new Error("`dataset` must be provided to perform queries");
    return config.dataset || "";
}, requestTag = (tag)=>{
    if (typeof tag != "string" || !/^[a-z0-9._-]{1,75}$/i.test(tag)) throw new Error("Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.");
    return tag;
};
function once(fn) {
    let didCall = !1, returnValue;
    return (...args)=>(didCall || (returnValue = fn(...args), didCall = !0), returnValue);
}
const createWarningPrinter = (message)=>// eslint-disable-next-line no-console
    once((...args)=>console.warn(message.join(" "), ...args)), printCdnAndWithCredentialsWarning = createWarningPrinter([
    "Because you set `withCredentials` to true, we will override your `useCdn`",
    "setting to be false since (cookie-based) credentials are never set on the CDN"
]), printCdnWarning = createWarningPrinter([
    "Since you haven't set a value for `useCdn`, we will deliver content using our",
    "global, edge-cached API-CDN. If you wish to have content delivered faster, set",
    "`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API."
]), printCdnPreviewDraftsWarning = createWarningPrinter([
    "The Sanity client is configured with the `perspective` set to `drafts` or `previewDrafts`, which doesn't support the API-CDN.",
    "The Live API will be used instead. Set `useCdn: false` in your configuration to hide this warning."
]), printPreviewDraftsDeprecationWarning = createWarningPrinter([
    "The `previewDrafts` perspective has been renamed to  `drafts` and will be removed in a future API version"
]), printBrowserTokenWarning = createWarningPrinter([
    "You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.",
    `See ${generateHelpUrl("js-client-browser-token")} for more information and how to hide this warning.`
]), printNoApiVersionSpecifiedWarning = createWarningPrinter([
    "Using the Sanity client without specifying an API version is deprecated.",
    `See ${generateHelpUrl("js-client-api-version")}`
]), printNoDefaultExport = createWarningPrinter([
    "The default export of @sanity/client has been deprecated. Use the named export `createClient` instead."
]), defaultCdnHost = "apicdn.sanity.io", defaultConfig = {
    apiHost: "https://api.sanity.io",
    apiVersion: "1",
    useProjectHostname: !0,
    stega: {
        enabled: !1
    }
}, LOCALHOSTS = [
    "localhost",
    "127.0.0.1",
    "0.0.0.0"
], isLocal = (host)=>LOCALHOSTS.indexOf(host) !== -1;
function validateApiVersion(apiVersion) {
    if (apiVersion === "1" || apiVersion === "X") return;
    const apiDate = new Date(apiVersion);
    if (!(/^\d{4}-\d{2}-\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0)) throw new Error("Invalid API version string, expected `1` or date in format `YYYY-MM-DD`");
}
const VALID_PERSPECTIVE = /^[a-z0-9_]+$/i;
function validateApiPerspective(perspective) {
    if (Array.isArray(perspective) && perspective.includes("raw")) throw new TypeError('Invalid API perspective value: "raw". The raw-perspective can not be combined with other perspectives');
    const invalid = (Array.isArray(perspective) ? perspective : [
        perspective
    ]).filter((perspectiveName)=>typeof perspectiveName != "string" || !VALID_PERSPECTIVE.test(perspectiveName));
    if (invalid.length > 0) {
        const formatted = invalid.map((v)=>JSON.stringify(v));
        throw new TypeError(`Invalid API perspective value${invalid.length === 1 ? "" : "s"}: ${formatted.join(", ")}, expected \`published\`, \`drafts\`, \`raw\` or a release identifier string`);
    }
}
const initConfig = (config, prevConfig)=>{
    const specifiedConfig = {
        ...prevConfig,
        ...config,
        stega: {
            ...typeof prevConfig.stega == "boolean" ? {
                enabled: prevConfig.stega
            } : prevConfig.stega || defaultConfig.stega,
            ...typeof config.stega == "boolean" ? {
                enabled: config.stega
            } : config.stega || {}
        }
    };
    specifiedConfig.apiVersion || printNoApiVersionSpecifiedWarning();
    const newConfig = {
        ...defaultConfig,
        ...specifiedConfig
    }, projectBased = newConfig.useProjectHostname;
    if (typeof Promise > "u") {
        const helpUrl = generateHelpUrl("js-client-promise-polyfill");
        throw new Error(`No native Promise-implementation found, polyfill needed - see ${helpUrl}`);
    }
    if (projectBased && !newConfig.projectId) throw new Error("Configuration must contain `projectId`");
    if (typeof newConfig.perspective < "u" && validateApiPerspective(newConfig.perspective), "encodeSourceMap" in newConfig) throw new Error("It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMap' is not supported in '@sanity/client'. Did you mean 'stega.enabled'?");
    if ("encodeSourceMapAtPath" in newConfig) throw new Error("It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMapAtPath' is not supported in '@sanity/client'. Did you mean 'stega.filter'?");
    if (typeof newConfig.stega.enabled != "boolean") throw new Error(`stega.enabled must be a boolean, received ${newConfig.stega.enabled}`);
    if (newConfig.stega.enabled && newConfig.stega.studioUrl === void 0) throw new Error("stega.studioUrl must be defined when stega.enabled is true");
    if (newConfig.stega.enabled && typeof newConfig.stega.studioUrl != "string" && typeof newConfig.stega.studioUrl != "function") throw new Error(`stega.studioUrl must be a string or a function, received ${newConfig.stega.studioUrl}`);
    const isBrowser = typeof window < "u" && window.location && window.location.hostname, isLocalhost = isBrowser && isLocal(window.location.hostname);
    isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== !0 ? printBrowserTokenWarning() : typeof newConfig.useCdn > "u" && printCdnWarning(), projectBased && projectId(newConfig.projectId), newConfig.dataset && dataset(newConfig.dataset), "requestTagPrefix" in newConfig && (newConfig.requestTagPrefix = newConfig.requestTagPrefix ? requestTag(newConfig.requestTagPrefix).replace(/\.+$/, "") : void 0), newConfig.apiVersion = `${newConfig.apiVersion}`.replace(/^v/, ""), newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost, newConfig.useCdn === !0 && newConfig.withCredentials && printCdnAndWithCredentialsWarning(), newConfig.useCdn = newConfig.useCdn !== !1 && !newConfig.withCredentials, validateApiVersion(newConfig.apiVersion);
    const hostParts = newConfig.apiHost.split("://", 2), protocol = hostParts[0], host = hostParts[1], cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;
    return newConfig.useProjectHostname ? (newConfig.url = `${protocol}://${newConfig.projectId}.${host}/v${newConfig.apiVersion}`, newConfig.cdnUrl = `${protocol}://${newConfig.projectId}.${cdnHost}/v${newConfig.apiVersion}`) : (newConfig.url = `${newConfig.apiHost}/v${newConfig.apiVersion}`, newConfig.cdnUrl = newConfig.url), newConfig;
};
class ConnectionFailedError extends Error {
    name = "ConnectionFailedError";
}
class DisconnectError extends Error {
    name = "DisconnectError";
    reason;
    constructor(message, reason, options = {}){
        super(message, options), this.reason = reason;
    }
}
class ChannelError extends Error {
    name = "ChannelError";
    data;
    constructor(message, data){
        super(message), this.data = data;
    }
}
class MessageError extends Error {
    name = "MessageError";
    data;
    constructor(message, data, options = {}){
        super(message, options), this.data = data;
    }
}
class MessageParseError extends Error {
    name = "MessageParseError";
}
const REQUIRED_EVENTS = [
    "channelError",
    "disconnect"
];
function connectEventSource(initEventSource, events) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$defer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defer"])(()=>{
        const es = initEventSource();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$isObservable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObservable"])(es) ? es : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])(es);
    }).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])((es)=>connectWithESInstance(es, events)));
}
function connectWithESInstance(es, events) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"]((observer)=>{
        const emitOpen = events.includes("open"), emitReconnect = events.includes("reconnect");
        function onError(evt) {
            if ("data" in evt) {
                const [parseError, event] = parseEvent(evt);
                observer.error(parseError ? new MessageParseError("Unable to parse EventSource error message", {
                    cause: event
                }) : new MessageError((event?.data).message, event));
                return;
            }
            es.readyState === es.CLOSED ? observer.error(new ConnectionFailedError("EventSource connection failed")) : emitReconnect && observer.next({
                type: "reconnect"
            });
        }
        function onOpen() {
            observer.next({
                type: "open"
            });
        }
        function onMessage(message) {
            const [parseError, event] = parseEvent(message);
            if (parseError) {
                observer.error(new MessageParseError("Unable to parse EventSource message", {
                    cause: parseError
                }));
                return;
            }
            if (message.type === "channelError") {
                observer.error(new ChannelError(extractErrorMessage(event?.data), event.data));
                return;
            }
            if (message.type === "disconnect") {
                observer.error(new DisconnectError(`Server disconnected client: ${event.data?.reason || "unknown error"}`));
                return;
            }
            observer.next({
                type: message.type,
                id: message.lastEventId,
                ...event.data ? {
                    data: event.data
                } : {}
            });
        }
        es.addEventListener("error", onError), emitOpen && es.addEventListener("open", onOpen);
        const cleanedEvents = [
            .../* @__PURE__ */ new Set([
                ...REQUIRED_EVENTS,
                ...events
            ])
        ].filter((type)=>type !== "error" && type !== "open" && type !== "reconnect");
        return cleanedEvents.forEach((type)=>es.addEventListener(type, onMessage)), ()=>{
            es.removeEventListener("error", onError), emitOpen && es.removeEventListener("open", onOpen), cleanedEvents.forEach((type)=>es.removeEventListener(type, onMessage)), es.close();
        };
    });
}
function parseEvent(message) {
    try {
        const data = typeof message.data == "string" && JSON.parse(message.data);
        return [
            null,
            {
                type: message.type,
                id: message.lastEventId,
                ...isEmptyObject(data) ? {} : {
                    data
                }
            }
        ];
    } catch (err) {
        return [
            err,
            null
        ];
    }
}
function extractErrorMessage(err) {
    return err.error ? err.error.description ? err.error.description : typeof err.error == "string" ? err.error : JSON.stringify(err.error, null, 2) : err.message || "Unknown listener error";
}
function isEmptyObject(data) {
    for(const _ in data)return !1;
    return !0;
}
function getSelection(sel) {
    if (typeof sel == "string") return {
        id: sel
    };
    if (Array.isArray(sel)) return {
        query: "*[_id in $ids]",
        params: {
            ids: sel
        }
    };
    if (typeof sel == "object" && sel !== null && "query" in sel && typeof sel.query == "string") return "params" in sel && typeof sel.params == "object" && sel.params !== null ? {
        query: sel.query,
        params: sel.params
    } : {
        query: sel.query
    };
    const selectionOpts = [
        "* Document ID (<docId>)",
        "* Array of document IDs",
        "* Object containing `query`"
    ].join(`
`);
    throw new Error(`Unknown selection - must be one of:

${selectionOpts}`);
}
class BasePatch {
    selection;
    operations;
    constructor(selection, operations = {}){
        this.selection = selection, this.operations = operations;
    }
    /**
   * Sets the given attributes to the document. Does NOT merge objects.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \{"nested.prop": "value"\}
   */ set(attrs) {
        return this._assign("set", attrs);
    }
    /**
   * Sets the given attributes to the document if they are not currently set. Does NOT merge objects.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \{"nested.prop": "value"\}
   */ setIfMissing(attrs) {
        return this._assign("setIfMissing", attrs);
    }
    /**
   * Performs a "diff-match-patch" operation on the string attributes provided.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs - Attributes to perform operation on. To set a deep attribute, use JSONMatch, eg: \{"nested.prop": "dmp"\}
   */ diffMatchPatch(attrs) {
        return validateObject("diffMatchPatch", attrs), this._assign("diffMatchPatch", attrs);
    }
    /**
   * Unsets the attribute paths provided.
   * The operation is added to the current patch, ready to be commited by `commit()`
   *
   * @param attrs - Attribute paths to unset.
   */ unset(attrs) {
        if (!Array.isArray(attrs)) throw new Error("unset(attrs) takes an array of attributes to unset, non-array given");
        return this.operations = Object.assign({}, this.operations, {
            unset: attrs
        }), this;
    }
    /**
   * Increment a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.
   *
   * @param attrs - Object of attribute paths to increment, values representing the number to increment by.
   */ inc(attrs) {
        return this._assign("inc", attrs);
    }
    /**
   * Decrement a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.
   *
   * @param attrs - Object of attribute paths to decrement, values representing the number to decrement by.
   */ dec(attrs) {
        return this._assign("dec", attrs);
    }
    /**
   * Provides methods for modifying arrays, by inserting, appending and replacing elements via a JSONPath expression.
   *
   * @param at - Location to insert at, relative to the given selector, or 'replace' the matched path
   * @param selector - JSONPath expression, eg `comments[-1]` or `blocks[_key=="abc123"]`
   * @param items - Array of items to insert/replace
   */ insert(at, selector, items) {
        return validateInsert(at, selector, items), this._assign("insert", {
            [at]: selector,
            items
        });
    }
    /**
   * Append the given items to the array at the given JSONPath
   *
   * @param selector - Attribute/path to append to, eg `comments` or `person.hobbies`
   * @param items - Array of items to append to the array
   */ append(selector, items) {
        return this.insert("after", `${selector}[-1]`, items);
    }
    /**
   * Prepend the given items to the array at the given JSONPath
   *
   * @param selector - Attribute/path to prepend to, eg `comments` or `person.hobbies`
   * @param items - Array of items to prepend to the array
   */ prepend(selector, items) {
        return this.insert("before", `${selector}[0]`, items);
    }
    /**
   * Change the contents of an array by removing existing elements and/or adding new elements.
   *
   * @param selector - Attribute or JSONPath expression for array
   * @param start - Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.x
   * @param deleteCount - An integer indicating the number of old array elements to remove.
   * @param items - The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.
   */ splice(selector, start, deleteCount, items) {
        const delAll = typeof deleteCount > "u" || deleteCount === -1, startIndex = start < 0 ? start - 1 : start, delCount = delAll ? -1 : Math.max(0, start + deleteCount), delRange = startIndex < 0 && delCount >= 0 ? "" : delCount, rangeSelector = `${selector}[${startIndex}:${delRange}]`;
        return this.insert("replace", rangeSelector, items || []);
    }
    /**
   * Adds a revision clause, preventing the document from being patched if the `_rev` property does not match the given value
   *
   * @param rev - Revision to lock the patch to
   */ ifRevisionId(rev) {
        return this.operations.ifRevisionID = rev, this;
    }
    /**
   * Return a plain JSON representation of the patch
   */ serialize() {
        return {
            ...getSelection(this.selection),
            ...this.operations
        };
    }
    /**
   * Return a plain JSON representation of the patch
   */ toJSON() {
        return this.serialize();
    }
    /**
   * Clears the patch of all operations
   */ reset() {
        return this.operations = {}, this;
    }
    _assign(op, props, merge2 = !0) {
        return validateObject(op, props), this.operations = Object.assign({}, this.operations, {
            [op]: Object.assign({}, merge2 && this.operations[op] || {}, props)
        }), this;
    }
    _set(op, props) {
        return this._assign(op, props, !1);
    }
}
class ObservablePatch extends BasePatch {
    #client;
    constructor(selection, operations, client){
        super(selection, operations), this.#client = client;
    }
    /**
   * Clones the patch
   */ clone() {
        return new ObservablePatch(this.selection, {
            ...this.operations
        }, this.#client);
    }
    commit(options) {
        if (!this.#client) throw new Error("No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method");
        const returnFirst = typeof this.selection == "string", opts = Object.assign({
            returnFirst,
            returnDocuments: !0
        }, options);
        return this.#client.mutate({
            patch: this.serialize()
        }, opts);
    }
}
class Patch extends BasePatch {
    #client;
    constructor(selection, operations, client){
        super(selection, operations), this.#client = client;
    }
    /**
   * Clones the patch
   */ clone() {
        return new Patch(this.selection, {
            ...this.operations
        }, this.#client);
    }
    commit(options) {
        if (!this.#client) throw new Error("No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method");
        const returnFirst = typeof this.selection == "string", opts = Object.assign({
            returnFirst,
            returnDocuments: !0
        }, options);
        return this.#client.mutate({
            patch: this.serialize()
        }, opts);
    }
}
const defaultMutateOptions = {
    returnDocuments: !1
};
class BaseTransaction {
    operations;
    trxId;
    constructor(operations = [], transactionId){
        this.operations = operations, this.trxId = transactionId;
    }
    /**
   * Creates a new Sanity document. If `_id` is provided and already exists, the mutation will fail. If no `_id` is given, one will automatically be generated by the database.
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param doc - Document to create. Requires a `_type` property.
   */ create(doc) {
        return validateObject("create", doc), this._add({
            create: doc
        });
    }
    /**
   * Creates a new Sanity document. If a document with the same `_id` already exists, the create operation will be ignored.
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param doc - Document to create if it does not already exist. Requires `_id` and `_type` properties.
   */ createIfNotExists(doc) {
        const op = "createIfNotExists";
        return validateObject(op, doc), requireDocumentId(op, doc), this._add({
            [op]: doc
        });
    }
    /**
   * Creates a new Sanity document, or replaces an existing one if the same `_id` is already used.
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param doc - Document to create or replace. Requires `_id` and `_type` properties.
   */ createOrReplace(doc) {
        const op = "createOrReplace";
        return validateObject(op, doc), requireDocumentId(op, doc), this._add({
            [op]: doc
        });
    }
    /**
   * Deletes the document with the given document ID
   * The operation is added to the current transaction, ready to be commited by `commit()`
   *
   * @param documentId - Document ID to delete
   */ delete(documentId) {
        return validateDocumentId("delete", documentId), this._add({
            delete: {
                id: documentId
            }
        });
    }
    transactionId(id) {
        return id ? (this.trxId = id, this) : this.trxId;
    }
    /**
   * Return a plain JSON representation of the transaction
   */ serialize() {
        return [
            ...this.operations
        ];
    }
    /**
   * Return a plain JSON representation of the transaction
   */ toJSON() {
        return this.serialize();
    }
    /**
   * Clears the transaction of all operations
   */ reset() {
        return this.operations = [], this;
    }
    _add(mut) {
        return this.operations.push(mut), this;
    }
}
class Transaction extends BaseTransaction {
    #client;
    constructor(operations, client, transactionId){
        super(operations, transactionId), this.#client = client;
    }
    /**
   * Clones the transaction
   */ clone() {
        return new Transaction([
            ...this.operations
        ], this.#client, this.trxId);
    }
    commit(options) {
        if (!this.#client) throw new Error("No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method");
        return this.#client.mutate(this.serialize(), Object.assign({
            transactionId: this.trxId
        }, defaultMutateOptions, options || {}));
    }
    patch(patchOrDocumentId, patchOps) {
        const isBuilder = typeof patchOps == "function", isPatch = typeof patchOrDocumentId != "string" && patchOrDocumentId instanceof Patch, isMutationSelection = typeof patchOrDocumentId == "object" && ("query" in patchOrDocumentId || "id" in patchOrDocumentId);
        if (isPatch) return this._add({
            patch: patchOrDocumentId.serialize()
        });
        if (isBuilder) {
            const patch = patchOps(new Patch(patchOrDocumentId, {}, this.#client));
            if (!(patch instanceof Patch)) throw new Error("function passed to `patch()` must return the patch");
            return this._add({
                patch: patch.serialize()
            });
        }
        if (isMutationSelection) {
            const patch = new Patch(patchOrDocumentId, patchOps || {}, this.#client);
            return this._add({
                patch: patch.serialize()
            });
        }
        return this._add({
            patch: {
                id: patchOrDocumentId,
                ...patchOps
            }
        });
    }
}
class ObservableTransaction extends BaseTransaction {
    #client;
    constructor(operations, client, transactionId){
        super(operations, transactionId), this.#client = client;
    }
    /**
   * Clones the transaction
   */ clone() {
        return new ObservableTransaction([
            ...this.operations
        ], this.#client, this.trxId);
    }
    commit(options) {
        if (!this.#client) throw new Error("No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method");
        return this.#client.mutate(this.serialize(), Object.assign({
            transactionId: this.trxId
        }, defaultMutateOptions, options || {}));
    }
    patch(patchOrDocumentId, patchOps) {
        const isBuilder = typeof patchOps == "function";
        if (typeof patchOrDocumentId != "string" && patchOrDocumentId instanceof ObservablePatch) return this._add({
            patch: patchOrDocumentId.serialize()
        });
        if (isBuilder) {
            const patch = patchOps(new ObservablePatch(patchOrDocumentId, {}, this.#client));
            if (!(patch instanceof ObservablePatch)) throw new Error("function passed to `patch()` must return the patch");
            return this._add({
                patch: patch.serialize()
            });
        }
        return this._add({
            patch: {
                id: patchOrDocumentId,
                ...patchOps
            }
        });
    }
}
const projectHeader = "X-Sanity-Project-ID";
function requestOptions(config, overrides = {}) {
    const headers = {}, token = overrides.token || config.token;
    token && (headers.Authorization = `Bearer ${token}`), !overrides.useGlobalApi && !config.useProjectHostname && config.projectId && (headers[projectHeader] = config.projectId);
    const withCredentials = !!(typeof overrides.withCredentials > "u" ? config.token || config.withCredentials : overrides.withCredentials), timeout = typeof overrides.timeout > "u" ? config.timeout : overrides.timeout;
    return Object.assign({}, overrides, {
        headers: Object.assign({}, headers, overrides.headers || {}),
        timeout: typeof timeout > "u" ? 5 * 60 * 1e3 : timeout,
        proxy: overrides.proxy || config.proxy,
        json: !0,
        withCredentials,
        fetch: typeof overrides.fetch == "object" && typeof config.fetch == "object" ? {
            ...config.fetch,
            ...overrides.fetch
        } : overrides.fetch || config.fetch
    });
}
const encodeQueryString = ({ query, params = {}, options = {} })=>{
    const searchParams = new URLSearchParams(), { tag, includeMutations, returnQuery, ...opts } = options;
    tag && searchParams.append("tag", tag), searchParams.append("query", query);
    for (const [key, value] of Object.entries(params))searchParams.append(`$${key}`, JSON.stringify(value));
    for (const [key, value] of Object.entries(opts))value && searchParams.append(key, `${value}`);
    return returnQuery === !1 && searchParams.append("returnQuery", "false"), includeMutations === !1 && searchParams.append("includeMutations", "false"), `?${searchParams}`;
}, excludeFalsey = (param, defValue)=>param === !1 ? void 0 : typeof param > "u" ? defValue : param, getMutationQuery = (options = {})=>({
        dryRun: options.dryRun,
        returnIds: !0,
        returnDocuments: excludeFalsey(options.returnDocuments, !0),
        visibility: options.visibility || "sync",
        autoGenerateArrayKeys: options.autoGenerateArrayKeys,
        skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation
    }), isResponse = (event)=>event.type === "response", getBody = (event)=>event.body, indexBy = (docs, attr)=>docs.reduce((indexed, doc)=>(indexed[attr(doc)] = doc, indexed), /* @__PURE__ */ Object.create(null)), getQuerySizeLimit = 11264;
function _fetch(client, httpRequest, _stega, query, _params = {}, options = {}) {
    const stega = "stega" in options ? {
        ..._stega || {},
        ...typeof options.stega == "boolean" ? {
            enabled: options.stega
        } : options.stega || {}
    } : _stega, params = stega.enabled ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$stegaClean$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stegaClean"])(_params) : _params, mapResponse = options.filterResponse === !1 ? (res)=>res : (res)=>res.result, { cache, next, ...opts } = {
        // Opt out of setting a `signal` on an internal `fetch` if one isn't provided.
        // This is necessary in React Server Components to avoid opting out of Request Memoization.
        useAbortSignal: typeof options.signal < "u",
        // Set `resultSourceMap' when stega is enabled, as it's required for encoding.
        resultSourceMap: stega.enabled ? "withKeyArraySelector" : options.resultSourceMap,
        ...options,
        // Default to not returning the query, unless `filterResponse` is `false`,
        // or `returnQuery` is explicitly set. `true` is the default in Content Lake, so skip if truthy
        returnQuery: options.filterResponse === !1 && options.returnQuery !== !1
    }, reqOpts = typeof cache < "u" || typeof next < "u" ? {
        ...opts,
        fetch: {
            cache,
            next
        }
    } : opts, $request = _dataRequest(client, httpRequest, "query", {
        query,
        params
    }, reqOpts);
    return stega.enabled ? $request.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$combineLatestWith$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combineLatestWith"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(__turbopack_context__.r("[project]/node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js [app-client] (ecmascript, async loader)")(__turbopack_context__.i).then(function(n) {
        return n.stegaEncodeSourceMap$1;
    }).then(({ stegaEncodeSourceMap })=>stegaEncodeSourceMap))), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(([res, stegaEncodeSourceMap])=>{
        const result = stegaEncodeSourceMap(res.result, res.resultSourceMap, stega);
        return mapResponse({
            ...res,
            result
        });
    })) : $request.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(mapResponse));
}
function _getDocument(client, httpRequest, id, opts = {}) {
    const options = {
        uri: _getDataUrl(client, "doc", id),
        json: !0,
        tag: opts.tag,
        signal: opts.signal
    };
    return _requestObservable(client, httpRequest, options).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])(isResponse), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])((event)=>event.body.documents && event.body.documents[0]));
}
function _getDocuments(client, httpRequest, ids, opts = {}) {
    const options = {
        uri: _getDataUrl(client, "doc", ids.join(",")),
        json: !0,
        tag: opts.tag,
        signal: opts.signal
    };
    return _requestObservable(client, httpRequest, options).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])(isResponse), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])((event)=>{
        const indexed = indexBy(event.body.documents || [], (doc)=>doc._id);
        return ids.map((id)=>indexed[id] || null);
    }));
}
function _createIfNotExists(client, httpRequest, doc, options) {
    return requireDocumentId("createIfNotExists", doc), _create(client, httpRequest, doc, "createIfNotExists", options);
}
function _createOrReplace(client, httpRequest, doc, options) {
    return requireDocumentId("createOrReplace", doc), _create(client, httpRequest, doc, "createOrReplace", options);
}
function _delete(client, httpRequest, selection, options) {
    return _dataRequest(client, httpRequest, "mutate", {
        mutations: [
            {
                delete: getSelection(selection)
            }
        ]
    }, options);
}
function _mutate(client, httpRequest, mutations, options) {
    let mut;
    mutations instanceof Patch || mutations instanceof ObservablePatch ? mut = {
        patch: mutations.serialize()
    } : mutations instanceof Transaction || mutations instanceof ObservableTransaction ? mut = mutations.serialize() : mut = mutations;
    const muts = Array.isArray(mut) ? mut : [
        mut
    ], transactionId = options && options.transactionId || void 0;
    return _dataRequest(client, httpRequest, "mutate", {
        mutations: muts,
        transactionId
    }, options);
}
function _action(client, httpRequest, actions, options) {
    const acts = Array.isArray(actions) ? actions : [
        actions
    ], transactionId = options && options.transactionId || void 0, skipCrossDatasetReferenceValidation = options && options.skipCrossDatasetReferenceValidation || void 0, dryRun = options && options.dryRun || void 0;
    return _dataRequest(client, httpRequest, "actions", {
        actions: acts,
        transactionId,
        skipCrossDatasetReferenceValidation,
        dryRun
    }, options);
}
function _dataRequest(client, httpRequest, endpoint, body, options = {}) {
    const isMutation = endpoint === "mutate", isAction = endpoint === "actions", isQuery = endpoint === "query", strQuery = isMutation || isAction ? "" : encodeQueryString(body), useGet = !isMutation && !isAction && strQuery.length < getQuerySizeLimit, stringQuery = useGet ? strQuery : "", returnFirst = options.returnFirst, { timeout, token, tag, headers, returnQuery, lastLiveEventId, cacheMode } = options, uri = _getDataUrl(client, endpoint, stringQuery), reqOptions = {
        method: useGet ? "GET" : "POST",
        uri,
        json: !0,
        body: useGet ? void 0 : body,
        query: isMutation && getMutationQuery(options),
        timeout,
        headers,
        token,
        tag,
        returnQuery,
        perspective: options.perspective,
        resultSourceMap: options.resultSourceMap,
        lastLiveEventId: Array.isArray(lastLiveEventId) ? lastLiveEventId[0] : lastLiveEventId,
        cacheMode,
        canUseCdn: isQuery,
        signal: options.signal,
        fetch: options.fetch,
        useAbortSignal: options.useAbortSignal,
        useCdn: options.useCdn
    };
    return _requestObservable(client, httpRequest, reqOptions).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])(isResponse), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(getBody), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])((res)=>{
        if (!isMutation) return res;
        const results = res.results || [];
        if (options.returnDocuments) return returnFirst ? results[0] && results[0].document : results.map((mut)=>mut.document);
        const key = returnFirst ? "documentId" : "documentIds", ids = returnFirst ? results[0] && results[0].id : results.map((mut)=>mut.id);
        return {
            transactionId: res.transactionId,
            results,
            [key]: ids
        };
    }));
}
function _create(client, httpRequest, doc, op, options = {}) {
    const mutation = {
        [op]: doc
    }, opts = Object.assign({
        returnFirst: !0,
        returnDocuments: !0
    }, options);
    return _dataRequest(client, httpRequest, "mutate", {
        mutations: [
            mutation
        ]
    }, opts);
}
function _requestObservable(client, httpRequest, options) {
    const uri = options.url || options.uri, config = client.config(), canUseCdn = typeof options.canUseCdn > "u" ? [
        "GET",
        "HEAD"
    ].indexOf(options.method || "GET") >= 0 && uri.indexOf("/data/") === 0 : options.canUseCdn;
    let useCdn = (options.useCdn ?? config.useCdn) && canUseCdn;
    const tag = options.tag && config.requestTagPrefix ? [
        config.requestTagPrefix,
        options.tag
    ].join(".") : options.tag || config.requestTagPrefix;
    if (tag && options.tag !== null && (options.query = {
        tag: requestTag(tag),
        ...options.query
    }), [
        "GET",
        "HEAD",
        "POST"
    ].indexOf(options.method || "GET") >= 0 && uri.indexOf("/data/query/") === 0) {
        const resultSourceMap = options.resultSourceMap ?? config.resultSourceMap;
        resultSourceMap !== void 0 && resultSourceMap !== !1 && (options.query = {
            resultSourceMap,
            ...options.query
        });
        const perspectiveOption = options.perspective || config.perspective;
        typeof perspectiveOption < "u" && (perspectiveOption === "previewDrafts" && printPreviewDraftsDeprecationWarning(), validateApiPerspective(perspectiveOption), options.query = {
            perspective: Array.isArray(perspectiveOption) ? perspectiveOption.join(",") : perspectiveOption,
            ...options.query
        }, (Array.isArray(perspectiveOption) && perspectiveOption.length > 0 || // previewDrafts was renamed to drafts, but keep for backwards compat
        perspectiveOption === "previewDrafts" || perspectiveOption === "drafts") && useCdn && (useCdn = !1, printCdnPreviewDraftsWarning())), options.lastLiveEventId && (options.query = {
            ...options.query,
            lastLiveEventId: options.lastLiveEventId
        }), options.returnQuery === !1 && (options.query = {
            returnQuery: "false",
            ...options.query
        }), useCdn && options.cacheMode == "noStale" && (options.query = {
            cacheMode: "noStale",
            ...options.query
        });
    }
    const reqOptions = requestOptions(config, Object.assign({}, options, {
        url: _getUrl(client, uri, useCdn)
    })), request = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"]((subscriber)=>httpRequest(reqOptions, config.requester).subscribe(subscriber));
    return options.signal ? request.pipe(_withAbortSignal(options.signal)) : request;
}
function _request(client, httpRequest, options) {
    return _requestObservable(client, httpRequest, options).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])((event)=>event.type === "response"), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])((event)=>event.body));
}
function _getDataUrl(client, operation, path) {
    const config = client.config(), catalog = hasDataset(config), baseUri = `/${operation}/${catalog}`;
    return `/data${path ? `${baseUri}/${path}` : baseUri}`.replace(/\/($|\?)/, "$1");
}
function _getUrl(client, uri, canUseCdn = !1) {
    const { url, cdnUrl } = client.config();
    return `${canUseCdn ? cdnUrl : url}/${uri.replace(/^\//, "")}`;
}
function _withAbortSignal(signal) {
    return (input)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"]((observer)=>{
            const abort = ()=>observer.error(_createAbortError(signal));
            if (signal && signal.aborted) {
                abort();
                return;
            }
            const subscription = input.subscribe(observer);
            return signal.addEventListener("abort", abort), ()=>{
                signal.removeEventListener("abort", abort), subscription.unsubscribe();
            };
        });
}
const isDomExceptionSupported = !!globalThis.DOMException;
function _createAbortError(signal) {
    if (isDomExceptionSupported) return new DOMException(signal?.reason ?? "The operation was aborted.", "AbortError");
    const error = new Error(signal?.reason ?? "The operation was aborted.");
    return error.name = "AbortError", error;
}
class ObservableAssetsClient {
    #client;
    #httpRequest;
    constructor(client, httpRequest){
        this.#client = client, this.#httpRequest = httpRequest;
    }
    upload(assetType, body, options) {
        return _upload(this.#client, this.#httpRequest, assetType, body, options);
    }
}
class AssetsClient {
    #client;
    #httpRequest;
    constructor(client, httpRequest){
        this.#client = client, this.#httpRequest = httpRequest;
    }
    upload(assetType, body, options) {
        const observable2 = _upload(this.#client, this.#httpRequest, assetType, body, options);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(observable2.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])((event)=>event.type === "response"), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])((event)=>event.body.document)));
    }
}
function _upload(client, httpRequest, assetType, body, opts = {}) {
    validateAssetType(assetType);
    let meta = opts.extract || void 0;
    meta && !meta.length && (meta = [
        "none"
    ]);
    const dataset2 = hasDataset(client.config()), assetEndpoint = assetType === "image" ? "images" : "files", options = optionsFromFile(opts, body), { tag, label, title, description, creditLine, filename, source } = options, query = {
        label,
        title,
        description,
        filename,
        meta,
        creditLine
    };
    return source && (query.sourceId = source.id, query.sourceName = source.name, query.sourceUrl = source.url), _requestObservable(client, httpRequest, {
        tag,
        method: "POST",
        timeout: options.timeout || 0,
        uri: `/assets/${assetEndpoint}/${dataset2}`,
        headers: options.contentType ? {
            "Content-Type": options.contentType
        } : {},
        query,
        body
    });
}
function optionsFromFile(opts, file) {
    return typeof File > "u" || !(file instanceof File) ? opts : Object.assign({
        filename: opts.preserveFilename === !1 ? void 0 : file.name,
        contentType: file.type
    }, opts);
}
var defaults = (obj, defaults2)=>Object.keys(defaults2).concat(Object.keys(obj)).reduce((target, prop)=>(target[prop] = typeof obj[prop] > "u" ? defaults2[prop] : obj[prop], target), {});
const pick = (obj, props)=>props.reduce((selection, prop)=>(typeof obj[prop] > "u" || (selection[prop] = obj[prop]), selection), {}), eventSourcePolyfill = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$defer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defer"])(()=>__turbopack_context__.r("[project]/node_modules/@sanity/eventsource/browser.js [app-client] (ecmascript, async loader)")(__turbopack_context__.i)).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(({ default: EventSource2 })=>EventSource2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shareReplay"])(1));
function reconnectOnConnectionFailure() {
    return function(source) {
        return source.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$catchError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["catchError"])((err, caught)=>err instanceof ConnectionFailedError ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])({
                type: "reconnect"
            }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$timer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timer"])(1e3).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(()=>caught))) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$throwError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwError"])(()=>err)));
    };
}
const MAX_URL_LENGTH = 14800, possibleOptions = [
    "includePreviousRevision",
    "includeResult",
    "includeMutations",
    "includeAllVersions",
    "visibility",
    "effectFormat",
    "tag"
], defaultOptions = {
    includeResult: !0
};
function _listen(query, params, opts = {}) {
    const { url, token, withCredentials, requestTagPrefix } = this.config(), tag = opts.tag && requestTagPrefix ? [
        requestTagPrefix,
        opts.tag
    ].join(".") : opts.tag, options = {
        ...defaults(opts, defaultOptions),
        tag
    }, listenOpts = pick(options, possibleOptions), qs = encodeQueryString({
        query,
        params,
        options: {
            tag,
            ...listenOpts
        }
    }), uri = `${url}${_getDataUrl(this, "listen", qs)}`;
    if (uri.length > MAX_URL_LENGTH) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$throwError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwError"])(()=>new Error("Query too large for listener"));
    const listenFor = options.events ? options.events : [
        "mutation"
    ], esOptions = {};
    return (token || withCredentials) && (esOptions.withCredentials = !0), token && (esOptions.headers = {
        Authorization: `Bearer ${token}`
    }), connectEventSource(()=>// use polyfill if there is no global EventSource or if we need to set headers
        (typeof EventSource > "u" || esOptions.headers ? eventSourcePolyfill : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])(EventSource)).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])((EventSource2)=>new EventSource2(uri, esOptions))), listenFor).pipe(reconnectOnConnectionFailure(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])((event)=>listenFor.includes(event.type)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])((event)=>({
            type: event.type,
            ..."data" in event ? event.data : {}
        })));
}
function shareReplayLatest(configOrPredicate, config) {
    return _shareReplayLatest(typeof configOrPredicate == "function" ? {
        predicate: configOrPredicate,
        ...config
    } : configOrPredicate);
}
function _shareReplayLatest(config) {
    return (source)=>{
        let latest, emitted = !1;
        const { predicate, ...shareConfig } = config, wrapped = source.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$tap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tap"])((value)=>{
            config.predicate(value) && (emitted = !0, latest = value);
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$finalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finalize"])(()=>{
            emitted = !1, latest = void 0;
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$share$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["share"])(shareConfig)), emitLatest = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"]((subscriber)=>{
            emitted && subscriber.next(latest), subscriber.complete();
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])(wrapped, emitLatest);
    };
}
const requiredApiVersion = "2021-03-25";
class LiveClient {
    #client;
    constructor(client){
        this.#client = client;
    }
    /**
   * Requires `apiVersion` to be `2021-03-25` or later.
   */ events({ includeDrafts = !1, tag: _tag } = {}) {
        const { projectId: projectId2, apiVersion: _apiVersion, token, withCredentials, requestTagPrefix } = this.#client.config(), apiVersion = _apiVersion.replace(/^v/, "");
        if (apiVersion !== "X" && apiVersion < requiredApiVersion) throw new Error(`The live events API requires API version ${requiredApiVersion} or later. The current API version is ${apiVersion}. Please update your API version to use this feature.`);
        if (includeDrafts && !token && !withCredentials) throw new Error("The live events API requires a token or withCredentials when 'includeDrafts: true'. Please update your client configuration. The token should have the lowest possible access role.");
        const path = _getDataUrl(this.#client, "live/events"), url = new URL(this.#client.getUrl(path, !1)), tag = _tag && requestTagPrefix ? [
            requestTagPrefix,
            _tag
        ].join(".") : _tag;
        tag && url.searchParams.set("tag", tag), includeDrafts && url.searchParams.set("includeDrafts", "true");
        const esOptions = {};
        includeDrafts && token && (esOptions.headers = {
            Authorization: `Bearer ${token}`
        }), includeDrafts && withCredentials && (esOptions.withCredentials = !0);
        const key = `${url.href}::${JSON.stringify(esOptions)}`, existing = eventsCache.get(key);
        if (existing) return existing;
        const events = connectEventSource(()=>// use polyfill if there is no global EventSource or if we need to set headers
            (typeof EventSource > "u" || esOptions.headers ? eventSourcePolyfill : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])(EventSource)).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])((EventSource2)=>new EventSource2(url.href, esOptions))), [
            "message",
            "restart",
            "welcome",
            "reconnect"
        ]).pipe(reconnectOnConnectionFailure(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])((event)=>{
            if (event.type === "message") {
                const { data, ...rest } = event;
                return {
                    ...rest,
                    tags: data.tags
                };
            }
            return event;
        })), checkCors = fetchObservable(url, {
            method: "OPTIONS",
            mode: "cors",
            credentials: esOptions.withCredentials ? "include" : "omit",
            headers: esOptions.headers
        }).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$catchError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["catchError"])(()=>{
            throw new CorsOriginError({
                projectId: projectId2
            });
        })), observable2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])(checkCors, events).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$finalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finalize"])(()=>eventsCache.delete(key)), shareReplayLatest({
            predicate: (event)=>event.type === "welcome"
        }));
        return eventsCache.set(key, observable2), observable2;
    }
}
function fetchObservable(url, init) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"]((observer)=>{
        const controller = new AbortController(), signal = controller.signal;
        return fetch(url, {
            ...init,
            signal: controller.signal
        }).then((response)=>{
            observer.next(response), observer.complete();
        }, (err)=>{
            signal.aborted || observer.error(err);
        }), ()=>controller.abort();
    });
}
const eventsCache = /* @__PURE__ */ new Map();
class ObservableDatasetsClient {
    #client;
    #httpRequest;
    constructor(client, httpRequest){
        this.#client = client, this.#httpRequest = httpRequest;
    }
    /**
   * Create a new dataset with the given name
   *
   * @param name - Name of the dataset to create
   * @param options - Options for the dataset
   */ create(name, options) {
        return _modify(this.#client, this.#httpRequest, "PUT", name, options);
    }
    /**
   * Edit a dataset with the given name
   *
   * @param name - Name of the dataset to edit
   * @param options - New options for the dataset
   */ edit(name, options) {
        return _modify(this.#client, this.#httpRequest, "PATCH", name, options);
    }
    /**
   * Delete a dataset with the given name
   *
   * @param name - Name of the dataset to delete
   */ delete(name) {
        return _modify(this.#client, this.#httpRequest, "DELETE", name);
    }
    /**
   * Fetch a list of datasets for the configured project
   */ list() {
        return _request(this.#client, this.#httpRequest, {
            uri: "/datasets",
            tag: null
        });
    }
}
class DatasetsClient {
    #client;
    #httpRequest;
    constructor(client, httpRequest){
        this.#client = client, this.#httpRequest = httpRequest;
    }
    /**
   * Create a new dataset with the given name
   *
   * @param name - Name of the dataset to create
   * @param options - Options for the dataset
   */ create(name, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_modify(this.#client, this.#httpRequest, "PUT", name, options));
    }
    /**
   * Edit a dataset with the given name
   *
   * @param name - Name of the dataset to edit
   * @param options - New options for the dataset
   */ edit(name, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_modify(this.#client, this.#httpRequest, "PATCH", name, options));
    }
    /**
   * Delete a dataset with the given name
   *
   * @param name - Name of the dataset to delete
   */ delete(name) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_modify(this.#client, this.#httpRequest, "DELETE", name));
    }
    /**
   * Fetch a list of datasets for the configured project
   */ list() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_request(this.#client, this.#httpRequest, {
            uri: "/datasets",
            tag: null
        }));
    }
}
function _modify(client, httpRequest, method, name, options) {
    return dataset(name), _request(client, httpRequest, {
        method,
        uri: `/datasets/${name}`,
        body: options,
        tag: null
    });
}
class ObservableProjectsClient {
    #client;
    #httpRequest;
    constructor(client, httpRequest){
        this.#client = client, this.#httpRequest = httpRequest;
    }
    list(options) {
        const uri = options?.includeMembers === !1 ? "/projects?includeMembers=false" : "/projects";
        return _request(this.#client, this.#httpRequest, {
            uri
        });
    }
    /**
   * Fetch a project by project ID
   *
   * @param projectId - ID of the project to fetch
   */ getById(projectId2) {
        return _request(this.#client, this.#httpRequest, {
            uri: `/projects/${projectId2}`
        });
    }
}
class ProjectsClient {
    #client;
    #httpRequest;
    constructor(client, httpRequest){
        this.#client = client, this.#httpRequest = httpRequest;
    }
    list(options) {
        const uri = options?.includeMembers === !1 ? "/projects?includeMembers=false" : "/projects";
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_request(this.#client, this.#httpRequest, {
            uri
        }));
    }
    /**
   * Fetch a project by project ID
   *
   * @param projectId - ID of the project to fetch
   */ getById(projectId2) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_request(this.#client, this.#httpRequest, {
            uri: `/projects/${projectId2}`
        }));
    }
}
class ObservableUsersClient {
    #client;
    #httpRequest;
    constructor(client, httpRequest){
        this.#client = client, this.#httpRequest = httpRequest;
    }
    /**
   * Fetch a user by user ID
   *
   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.
   */ getById(id) {
        return _request(this.#client, this.#httpRequest, {
            uri: `/users/${id}`
        });
    }
}
class UsersClient {
    #client;
    #httpRequest;
    constructor(client, httpRequest){
        this.#client = client, this.#httpRequest = httpRequest;
    }
    /**
   * Fetch a user by user ID
   *
   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.
   */ getById(id) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_request(this.#client, this.#httpRequest, {
            uri: `/users/${id}`
        }));
    }
}
class ObservableSanityClient {
    assets;
    datasets;
    live;
    projects;
    users;
    /**
   * Private properties
   */ #clientConfig;
    #httpRequest;
    /**
   * Instance properties
   */ listen = _listen;
    constructor(httpRequest, config = defaultConfig){
        this.config(config), this.#httpRequest = httpRequest, this.assets = new ObservableAssetsClient(this, this.#httpRequest), this.datasets = new ObservableDatasetsClient(this, this.#httpRequest), this.live = new LiveClient(this), this.projects = new ObservableProjectsClient(this, this.#httpRequest), this.users = new ObservableUsersClient(this, this.#httpRequest);
    }
    /**
   * Clone the client - returns a new instance
   */ clone() {
        return new ObservableSanityClient(this.#httpRequest, this.config());
    }
    config(newConfig) {
        if (newConfig === void 0) return {
            ...this.#clientConfig
        };
        if (this.#clientConfig && this.#clientConfig.allowReconfigure === !1) throw new Error("Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client");
        return this.#clientConfig = initConfig(newConfig, this.#clientConfig || {}), this;
    }
    /**
   * Clone the client with a new (partial) configuration.
   *
   * @param newConfig - New client configuration properties, shallowly merged with existing configuration
   */ withConfig(newConfig) {
        const thisConfig = this.config();
        return new ObservableSanityClient(this.#httpRequest, {
            ...thisConfig,
            ...newConfig,
            stega: {
                ...thisConfig.stega || {},
                ...typeof newConfig?.stega == "boolean" ? {
                    enabled: newConfig.stega
                } : newConfig?.stega || {}
            }
        });
    }
    fetch(query, params, options) {
        return _fetch(this, this.#httpRequest, this.#clientConfig.stega, query, params, options);
    }
    /**
   * Fetch a single document with the given ID.
   *
   * @param id - Document ID to fetch
   * @param options - Request options
   */ getDocument(id, options) {
        return _getDocument(this, this.#httpRequest, id, options);
    }
    /**
   * Fetch multiple documents in one request.
   * Should be used sparingly - performing a query is usually a better option.
   * The order/position of documents is preserved based on the original array of IDs.
   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array
   *
   * @param ids - Document IDs to fetch
   * @param options - Request options
   */ getDocuments(ids, options) {
        return _getDocuments(this, this.#httpRequest, ids, options);
    }
    create(document, options) {
        return _create(this, this.#httpRequest, document, "create", options);
    }
    createIfNotExists(document, options) {
        return _createIfNotExists(this, this.#httpRequest, document, options);
    }
    createOrReplace(document, options) {
        return _createOrReplace(this, this.#httpRequest, document, options);
    }
    delete(selection, options) {
        return _delete(this, this.#httpRequest, selection, options);
    }
    mutate(operations, options) {
        return _mutate(this, this.#httpRequest, operations, options);
    }
    /**
   * Create a new buildable patch of operations to perform
   *
   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch
   * @param operations - Optional object of patch operations to initialize the patch instance with
   * @returns Patch instance - call `.commit()` to perform the operations defined
   */ patch(selection, operations) {
        return new ObservablePatch(selection, operations, this);
    }
    /**
   * Create a new transaction of mutations
   *
   * @param operations - Optional array of mutation operations to initialize the transaction instance with
   */ transaction(operations) {
        return new ObservableTransaction(operations, this);
    }
    /**
   * Perform action operations against the configured dataset
   *
   * @param operations - Action operation(s) to execute
   * @param options - Action options
   */ action(operations, options) {
        return _action(this, this.#httpRequest, operations, options);
    }
    /**
   * Perform an HTTP request against the Sanity API
   *
   * @param options - Request options
   */ request(options) {
        return _request(this, this.#httpRequest, options);
    }
    /**
   * Get a Sanity API URL for the URI provided
   *
   * @param uri - URI/path to build URL for
   * @param canUseCdn - Whether or not to allow using the API CDN for this route
   */ getUrl(uri, canUseCdn) {
        return _getUrl(this, uri, canUseCdn);
    }
    /**
   * Get a Sanity API URL for the data operation and path provided
   *
   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)
   * @param path - Path to append after the operation
   */ getDataUrl(operation, path) {
        return _getDataUrl(this, operation, path);
    }
}
class SanityClient {
    assets;
    datasets;
    live;
    projects;
    users;
    /**
   * Observable version of the Sanity client, with the same configuration as the promise-based one
   */ observable;
    /**
   * Private properties
   */ #clientConfig;
    #httpRequest;
    /**
   * Instance properties
   */ listen = _listen;
    constructor(httpRequest, config = defaultConfig){
        this.config(config), this.#httpRequest = httpRequest, this.assets = new AssetsClient(this, this.#httpRequest), this.datasets = new DatasetsClient(this, this.#httpRequest), this.live = new LiveClient(this), this.projects = new ProjectsClient(this, this.#httpRequest), this.users = new UsersClient(this, this.#httpRequest), this.observable = new ObservableSanityClient(httpRequest, config);
    }
    /**
   * Clone the client - returns a new instance
   */ clone() {
        return new SanityClient(this.#httpRequest, this.config());
    }
    config(newConfig) {
        if (newConfig === void 0) return {
            ...this.#clientConfig
        };
        if (this.#clientConfig && this.#clientConfig.allowReconfigure === !1) throw new Error("Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client");
        return this.observable && this.observable.config(newConfig), this.#clientConfig = initConfig(newConfig, this.#clientConfig || {}), this;
    }
    /**
   * Clone the client with a new (partial) configuration.
   *
   * @param newConfig - New client configuration properties, shallowly merged with existing configuration
   */ withConfig(newConfig) {
        const thisConfig = this.config();
        return new SanityClient(this.#httpRequest, {
            ...thisConfig,
            ...newConfig,
            stega: {
                ...thisConfig.stega || {},
                ...typeof newConfig?.stega == "boolean" ? {
                    enabled: newConfig.stega
                } : newConfig?.stega || {}
            }
        });
    }
    fetch(query, params, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_fetch(this, this.#httpRequest, this.#clientConfig.stega, query, params, options));
    }
    /**
   * Fetch a single document with the given ID.
   *
   * @param id - Document ID to fetch
   * @param options - Request options
   */ getDocument(id, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_getDocument(this, this.#httpRequest, id, options));
    }
    /**
   * Fetch multiple documents in one request.
   * Should be used sparingly - performing a query is usually a better option.
   * The order/position of documents is preserved based on the original array of IDs.
   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array
   *
   * @param ids - Document IDs to fetch
   * @param options - Request options
   */ getDocuments(ids, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_getDocuments(this, this.#httpRequest, ids, options));
    }
    create(document, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_create(this, this.#httpRequest, document, "create", options));
    }
    createIfNotExists(document, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_createIfNotExists(this, this.#httpRequest, document, options));
    }
    createOrReplace(document, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_createOrReplace(this, this.#httpRequest, document, options));
    }
    delete(selection, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_delete(this, this.#httpRequest, selection, options));
    }
    mutate(operations, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_mutate(this, this.#httpRequest, operations, options));
    }
    /**
   * Create a new buildable patch of operations to perform
   *
   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch
   * @param operations - Optional object of patch operations to initialize the patch instance with
   * @returns Patch instance - call `.commit()` to perform the operations defined
   */ patch(documentId, operations) {
        return new Patch(documentId, operations, this);
    }
    /**
   * Create a new transaction of mutations
   *
   * @param operations - Optional array of mutation operations to initialize the transaction instance with
   */ transaction(operations) {
        return new Transaction(operations, this);
    }
    /**
   * Perform action operations against the configured dataset
   * Returns a promise that resolves to the transaction result
   *
   * @param operations - Action operation(s) to execute
   * @param options - Action options
   */ action(operations, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_action(this, this.#httpRequest, operations, options));
    }
    /**
   * Perform a request against the Sanity API
   * NOTE: Only use this for Sanity API endpoints, not for your own APIs!
   *
   * @param options - Request options
   * @returns Promise resolving to the response body
   */ request(options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_request(this, this.#httpRequest, options));
    }
    /**
   * Perform an HTTP request a `/data` sub-endpoint
   * NOTE: Considered internal, thus marked as deprecated. Use `request` instead.
   *
   * @deprecated - Use `request()` or your own HTTP library instead
   * @param endpoint - Endpoint to hit (mutate, query etc)
   * @param body - Request body
   * @param options - Request options
   * @internal
   */ dataRequest(endpoint, body, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(_dataRequest(this, this.#httpRequest, endpoint, body, options));
    }
    /**
   * Get a Sanity API URL for the URI provided
   *
   * @param uri - URI/path to build URL for
   * @param canUseCdn - Whether or not to allow using the API CDN for this route
   */ getUrl(uri, canUseCdn) {
        return _getUrl(this, uri, canUseCdn);
    }
    /**
   * Get a Sanity API URL for the data operation and path provided
   *
   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)
   * @param path - Path to append after the operation
   */ getDataUrl(operation, path) {
        return _getDataUrl(this, operation, path);
    }
}
function defineCreateClientExports(envMiddleware2, ClassConstructor) {
    return {
        requester: defineHttpRequest(envMiddleware2),
        createClient: (config)=>{
            const clientRequester = defineHttpRequest(envMiddleware2);
            return new ClassConstructor((options, requester2)=>(requester2 || clientRequester)({
                    maxRedirects: 0,
                    maxRetries: config.maxRetries,
                    retryDelay: config.retryDelay,
                    ...options
                }), config);
        }
    };
}
function defineDeprecatedCreateClient(createClient2) {
    return function(config) {
        return printNoDefaultExport(), createClient2(config);
    };
}
var envMiddleware = [];
const exp = defineCreateClientExports(envMiddleware, SanityClient), requester = exp.requester, createClient = exp.createClient, deprecatedCreateClient = defineDeprecatedCreateClient(createClient);
;
 //# sourceMappingURL=index.browser.js.map
}}),
"[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DRAFTS_FOLDER": (()=>DRAFTS_FOLDER),
    "VERSION_FOLDER": (()=>VERSION_FOLDER),
    "createEditUrl": (()=>createEditUrl),
    "get": (()=>get),
    "getDraftId": (()=>getDraftId),
    "getPublishedId": (()=>getPublishedId),
    "getVersionFromId": (()=>getVersionFromId),
    "getVersionId": (()=>getVersionId),
    "isDraftId": (()=>isDraftId),
    "isPublishedId": (()=>isPublishedId),
    "isVersionId": (()=>isVersionId),
    "jsonPath": (()=>jsonPath),
    "jsonPathToStudioPath": (()=>jsonPathToStudioPath),
    "parseJsonPath": (()=>parseJsonPath),
    "reKeySegment": (()=>reKeySegment),
    "resolveEditInfo": (()=>resolveEditInfo),
    "resolveMapping": (()=>resolveMapping),
    "resolveStudioBaseRoute": (()=>resolveStudioBaseRoute),
    "studioPath": (()=>studioPath),
    "studioPathToJsonPath": (()=>studioPathToJsonPath),
    "toString": (()=>toString),
    "walkMap": (()=>walkMap)
});
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/, reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment == "number" || typeof segment == "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
    return typeof segment == "string" ? reKeySegment.test(segment.trim()) : typeof segment == "object" && "_key" in segment;
}
function isIndexTuple(segment) {
    if (typeof segment == "string" && reIndexTuple.test(segment)) return !0;
    if (!Array.isArray(segment) || segment.length !== 2) return !1;
    const [from, to] = segment;
    return (typeof from == "number" || from === "") && (typeof to == "number" || to === "");
}
function get(obj, path, defaultVal) {
    const select = typeof path == "string" ? fromString(path) : path;
    if (!Array.isArray(select)) throw new Error("Path must be an array or a string");
    let acc = obj;
    for(let i = 0; i < select.length; i++){
        const segment = select[i];
        if (isIndexSegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc[segment];
        }
        if (isKeySegment(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc.find((item)=>item._key === segment._key);
        }
        if (typeof segment == "string" && (acc = typeof acc == "object" && acc !== null ? acc[segment] : void 0), typeof acc > "u") return defaultVal;
    }
    return acc;
}
function toString(path) {
    if (!Array.isArray(path)) throw new Error("Path is not an array");
    return path.reduce((target, segment, i)=>{
        const segmentType = typeof segment;
        if (segmentType === "number") return `${target}[${segment}]`;
        if (segmentType === "string") return `${target}${i === 0 ? "" : "."}${segment}`;
        if (isKeySegment(segment) && segment._key) return `${target}[_key=="${segment._key}"]`;
        if (Array.isArray(segment)) {
            const [from, to] = segment;
            return `${target}[${from}:${to}]`;
        }
        throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
    }, "");
}
function fromString(path) {
    if (typeof path != "string") throw new Error("Path is not a string");
    const segments = path.match(rePropName);
    if (!segments) throw new Error("Invalid path string");
    return segments.map(parsePathSegment);
}
function parsePathSegment(segment) {
    return isIndexSegment(segment) ? parseIndexSegment(segment) : isKeySegment(segment) ? parseKeySegment(segment) : isIndexTuple(segment) ? parseIndexTupleSegment(segment) : segment;
}
function parseIndexSegment(segment) {
    return Number(segment.replace(/[^\d]/g, ""));
}
function parseKeySegment(segment) {
    return {
        _key: segment.match(reKeySegment)[1]
    };
}
function parseIndexTupleSegment(segment) {
    const [from, to] = segment.split(":").map((seg)=>seg === "" ? seg : Number(seg));
    return [
        from,
        to
    ];
}
var studioPath = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fromString,
    get,
    isIndexSegment,
    isIndexTuple,
    isKeySegment,
    reKeySegment,
    toString
});
const DRAFTS_FOLDER = "drafts", VERSION_FOLDER = "versions", PATH_SEPARATOR = ".", DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`, VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`;
function isDraftId(id) {
    return id.startsWith(DRAFTS_PREFIX);
}
function isVersionId(id) {
    return id.startsWith(VERSION_PREFIX);
}
function isPublishedId(id) {
    return !isDraftId(id) && !isVersionId(id);
}
function getDraftId(id) {
    if (isVersionId(id)) {
        const publishedId = getPublishedId(id);
        return DRAFTS_PREFIX + publishedId;
    }
    return isDraftId(id) ? id : DRAFTS_PREFIX + id;
}
function getVersionId(id, version) {
    if (version === "drafts" || version === "published") throw new Error('Version can not be "published" or "drafts"');
    return `${VERSION_PREFIX}${version}${PATH_SEPARATOR}${getPublishedId(id)}`;
}
function getVersionFromId(id) {
    if (!isVersionId(id)) return;
    const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR);
    return versionId;
}
function getPublishedId(id) {
    return isVersionId(id) ? id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) : isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id;
}
const ESCAPE = {
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "'": "\\'",
    "\\": "\\\\"
}, UNESCAPE = {
    "\\f": "\f",
    "\\n": `
`,
    "\\r": "\r",
    "\\t": "	",
    "\\'": "'",
    "\\\\": "\\"
};
function jsonPath(path) {
    return `$${path.map((segment)=>typeof segment == "string" ? `['${segment.replace(/[\f\n\r\t'\\]/g, (match)=>ESCAPE[match])}']` : typeof segment == "number" ? `[${segment}]` : segment._key !== "" ? `[?(@._key=='${segment._key.replace(/['\\]/g, (match)=>ESCAPE[match])}')]` : `[${segment._index}]`).join("")}`;
}
function parseJsonPath(path) {
    const parsed = [], parseRe = /\['(.*?)'\]|\[(\d+)\]|\[\?\(@\._key=='(.*?)'\)\]/g;
    let match;
    for(; (match = parseRe.exec(path)) !== null;){
        if (match[1] !== void 0) {
            const key = match[1].replace(/\\(\\|f|n|r|t|')/g, (m)=>UNESCAPE[m]);
            parsed.push(key);
            continue;
        }
        if (match[2] !== void 0) {
            parsed.push(parseInt(match[2], 10));
            continue;
        }
        if (match[3] !== void 0) {
            const _key = match[3].replace(/\\(\\')/g, (m)=>UNESCAPE[m]);
            parsed.push({
                _key,
                _index: -1
            });
            continue;
        }
    }
    return parsed;
}
function jsonPathToStudioPath(path) {
    return path.map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (segment._key !== "") return {
            _key: segment._key
        };
        if (segment._index !== -1) return segment._index;
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function studioPathToJsonPath(path) {
    return (typeof path == "string" ? fromString(path) : path).map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (Array.isArray(segment)) throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`);
        if (isContentSourceMapParsedPathKeyedSegment(segment)) return segment;
        if (segment._key) return {
            _key: segment._key,
            _index: -1
        };
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function isContentSourceMapParsedPathKeyedSegment(segment) {
    return typeof segment == "object" && "_key" in segment && "_index" in segment;
}
function jsonPathToMappingPath(path) {
    return path.map((segment)=>{
        if (typeof segment == "string" || typeof segment == "number") return segment;
        if (segment._index !== -1) return segment._index;
        throw new Error(`invalid segment:${JSON.stringify(segment)}`);
    });
}
function resolveMapping(resultPath, csm) {
    if (!csm?.mappings) return;
    const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));
    if (csm.mappings[resultMappingPath] !== void 0) return {
        mapping: csm.mappings[resultMappingPath],
        matchedPath: resultMappingPath,
        pathSuffix: ""
    };
    const mappings = Object.entries(csm.mappings).filter(([key])=>resultMappingPath.startsWith(key)).sort(([key1], [key2])=>key2.length - key1.length);
    if (mappings.length == 0) return;
    const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);
    return {
        mapping,
        matchedPath,
        pathSuffix
    };
}
function isArray(value) {
    return value !== null && Array.isArray(value);
}
function isRecord(value) {
    return typeof value == "object" && value !== null;
}
function walkMap(value, mappingFn, path = []) {
    if (isArray(value)) return value.map((v, idx)=>{
        if (isRecord(v)) {
            const _key = v._key;
            if (typeof _key == "string") return walkMap(v, mappingFn, path.concat({
                _key,
                _index: idx
            }));
        }
        return walkMap(v, mappingFn, path.concat(idx));
    });
    if (isRecord(value)) {
        if (value._type === "block" || value._type === "span") {
            const result = {
                ...value
            };
            return value._type === "block" ? result.children = walkMap(value.children, mappingFn, path.concat("children")) : value._type === "span" && (result.text = walkMap(value.text, mappingFn, path.concat("text"))), result;
        }
        return Object.fromEntries(Object.entries(value).map(([k, v])=>[
                k,
                walkMap(v, mappingFn, path.concat(k))
            ]));
    }
    return mappingFn(value, path);
}
function createEditUrl(options) {
    const { baseUrl, workspace: _workspace = "default", tool: _tool = "default", id: _id, type, path, projectId, dataset } = options;
    if (!baseUrl) throw new Error("baseUrl is required");
    if (!path) throw new Error("path is required");
    if (!_id) throw new Error("id is required");
    if (baseUrl !== "/" && baseUrl.endsWith("/")) throw new Error("baseUrl must not end with a slash");
    const workspace = _workspace === "default" ? void 0 : _workspace, tool = _tool === "default" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({
        baseUrl,
        id,
        type,
        path: stringifiedPath
    });
    if (workspace && searchParams.set("workspace", workspace), tool && searchParams.set("tool", tool), projectId && searchParams.set("projectId", projectId), dataset && searchParams.set("dataset", dataset), isPublishedId(_id)) searchParams.set("perspective", "published");
    else if (isVersionId(_id)) {
        const versionId = getVersionFromId(_id);
        searchParams.set("perspective", versionId);
    }
    const segments = [
        baseUrl === "/" ? "" : baseUrl
    ];
    workspace && segments.push(workspace);
    const routerParams = [
        "mode=presentation",
        `id=${id}`,
        `type=${type}`,
        `path=${encodeURIComponent(stringifiedPath)}`
    ];
    return tool && routerParams.push(`tool=${tool}`), segments.push("intent", "edit", `${routerParams.join(";")}?${searchParams}`), segments.join("/");
}
function resolveEditInfo(options) {
    const { resultSourceMap: csm, resultPath } = options, { mapping, pathSuffix } = resolveMapping(resultPath, csm) || {};
    if (!mapping || mapping.source.type === "literal" || mapping.source.type === "unknown") return;
    const sourceDoc = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path];
    if (sourceDoc && sourcePath) {
        const { baseUrl, workspace, tool } = resolveStudioBaseRoute(typeof options.studioUrl == "function" ? options.studioUrl(sourceDoc) : options.studioUrl);
        if (!baseUrl) return;
        const { _id, _type, _projectId, _dataset } = sourceDoc;
        return {
            baseUrl,
            workspace,
            tool,
            id: _id,
            type: _type,
            path: parseJsonPath(sourcePath + pathSuffix),
            projectId: _projectId,
            dataset: _dataset
        };
    }
}
function resolveStudioBaseRoute(studioUrl) {
    let baseUrl = typeof studioUrl == "string" ? studioUrl : studioUrl.baseUrl;
    return baseUrl !== "/" && (baseUrl = baseUrl.replace(/\/$/, "")), typeof studioUrl == "string" ? {
        baseUrl
    } : {
        ...studioUrl,
        baseUrl
    };
}
;
 //# sourceMappingURL=resolveEditInfo.js.map
}}),
"[project]/node_modules/@sanity/telemetry/dist/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createBatchedStore": (()=>createBatchedStore),
    "createSessionId": (()=>createSessionId),
    "defineEvent": (()=>defineEvent),
    "defineTrace": (()=>defineTrace)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeid$2d$js$2f$dist$2f$chunk$2d$FOHWUNKU$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeid-js/dist/chunk-FOHWUNKU.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/Subject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$tap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/tap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/throttle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$concatMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/concatMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/Observable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/empty.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$combineLatest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/from.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$catchError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/catchError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js [app-client] (ecmascript)");
;
;
;
function createSessionId() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeid$2d$js$2f$dist$2f$chunk$2d$FOHWUNKU$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeid"])("session").toString();
}
function createTraceId() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeid$2d$js$2f$dist$2f$chunk$2d$FOHWUNKU$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeid"])("trace").toString();
}
function splitAt(str, index) {
    return index < 1 ? [
        str,
        ""
    ] : [
        str.substring(0, index),
        str.substring(index)
    ];
}
const MAX_LENGTH = 1024;
function trimErrorMessage(errorMessage) {
    const newLineIndex = errorMessage.indexOf("\n");
    const splitIndex = newLineIndex === -1 ? MAX_LENGTH : Math.min(newLineIndex, MAX_LENGTH);
    const [first, rest] = splitAt(errorMessage, splitIndex);
    return first + (rest ? "\u2026 (+".concat(rest.length, ")") : "");
}
function createStore(sessionId) {
    const logEntries$ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subject"]();
    function pushTraceError(traceId, telemetryTrace, error, context) {
        logEntries$.next({
            sessionId,
            type: "trace.error",
            traceId,
            name: telemetryTrace.name,
            version: telemetryTrace.version,
            data: {
                message: trimErrorMessage(error.message)
            },
            context,
            createdAt: /* @__PURE__ */ new Date().toISOString()
        });
    }
    function pushTraceEntry(type, traceId, telemetryTrace, data, context) {
        logEntries$.next({
            sessionId,
            type,
            traceId,
            name: telemetryTrace.name,
            version: telemetryTrace.version,
            data,
            context,
            createdAt: /* @__PURE__ */ new Date().toISOString()
        });
    }
    function pushLogEntry(type, event, data) {
        logEntries$.next({
            sessionId,
            type,
            version: event.version,
            name: event.name,
            data,
            createdAt: /* @__PURE__ */ new Date().toISOString()
        });
    }
    function pushUserPropertiesEntry(properties) {
        logEntries$.next({
            sessionId,
            type: "userProperties",
            properties,
            createdAt: /* @__PURE__ */ new Date().toISOString()
        });
    }
    function createTrace(traceId, traceDef, context) {
        return {
            start () {
                pushTraceEntry("trace.start", traceId, traceDef, void 0, context);
            },
            newContext (name) {
                return {
                    trace (innerTraceDef) {
                        return createTrace("".concat(traceId, ".").concat(name), innerTraceDef, context);
                    },
                    updateUserProperties () {},
                    log
                };
            },
            log (data) {
                pushTraceEntry("trace.log", traceId, traceDef, data, context);
            },
            complete () {
                pushTraceEntry("trace.complete", traceId, traceDef, void 0, context);
            },
            error (error) {
                pushTraceError(traceId, traceDef, error, context);
            },
            await (promise, data) {
                this.start();
                promise.then((result)=>{
                    this.log(data ? data : result);
                    this.complete();
                    return result;
                }, (error)=>{
                    this.error(error);
                    throw error;
                });
                return promise;
            }
        };
    }
    function log(event, data) {
        pushLogEntry("log", event, data);
    }
    return {
        events$: logEntries$.asObservable(),
        logger: {
            updateUserProperties (properties) {
                pushUserPropertiesEntry(properties);
            },
            trace: (traceDef, context)=>{
                const traceId = createTraceId();
                return createTrace(traceId, traceDef, context);
            },
            log
        }
    };
}
const unrefTimer = (ms)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"]((subscriber)=>{
        const timeout = setTimeout(()=>{
            subscriber.next();
            subscriber.complete();
        }, ms);
        if (typeof timeout.unref === "function") {
            timeout.unref();
        }
        return ()=>clearTimeout(timeout);
    });
function createBatchedStore(sessionId, options) {
    var _a;
    const store = createStore(sessionId);
    function resolveConsent() {
        return options.resolveConsent().catch((err)=>(// if we for some reason can't fetch consent we treat it as "undetermined", and try again at next flush
            {
                status: "undetermined"
            }));
    }
    const _buffer = [];
    function consume() {
        const buf = _buffer.slice();
        _buffer.length = 0;
        return buf;
    }
    function submit() {
        const pending = consume();
        if (pending.length === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$combineLatest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combineLatest"])([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])(pending),
            resolveConsent()
        ]).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])((_ref)=>{
            let [events, consent] = _ref;
            if (events.length === 0 || consent.status !== "granted") {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(options.sendEvents(events)).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$catchError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["catchError"])((err)=>{
                _buffer.unshift(...events);
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
            }));
        }));
    }
    const flushInterval = (_a = options.flushInterval) != null ? _a : 3e4;
    const flush$ = store.events$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$tap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tap"])((ev)=>_buffer.push(ev)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(()=>{}), // void to avoid accidental use of events further down the pipe
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throttle"])(()=>unrefTimer(flushInterval), {
        leading: false,
        trailing: true
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$concatMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concatMap"])(()=>submit()));
    function flush() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(submit(), {
            defaultValue: void 0
        }).then(()=>{});
    }
    const subscription = flush$.subscribe();
    function endWithBeacon() {
        if (!options.sendBeacon) {
            end();
            return true;
        }
        const events = consume();
        subscription.unsubscribe();
        return events.length > 0 ? options.sendBeacon(events) : true;
    }
    function end() {
        return flush().then(()=>{}, // void promise
        ()=>{}).finally(()=>{
            subscription.unsubscribe();
        });
    }
    return {
        end,
        endWithBeacon,
        // Note: flush may fail
        flush,
        logger: store.logger
    };
}
function defineEvent(options) {
    return {
        type: "log",
        name: options.name,
        version: options.version,
        description: options.description,
        schema: void 0
    };
}
function defineTrace(options) {
    return {
        type: "trace",
        name: options.name,
        version: options.version,
        description: options.description,
        schema: void 0,
        context: void 0
    };
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/telemetry/dist/_chunks/noopLogger-b5b1676e.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "noopLogger": (()=>noopLogger),
    "onPageHide": (()=>onPageHide),
    "onVisibilityHidden": (()=>onVisibilityHidden),
    "registerLifecycleEvents": (()=>registerLifecycleEvents)
});
const capture = {
    capture: true
};
function listen(target, type, cb) {
    target.addEventListener(type, cb, capture);
    return ()=>target.removeEventListener(type, cb, capture);
}
function onPageHide(listener) {
    if ("onpagehide" in window) {
        return listen(window, "pagehide", listener);
    }
    const cleanupUnload = listen(window, "unload", listener);
    const cleanupBeforeUnload = listen(window, "unload", listener);
    return ()=>{
        cleanupUnload();
        cleanupBeforeUnload();
    };
}
function onVisibilityHidden(cb) {
    return listen(document, "visibilitychange", ()=>{
        if (document.visibilityState === "hidden") {
            cb();
        }
    });
}
function registerLifecycleEvents(store) {
    const unregisterVisibilityHidden = onVisibilityHidden(()=>store.flush());
    const unregisterPageHide = onPageHide(()=>store.endWithBeacon());
    return ()=>{
        unregisterPageHide();
        unregisterVisibilityHidden();
    };
}
function createNoopLogger() {
    const logger = {
        updateUserProperties () {},
        trace,
        log
    };
    function trace(telemetryTrace) {
        return {
            start () {},
            log (data) {},
            complete () {},
            newContext (name) {
                return logger;
            },
            error (error) {},
            await: (promise)=>promise
        };
    }
    function log(event, data) {}
    return logger;
}
const noopLogger = createNoopLogger();
;
 //# sourceMappingURL=noopLogger-b5b1676e.js.map
}}),
"[project]/node_modules/@sanity/telemetry/dist/react/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "TelemetryProvider": (()=>TelemetryProvider),
    "useTelemetry": (()=>useTelemetry),
    "useTelemetryStoreLifeCycleEvents": (()=>useTelemetryStoreLifeCycleEvents)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$telemetry$2f$dist$2f$_chunks$2f$noopLogger$2d$b5b1676e$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/telemetry/dist/_chunks/noopLogger-b5b1676e.js [app-client] (ecmascript)");
;
;
;
function useTelemetryStoreLifeCycleEvents(store) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useTelemetryStoreLifeCycleEvents.useEffect": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$telemetry$2f$dist$2f$_chunks$2f$noopLogger$2d$b5b1676e$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onVisibilityHidden"])(store.flush)
    }["useTelemetryStoreLifeCycleEvents.useEffect"], [
        store.flush
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useTelemetryStoreLifeCycleEvents.useEffect": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$telemetry$2f$dist$2f$_chunks$2f$noopLogger$2d$b5b1676e$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onPageHide"])(store.endWithBeacon)
    }["useTelemetryStoreLifeCycleEvents.useEffect"], [
        store.endWithBeacon
    ]);
}
const TelemetryLoggerContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$telemetry$2f$dist$2f$_chunks$2f$noopLogger$2d$b5b1676e$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noopLogger"]);
function TelemetryProvider(_ref) {
    let { children, store } = _ref;
    useTelemetryStoreLifeCycleEvents(store);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(TelemetryLoggerContext.Provider, {
        value: store.logger,
        children
    });
}
function useTelemetry() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(TelemetryLoggerContext);
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/telemetry/dist/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$telemetry$2f$dist$2f$_chunks$2f$noopLogger$2d$b5b1676e$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/telemetry/dist/_chunks/noopLogger-b5b1676e.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$telemetry$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@sanity/telemetry/dist/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@sanity/asset-utils/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DEFAULT_CROP": (()=>DEFAULT_CROP),
    "DEFAULT_HOTSPOT": (()=>DEFAULT_HOTSPOT),
    "UnresolvableError": (()=>UnresolvableError),
    "buildFilePath": (()=>buildFilePath),
    "buildFileUrl": (()=>buildFileUrl),
    "buildImagePath": (()=>buildImagePath),
    "buildImageUrl": (()=>buildImageUrl),
    "getAssetDocumentId": (()=>getAssetDocumentId),
    "getAssetUrlType": (()=>getAssetUrlType),
    "getDefaultCrop": (()=>getDefaultCrop),
    "getDefaultHotspot": (()=>getDefaultHotspot),
    "getExtension": (()=>getExtension),
    "getFile": (()=>getFile),
    "getFileAsset": (()=>getFileAsset),
    "getIdFromString": (()=>getIdFromString),
    "getImage": (()=>getImage),
    "getImageAsset": (()=>getImageAsset),
    "getImageDimensions": (()=>getImageDimensions),
    "getProject": (()=>getProject),
    "getUrlFilename": (()=>getUrlFilename),
    "getUrlPath": (()=>getUrlPath),
    "getVanityStub": (()=>getVanityStub),
    "isAssetFilename": (()=>isAssetFilename),
    "isAssetId": (()=>isAssetId),
    "isAssetIdStub": (()=>isAssetIdStub),
    "isAssetObjectStub": (()=>isAssetObjectStub),
    "isAssetPathStub": (()=>isAssetPathStub),
    "isAssetUrlStub": (()=>isAssetUrlStub),
    "isDefaultCrop": (()=>isDefaultCrop),
    "isDefaultHotspot": (()=>isDefaultHotspot),
    "isFileAssetFilename": (()=>isFileAssetFilename),
    "isFileAssetId": (()=>isFileAssetId),
    "isFileSource": (()=>isFileSource),
    "isImageAssetFilename": (()=>isImageAssetFilename),
    "isImageAssetId": (()=>isImageAssetId),
    "isImageSource": (()=>isImageSource),
    "isReference": (()=>isReference),
    "isSanityAssetUrl": (()=>isSanityAssetUrl),
    "isSanityFileAsset": (()=>isSanityFileAsset),
    "isSanityFileUrl": (()=>isSanityFileUrl),
    "isSanityImageAsset": (()=>isSanityImageAsset),
    "isSanityImageUrl": (()=>isSanityImageUrl),
    "isUnresolvableError": (()=>isUnresolvableError),
    "isValidFilename": (()=>isValidFilename),
    "parseAssetFilename": (()=>parseAssetFilename),
    "parseAssetId": (()=>parseAssetId),
    "parseAssetUrl": (()=>parseAssetUrl),
    "parseFileAssetId": (()=>parseFileAssetId),
    "parseFileAssetUrl": (()=>parseFileAssetUrl),
    "parseImageAssetId": (()=>parseImageAssetId),
    "parseImageAssetUrl": (()=>parseImageAssetUrl),
    "tryGetAssetDocumentId": (()=>tryGetAssetDocumentId),
    "tryGetAssetPath": (()=>tryGetAssetPath),
    "tryGetExtension": (()=>tryGetExtension),
    "tryGetFile": (()=>tryGetFile),
    "tryGetFileAsset": (()=>tryGetFileAsset),
    "tryGetIdFromString": (()=>tryGetIdFromString),
    "tryGetImage": (()=>tryGetImage),
    "tryGetImageAsset": (()=>tryGetImageAsset),
    "tryGetImageDimensions": (()=>tryGetImageDimensions),
    "tryGetProject": (()=>tryGetProject),
    "tryGetUrlFilename": (()=>tryGetUrlFilename),
    "tryGetUrlPath": (()=>tryGetUrlPath)
});
const cdnUrl = "https://cdn.sanity.io", cdnUrlPattern = /^https:\/\/cdn\.sanity\./, customCdnUrlPattern = /^https:\/\/cdn\.[^/]+\/(images|files)\/[^/]+\/.*?[a-zA-Z0-9_]{24,40}.*$/, fileAssetFilenamePattern = /^([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+\.[a-z0-9]+$/, fileAssetIdPattern = /^file-([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-[a-z0-9]+$/, imageAssetFilenamePattern = /^([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})-\d+x\d+\.[a-z0-9]+$/, imageAssetIdPattern = /^image-([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-\d+x\d+-[a-z0-9]+$/, pathPattern = /^(images|files)\/([a-z0-9]+)\/([a-z0-9][-\w]*)\//, idPattern = /^(?:image-(?:[a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-\d+x\d+-[a-z0-9]+|file-(?:[a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-[a-z0-9]+)$/, dummyProject = {
    projectId: "a",
    dataset: "b"
};
class UnresolvableError extends Error {
    constructor(inputSource, message = "Failed to resolve asset ID from source"){
        super(message), this.unresolvable = !0, this.input = inputSource;
    }
}
function isUnresolvableError(err) {
    const error = err;
    return !!(error.unresolvable && "input" in error);
}
function getForgivingResolver(method) {
    return (...args)=>{
        try {
            return method(...args);
        } catch (err) {
            if (isUnresolvableError(err)) return;
            throw err;
        }
    };
}
function isObject(obj) {
    return obj !== null && !Array.isArray(obj) && typeof obj == "object";
}
function isReference(ref) {
    return isObject(ref) && typeof ref._ref == "string";
}
function isAssetIdStub(stub) {
    return isObject(stub) && typeof stub._id == "string";
}
function isAssetPathStub(stub) {
    return isObject(stub) && typeof stub.path == "string";
}
function isAssetUrlStub(stub) {
    return isObject(stub) && typeof stub.url == "string";
}
function isSanityFileAsset(src) {
    return isObject(src) && src._type === "sanity.fileAsset";
}
function isSanityImageAsset(src) {
    return isObject(src) && src._type === "sanity.imageAsset";
}
function isImageAssetId(documentId) {
    return imageAssetIdPattern.test(documentId);
}
function isFileAssetId(documentId) {
    return fileAssetIdPattern.test(documentId);
}
function isAssetId(documentId) {
    return isImageAssetId(documentId) || isFileAssetId(documentId);
}
function isAssetObjectStub(stub) {
    const item = stub;
    return isObject(item) && item.asset && typeof item.asset == "object";
}
function isCdnUrl(url) {
    return cdnUrlPattern.test(url) || customCdnUrlPattern.test(url);
}
const DEFAULT_CROP = Object.freeze({
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
}), DEFAULT_HOTSPOT = Object.freeze({
    x: 0.5,
    y: 0.5,
    height: 1,
    width: 1
}), getDefaultCrop = ()=>({
        ...DEFAULT_CROP
    }), getDefaultHotspot = ()=>({
        ...DEFAULT_HOTSPOT
    }), isDefaultCrop = (crop)=>{
    const { top, bottom, left, right } = crop, { top: defaultTop, bottom: defaultBottom, left: defaultLeft, right: defaultRight } = DEFAULT_CROP;
    return top === defaultTop && bottom === defaultBottom && left === defaultLeft && right === defaultRight;
}, isDefaultHotspot = (hotspot)=>{
    const { x, y, width, height } = hotspot, { x: defaultX, y: defaultY, width: defaultWidth, height: defaultHeight } = DEFAULT_HOTSPOT;
    return x === defaultX && y === defaultY && width === defaultWidth && height === defaultHeight;
};
function buildImagePath(asset, options) {
    const projectId = options?.projectId || asset.projectId, dataset = options?.dataset || asset.dataset;
    if (!projectId || !dataset) throw new Error("Project details (projectId and dataset) required to resolve path for image");
    const dimensions = "metadata" in asset ? asset.metadata.dimensions : {
        width: asset.width,
        height: asset.height
    }, originalFilename = "originalFilename" in asset ? asset.originalFilename : void 0, { assetId, extension, vanityFilename } = asset, { width, height } = dimensions, vanity = getVanityStub(originalFilename, vanityFilename, options);
    return `images/${projectId}/${dataset}/${assetId}-${width}x${height}.${extension}${vanity}`;
}
function buildImageUrl(asset, options) {
    return `${options?.baseUrl || cdnUrl}/${buildImagePath(asset, options)}`;
}
function buildFilePath(asset, options) {
    const projectId = options?.projectId || asset.projectId, dataset = options?.dataset || asset.dataset;
    if (!projectId || !dataset) throw new Error("Project details (projectId and dataset) required to resolve path for file");
    const originalFilename = "originalFilename" in asset ? asset.originalFilename : void 0, { assetId, extension, vanityFilename } = asset, vanity = getVanityStub(originalFilename, vanityFilename, options);
    return `files/${projectId}/${dataset}/${assetId}.${extension}${vanity}`;
}
function buildFileUrl(asset, options) {
    return `${options?.baseUrl || cdnUrl}/${buildFilePath(asset, options)}`;
}
function hasPath(urlOrPath) {
    return pathPattern.test(tryGetUrlPath(urlOrPath) || "");
}
function tryGetAssetPath(src) {
    if (isAssetObjectStub(src)) return tryGetAssetPath(src.asset);
    if (!isReference(src)) {
        if (typeof src == "string") return hasPath(src) ? getUrlPath(src) : void 0;
        if (isAssetPathStub(src)) return src.path;
        if (isAssetUrlStub(src)) return getUrlPath(src.url);
    }
}
function getUrlPath(url) {
    if (pathPattern.test(url)) return url;
    if (!isCdnUrl(url)) throw new UnresolvableError(`Failed to resolve path from URL "${url}"`);
    return new URL(url).pathname.replace(/^\/+/, "");
}
const tryGetUrlPath = getForgivingResolver(getUrlPath);
function getUrlFilename(url) {
    const filename = (tryGetUrlPath(url) || url).replace(/^(images|files)\/[a-z0-9]+\/[a-z0-9][-\w]\/*/, "");
    if (!isValidFilename(filename)) throw new UnresolvableError(`Failed to resolve filename from URL "${url}"`);
    return filename;
}
const tryGetUrlFilename = getForgivingResolver(getUrlFilename);
function isValidFilename(filename) {
    return fileAssetFilenamePattern.test(filename) || imageAssetFilenamePattern.test(filename);
}
function getVanityStub(originalFilename, vanityFilename, options) {
    const vanity = vanityFilename || originalFilename;
    return options?.useVanityName === !1 || !vanity ? "" : `/${vanity}`;
}
const exampleFileId = "file-027401f31c3ac1e6d78c5d539ccd1beff72b9b11-pdf", exampleImageId = "image-027401f31c3ac1e6d78c5d539ccd1beff72b9b11-2000x3000-jpg";
function parseAssetId(documentId) {
    if (imageAssetIdPattern.test(documentId)) return parseImageAssetId(documentId);
    if (fileAssetIdPattern.test(documentId)) return parseFileAssetId(documentId);
    throw new Error(`Invalid image/file asset ID: ${documentId}`);
}
function parseFileAssetId(documentId) {
    if (!fileAssetIdPattern.test(documentId)) throw new Error(`Malformed file asset ID '${documentId}'. Expected an id like "${exampleFileId}"`);
    const [, assetId, extension] = documentId.split("-");
    return {
        type: "file",
        assetId,
        extension
    };
}
function parseImageAssetId(documentId) {
    const [, assetId, dimensionString, extension] = documentId.split("-"), [width, height] = (dimensionString || "").split("x").map(Number);
    if (!assetId || !dimensionString || !extension || !(width > 0) || !(height > 0)) throw new Error(`Malformed asset ID '${documentId}'. Expected an id like "${exampleImageId}".`);
    return {
        type: "image",
        assetId,
        width,
        height,
        extension
    };
}
function parseAssetFilename(filename) {
    const file = tryGetUrlFilename(filename) || "";
    if (!isValidFilename(file)) throw new Error(`Invalid image/file asset filename: ${filename}`);
    try {
        const type = imageAssetFilenamePattern.test(file) ? "image" : "file", assetId = file.replace(/\.([a-z0-9+]+)$/i, "-$1");
        return parseAssetId(`${type}-${assetId}`);
    } catch  {
        throw new Error(`Invalid image/file asset filename: ${filename}`);
    }
}
function parseAssetUrl(url) {
    if (!isCdnUrl(url)) throw new Error(`URL is not a valid Sanity asset URL: ${url}`);
    const path = new URL(url).pathname.replace(/^\/+/, ""), [projectPath, , projectId, dataset] = path.match(pathPattern) || [];
    if (!projectPath || !projectId || !dataset) throw new Error(`URL is not a valid Sanity asset URL: ${url}`);
    const [filename, vanityFilename] = path.slice(projectPath.length).split("/");
    return {
        ...parseAssetFilename(filename),
        projectId,
        dataset,
        vanityFilename
    };
}
function parseImageAssetUrl(url) {
    const parsed = parseAssetUrl(url);
    if (parsed.type !== "image") throw new Error(`URL is not a valid Sanity image asset URL: ${url}`);
    return parsed;
}
function parseFileAssetUrl(url) {
    const parsed = parseAssetUrl(url);
    if (parsed.type !== "file") throw new Error(`URL is not a valid Sanity file asset URL: ${url}`);
    return parsed;
}
function getAssetUrlType(url) {
    try {
        return parseAssetUrl(url).type;
    } catch  {
        return !1;
    }
}
function getImageDimensions(src) {
    const imageId = getAssetDocumentId(src), { width, height } = parseImageAssetId(imageId), aspectRatio = width / height;
    return {
        width,
        height,
        aspectRatio
    };
}
const tryGetImageDimensions = getForgivingResolver(getImageDimensions);
function getExtension(src) {
    return isFileSource(src) ? getFile(src, dummyProject).asset.extension : getImage(src, dummyProject).asset.extension;
}
const tryGetExtension = getForgivingResolver(getExtension);
function getImage(src, project) {
    const projectDetails = project || tryGetProject(src), asset = getImageAsset(src, projectDetails), img = src;
    return {
        asset,
        crop: img.crop || getDefaultCrop(),
        hotspot: img.hotspot || getDefaultHotspot()
    };
}
const tryGetImage = getForgivingResolver(getImage);
function getImageAsset(src, project) {
    const pathOptions = {
        ...project || getProject(src),
        useVanityName: !1
    }, _id = getAssetDocumentId(src), metadata = (src.asset || src).metadata || {}, { assetId, width, height, extension } = parseImageAssetId(_id), aspectRatio = width / height, baseAsset = {
        ...isSanityImageAsset(src) ? src : {},
        _id,
        _type: "sanity.imageAsset",
        assetId,
        extension,
        metadata: {
            ...metadata,
            dimensions: {
                width,
                height,
                aspectRatio
            }
        },
        // Placeholders, overwritten below
        url: "",
        path: ""
    };
    return {
        ...baseAsset,
        path: buildImagePath(baseAsset, pathOptions),
        url: buildImageUrl(baseAsset, pathOptions)
    };
}
const tryGetImageAsset = getForgivingResolver(getImageAsset);
function getFile(src, project) {
    const projectDetails = project || tryGetProject(src);
    return {
        asset: getFileAsset(src, projectDetails)
    };
}
const tryGetFile = getForgivingResolver(getFile);
function getFileAsset(src, options) {
    const projectDetails = {
        ...options || getProject(src),
        useVanityName: !1
    }, _id = getAssetDocumentId(src), source = src.asset || src, { assetId, extension } = parseFileAssetId(_id), baseAsset = {
        ...isSanityFileAsset(src) ? src : {},
        _id,
        _type: "sanity.fileAsset",
        assetId,
        extension,
        metadata: source.metadata || {},
        // Placeholders, overwritten below
        url: "",
        path: ""
    };
    return {
        ...baseAsset,
        path: buildFilePath(baseAsset, projectDetails),
        url: buildFileUrl(baseAsset, projectDetails)
    };
}
const tryGetFileAsset = getForgivingResolver(getFileAsset);
function getAssetDocumentId(src) {
    const source = isAssetObjectStub(src) ? src.asset : src;
    let id = "";
    if (typeof source == "string" ? id = getIdFromString(source) : isReference(source) ? id = source._ref : isAssetIdStub(source) ? id = source._id : isAssetPathStub(source) ? id = idFromUrl(`${cdnUrl}/${source.path}`) : isAssetUrlStub(source) && (id = idFromUrl(source.url)), !(id && idPattern.test(id))) throw new UnresolvableError(src);
    return id;
}
const tryGetAssetDocumentId = getForgivingResolver(getAssetDocumentId);
function getIdFromString(str) {
    if (idPattern.test(str)) return str;
    const path = isCdnUrl(str) ? new URL(str).pathname : str;
    if (path.indexOf("/images") === 0 || path.indexOf("/files") === 0) return idFromUrl(str);
    if (pathPattern.test(str)) return idFromUrl(`${cdnUrl}/${str}`);
    if (isFileAssetFilename(str)) return idFromUrl(`${cdnUrl}/files/a/b/${str}`);
    if (isImageAssetFilename(str)) return idFromUrl(`${cdnUrl}/images/a/b/${str}`);
    throw new UnresolvableError(str);
}
const tryGetIdFromString = getForgivingResolver(getIdFromString);
function idFromUrl(url) {
    const path = getUrlPath(url), [type, , , fileName] = path.split("/");
    return `${type.replace(/s$/, "")}-${fileName.replace(/\./g, "-")}`;
}
function getProject(src) {
    const path = tryGetAssetPath(src);
    if (!path) throw new UnresolvableError(src, "Failed to resolve project ID and dataset from source");
    const [, , projectId, dataset] = path.match(pathPattern) || [];
    if (!projectId || !dataset) throw new UnresolvableError(src, "Failed to resolve project ID and dataset from source");
    return {
        projectId,
        dataset
    };
}
const tryGetProject = getForgivingResolver(getProject);
function isImageAssetFilename(filename) {
    return imageAssetFilenamePattern.test(filename);
}
function isFileAssetFilename(filename) {
    return fileAssetFilenamePattern.test(filename);
}
function isAssetFilename(filename) {
    return isImageAssetFilename(filename) || isFileAssetFilename(filename);
}
function isFileSource(src) {
    const assetId = tryGetAssetDocumentId(src);
    return assetId ? assetId.startsWith("file-") : !1;
}
function isImageSource(src) {
    const assetId = tryGetAssetDocumentId(src);
    return assetId ? assetId.startsWith("image-") : !1;
}
function isSanityAssetUrl(url) {
    return getAssetUrlType(url) !== !1;
}
function isSanityImageUrl(url) {
    return getAssetUrlType(url) === "image";
}
function isSanityFileUrl(url) {
    return getAssetUrlType(url) === "file";
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/image-url/lib/browser/image-url.umd.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : ("TURBOPACK unreachable", undefined);
})(this, function() {
    function _extends() {
        _extends = Object.assign || function(target) {
            for(var i = 1; i < arguments.length; i++){
                var source = arguments[i];
                for(var key in source){
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                        target[key] = source[key];
                    }
                }
            }
            return target;
        };
        return _extends.apply(this, arguments);
    }
    function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (it) return (it = it.call(o)).next.bind(it);
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            return function() {
                if (i >= o.length) return {
                    done: true
                };
                return {
                    done: false,
                    value: o[i++]
                };
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var example = 'image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg';
    function parseAssetId(ref) {
        var _ref$split = ref.split('-'), id = _ref$split[1], dimensionString = _ref$split[2], format = _ref$split[3];
        if (!id || !dimensionString || !format) {
            throw new Error("Malformed asset _ref '" + ref + "'. Expected an id like \"" + example + "\".");
        }
        var _dimensionString$spli = dimensionString.split('x'), imgWidthStr = _dimensionString$spli[0], imgHeightStr = _dimensionString$spli[1];
        var width = +imgWidthStr;
        var height = +imgHeightStr;
        var isValidAssetId = isFinite(width) && isFinite(height);
        if (!isValidAssetId) {
            throw new Error("Malformed asset _ref '" + ref + "'. Expected an id like \"" + example + "\".");
        }
        return {
            id: id,
            width: width,
            height: height,
            format: format
        };
    }
    var isRef = function isRef(src) {
        var source = src;
        return source ? typeof source._ref === 'string' : false;
    };
    var isAsset = function isAsset(src) {
        var source = src;
        return source ? typeof source._id === 'string' : false;
    };
    var isAssetStub = function isAssetStub(src) {
        var source = src;
        return source && source.asset ? typeof source.asset.url === 'string' : false;
    };
    // Convert an asset-id, asset or image to an image record suitable for processing
    // eslint-disable-next-line complexity
    function parseSource(source) {
        if (!source) {
            return null;
        }
        var image;
        if (typeof source === 'string' && isUrl(source)) {
            // Someone passed an existing image url?
            image = {
                asset: {
                    _ref: urlToId(source)
                }
            };
        } else if (typeof source === 'string') {
            // Just an asset id
            image = {
                asset: {
                    _ref: source
                }
            };
        } else if (isRef(source)) {
            // We just got passed an asset directly
            image = {
                asset: source
            };
        } else if (isAsset(source)) {
            // If we were passed an image asset document
            image = {
                asset: {
                    _ref: source._id || ''
                }
            };
        } else if (isAssetStub(source)) {
            // If we were passed a partial asset (`url`, but no `_id`)
            image = {
                asset: {
                    _ref: urlToId(source.asset.url)
                }
            };
        } else if (typeof source.asset === 'object') {
            // Probably an actual image with materialized asset
            image = _extends({}, source);
        } else {
            // We got something that does not look like an image, or it is an image
            // that currently isn't sporting an asset.
            return null;
        }
        var img = source;
        if (img.crop) {
            image.crop = img.crop;
        }
        if (img.hotspot) {
            image.hotspot = img.hotspot;
        }
        return applyDefaults(image);
    }
    function isUrl(url) {
        return /^https?:\/\//.test("" + url);
    }
    function urlToId(url) {
        var parts = url.split('/').slice(-1);
        return ("image-" + parts[0]).replace(/\.([a-z]+)$/, '-$1');
    }
    // Mock crop and hotspot if image lacks it
    function applyDefaults(image) {
        if (image.crop && image.hotspot) {
            return image;
        }
        // We need to pad in default values for crop or hotspot
        var result = _extends({}, image);
        if (!result.crop) {
            result.crop = {
                left: 0,
                top: 0,
                bottom: 0,
                right: 0
            };
        }
        if (!result.hotspot) {
            result.hotspot = {
                x: 0.5,
                y: 0.5,
                height: 1.0,
                width: 1.0
            };
        }
        return result;
    }
    var SPEC_NAME_TO_URL_NAME_MAPPINGS = [
        [
            'width',
            'w'
        ],
        [
            'height',
            'h'
        ],
        [
            'format',
            'fm'
        ],
        [
            'download',
            'dl'
        ],
        [
            'blur',
            'blur'
        ],
        [
            'sharpen',
            'sharp'
        ],
        [
            'invert',
            'invert'
        ],
        [
            'orientation',
            'or'
        ],
        [
            'minHeight',
            'min-h'
        ],
        [
            'maxHeight',
            'max-h'
        ],
        [
            'minWidth',
            'min-w'
        ],
        [
            'maxWidth',
            'max-w'
        ],
        [
            'quality',
            'q'
        ],
        [
            'fit',
            'fit'
        ],
        [
            'crop',
            'crop'
        ],
        [
            'saturation',
            'sat'
        ],
        [
            'auto',
            'auto'
        ],
        [
            'dpr',
            'dpr'
        ],
        [
            'pad',
            'pad'
        ],
        [
            'frame',
            'frame'
        ]
    ];
    function urlForImage(options) {
        var spec = _extends({}, options || {});
        var source = spec.source;
        delete spec.source;
        var image = parseSource(source);
        if (!image) {
            throw new Error("Unable to resolve image URL from source (" + JSON.stringify(source) + ")");
        }
        var id = image.asset._ref || image.asset._id || '';
        var asset = parseAssetId(id);
        // Compute crop rect in terms of pixel coordinates in the raw source image
        var cropLeft = Math.round(image.crop.left * asset.width);
        var cropTop = Math.round(image.crop.top * asset.height);
        var crop = {
            left: cropLeft,
            top: cropTop,
            width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),
            height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop)
        };
        // Compute hot spot rect in terms of pixel coordinates
        var hotSpotVerticalRadius = image.hotspot.height * asset.height / 2;
        var hotSpotHorizontalRadius = image.hotspot.width * asset.width / 2;
        var hotSpotCenterX = image.hotspot.x * asset.width;
        var hotSpotCenterY = image.hotspot.y * asset.height;
        var hotspot = {
            left: hotSpotCenterX - hotSpotHorizontalRadius,
            top: hotSpotCenterY - hotSpotVerticalRadius,
            right: hotSpotCenterX + hotSpotHorizontalRadius,
            bottom: hotSpotCenterY + hotSpotVerticalRadius
        };
        // If irrelevant, or if we are requested to: don't perform crop/fit based on
        // the crop/hotspot.
        if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {
            spec = _extends({}, spec, fit({
                crop: crop,
                hotspot: hotspot
            }, spec));
        }
        return specToImageUrl(_extends({}, spec, {
            asset: asset
        }));
    }
    // eslint-disable-next-line complexity
    function specToImageUrl(spec) {
        var cdnUrl = (spec.baseUrl || 'https://cdn.sanity.io').replace(/\/+$/, '');
        var vanityStub = spec.vanityName ? "/" + spec.vanityName : '';
        var filename = spec.asset.id + "-" + spec.asset.width + "x" + spec.asset.height + "." + spec.asset.format + vanityStub;
        var baseUrl = cdnUrl + "/images/" + spec.projectId + "/" + spec.dataset + "/" + filename;
        var params = [];
        if (spec.rect) {
            // Only bother url with a crop if it actually crops anything
            var _spec$rect = spec.rect, left = _spec$rect.left, top = _spec$rect.top, width = _spec$rect.width, height = _spec$rect.height;
            var isEffectiveCrop = left !== 0 || top !== 0 || height !== spec.asset.height || width !== spec.asset.width;
            if (isEffectiveCrop) {
                params.push("rect=" + left + "," + top + "," + width + "," + height);
            }
        }
        if (spec.bg) {
            params.push("bg=" + spec.bg);
        }
        if (spec.focalPoint) {
            params.push("fp-x=" + spec.focalPoint.x);
            params.push("fp-y=" + spec.focalPoint.y);
        }
        var flip = [
            spec.flipHorizontal && 'h',
            spec.flipVertical && 'v'
        ].filter(Boolean).join('');
        if (flip) {
            params.push("flip=" + flip);
        }
        // Map from spec name to url param name, and allow using the actual param name as an alternative
        SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function(mapping) {
            var specName = mapping[0], param = mapping[1];
            if (typeof spec[specName] !== 'undefined') {
                params.push(param + "=" + encodeURIComponent(spec[specName]));
            } else if (typeof spec[param] !== 'undefined') {
                params.push(param + "=" + encodeURIComponent(spec[param]));
            }
        });
        if (params.length === 0) {
            return baseUrl;
        }
        return baseUrl + "?" + params.join('&');
    }
    function fit(source, spec) {
        var cropRect;
        var imgWidth = spec.width;
        var imgHeight = spec.height;
        // If we are not constraining the aspect ratio, we'll just use the whole crop
        if (!(imgWidth && imgHeight)) {
            return {
                width: imgWidth,
                height: imgHeight,
                rect: source.crop
            };
        }
        var crop = source.crop;
        var hotspot = source.hotspot;
        // If we are here, that means aspect ratio is locked and fitting will be a bit harder
        var desiredAspectRatio = imgWidth / imgHeight;
        var cropAspectRatio = crop.width / crop.height;
        if (cropAspectRatio > desiredAspectRatio) {
            // The crop is wider than the desired aspect ratio. That means we are cutting from the sides
            var height = Math.round(crop.height);
            var width = Math.round(height * desiredAspectRatio);
            var top = Math.max(0, Math.round(crop.top));
            // Center output horizontally over hotspot
            var hotspotXCenter = Math.round((hotspot.right - hotspot.left) / 2 + hotspot.left);
            var left = Math.max(0, Math.round(hotspotXCenter - width / 2));
            // Keep output within crop
            if (left < crop.left) {
                left = crop.left;
            } else if (left + width > crop.left + crop.width) {
                left = crop.left + crop.width - width;
            }
            cropRect = {
                left: left,
                top: top,
                width: width,
                height: height
            };
        } else {
            // The crop is taller than the desired ratio, we are cutting from top and bottom
            var _width = crop.width;
            var _height = Math.round(_width / desiredAspectRatio);
            var _left = Math.max(0, Math.round(crop.left));
            // Center output vertically over hotspot
            var hotspotYCenter = Math.round((hotspot.bottom - hotspot.top) / 2 + hotspot.top);
            var _top = Math.max(0, Math.round(hotspotYCenter - _height / 2));
            // Keep output rect within crop
            if (_top < crop.top) {
                _top = crop.top;
            } else if (_top + _height > crop.top + crop.height) {
                _top = crop.top + crop.height - _height;
            }
            cropRect = {
                left: _left,
                top: _top,
                width: _width,
                height: _height
            };
        }
        return {
            width: imgWidth,
            height: imgHeight,
            rect: cropRect
        };
    }
    var validFits = [
        'clip',
        'crop',
        'fill',
        'fillmax',
        'max',
        'scale',
        'min'
    ];
    var validCrops = [
        'top',
        'bottom',
        'left',
        'right',
        'center',
        'focalpoint',
        'entropy'
    ];
    var validAutoModes = [
        'format'
    ];
    function isSanityModernClientLike(client) {
        return client && 'config' in client ? typeof client.config === 'function' : false;
    }
    function isSanityClientLike(client) {
        return client && 'clientConfig' in client ? typeof client.clientConfig === 'object' : false;
    }
    function rewriteSpecName(key) {
        var specs = SPEC_NAME_TO_URL_NAME_MAPPINGS;
        for(var _iterator = _createForOfIteratorHelperLoose(specs), _step; !(_step = _iterator()).done;){
            var entry = _step.value;
            var specName = entry[0], param = entry[1];
            if (key === specName || key === param) {
                return specName;
            }
        }
        return key;
    }
    function urlBuilder(options) {
        // Did we get a modernish client?
        if (isSanityModernClientLike(options)) {
            // Inherit config from client
            var _options$config = options.config(), apiUrl = _options$config.apiHost, projectId = _options$config.projectId, dataset = _options$config.dataset;
            var apiHost = apiUrl || 'https://api.sanity.io';
            return new ImageUrlBuilder(null, {
                baseUrl: apiHost.replace(/^https:\/\/api\./, 'https://cdn.'),
                projectId: projectId,
                dataset: dataset
            });
        }
        // Did we get a SanityClient?
        if (isSanityClientLike(options)) {
            // Inherit config from client
            var _options$clientConfig = options.clientConfig, _apiUrl = _options$clientConfig.apiHost, _projectId = _options$clientConfig.projectId, _dataset = _options$clientConfig.dataset;
            var _apiHost = _apiUrl || 'https://api.sanity.io';
            return new ImageUrlBuilder(null, {
                baseUrl: _apiHost.replace(/^https:\/\/api\./, 'https://cdn.'),
                projectId: _projectId,
                dataset: _dataset
            });
        }
        // Or just accept the options as given
        return new ImageUrlBuilder(null, options || {});
    }
    var ImageUrlBuilder = /*#__PURE__*/ function() {
        function ImageUrlBuilder(parent, options) {
            this.options = void 0;
            this.options = parent ? _extends({}, parent.options || {}, options || {}) // Merge parent options
             : _extends({}, options || {}); // Copy options
        }
        var _proto = ImageUrlBuilder.prototype;
        _proto.withOptions = function withOptions(options) {
            var baseUrl = options.baseUrl || this.options.baseUrl;
            var newOptions = {
                baseUrl: baseUrl
            };
            for(var key in options){
                if (options.hasOwnProperty(key)) {
                    var specKey = rewriteSpecName(key);
                    newOptions[specKey] = options[key];
                }
            }
            return new ImageUrlBuilder(this, _extends({
                baseUrl: baseUrl
            }, newOptions));
        };
        _proto.image = function image(source) {
            return this.withOptions({
                source: source
            });
        };
        _proto.dataset = function dataset(_dataset2) {
            return this.withOptions({
                dataset: _dataset2
            });
        };
        _proto.projectId = function projectId(_projectId2) {
            return this.withOptions({
                projectId: _projectId2
            });
        };
        _proto.bg = function bg(_bg) {
            return this.withOptions({
                bg: _bg
            });
        };
        _proto.dpr = function dpr(_dpr) {
            // A DPR of 1 is the default - so only include it if we have a different value
            return this.withOptions(_dpr && _dpr !== 1 ? {
                dpr: _dpr
            } : {});
        };
        _proto.width = function width(_width) {
            return this.withOptions({
                width: _width
            });
        };
        _proto.height = function height(_height) {
            return this.withOptions({
                height: _height
            });
        };
        _proto.focalPoint = function focalPoint(x, y) {
            return this.withOptions({
                focalPoint: {
                    x: x,
                    y: y
                }
            });
        };
        _proto.maxWidth = function maxWidth(_maxWidth) {
            return this.withOptions({
                maxWidth: _maxWidth
            });
        };
        _proto.minWidth = function minWidth(_minWidth) {
            return this.withOptions({
                minWidth: _minWidth
            });
        };
        _proto.maxHeight = function maxHeight(_maxHeight) {
            return this.withOptions({
                maxHeight: _maxHeight
            });
        };
        _proto.minHeight = function minHeight(_minHeight) {
            return this.withOptions({
                minHeight: _minHeight
            });
        };
        _proto.size = function size(width, height) {
            return this.withOptions({
                width: width,
                height: height
            });
        };
        _proto.blur = function blur(_blur) {
            return this.withOptions({
                blur: _blur
            });
        };
        _proto.sharpen = function sharpen(_sharpen) {
            return this.withOptions({
                sharpen: _sharpen
            });
        };
        _proto.rect = function rect(left, top, width, height) {
            return this.withOptions({
                rect: {
                    left: left,
                    top: top,
                    width: width,
                    height: height
                }
            });
        };
        _proto.format = function format(_format) {
            return this.withOptions({
                format: _format
            });
        };
        _proto.invert = function invert(_invert) {
            return this.withOptions({
                invert: _invert
            });
        };
        _proto.orientation = function orientation(_orientation) {
            return this.withOptions({
                orientation: _orientation
            });
        };
        _proto.quality = function quality(_quality) {
            return this.withOptions({
                quality: _quality
            });
        };
        _proto.forceDownload = function forceDownload(download) {
            return this.withOptions({
                download: download
            });
        };
        _proto.flipHorizontal = function flipHorizontal() {
            return this.withOptions({
                flipHorizontal: true
            });
        };
        _proto.flipVertical = function flipVertical() {
            return this.withOptions({
                flipVertical: true
            });
        };
        _proto.ignoreImageParams = function ignoreImageParams() {
            return this.withOptions({
                ignoreImageParams: true
            });
        };
        _proto.fit = function fit(value) {
            if (validFits.indexOf(value) === -1) {
                throw new Error("Invalid fit mode \"" + value + "\"");
            }
            return this.withOptions({
                fit: value
            });
        };
        _proto.crop = function crop(value) {
            if (validCrops.indexOf(value) === -1) {
                throw new Error("Invalid crop mode \"" + value + "\"");
            }
            return this.withOptions({
                crop: value
            });
        };
        _proto.saturation = function saturation(_saturation) {
            return this.withOptions({
                saturation: _saturation
            });
        };
        _proto.auto = function auto(value) {
            if (validAutoModes.indexOf(value) === -1) {
                throw new Error("Invalid auto mode \"" + value + "\"");
            }
            return this.withOptions({
                auto: value
            });
        };
        _proto.pad = function pad(_pad) {
            return this.withOptions({
                pad: _pad
            });
        };
        _proto.vanityName = function vanityName(value) {
            return this.withOptions({
                vanityName: value
            });
        };
        _proto.frame = function frame(_frame) {
            if (_frame !== 1) {
                throw new Error("Invalid frame value \"" + _frame + "\"");
            }
            return this.withOptions({
                frame: _frame
            });
        };
        _proto.url = function url() {
            return urlForImage(this.options);
        };
        _proto.toString = function toString() {
            return this.url();
        };
        return ImageUrlBuilder;
    }();
    return urlBuilder;
}); //# sourceMappingURL=image-url.umd.js.map
}}),
"[project]/node_modules/@sanity/diff-match-patch/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DIFF_DELETE": (()=>DIFF_DELETE),
    "DIFF_EQUAL": (()=>DIFF_EQUAL),
    "DIFF_INSERT": (()=>DIFF_INSERT),
    "adjustIndiciesToUcs2": (()=>adjustIndiciesToUcs2),
    "applyPatches": (()=>apply),
    "cleanupEfficiency": (()=>cleanupEfficiency),
    "cleanupSemantic": (()=>cleanupSemantic),
    "makeDiff": (()=>diff),
    "makePatches": (()=>make),
    "match": (()=>match),
    "parsePatch": (()=>parse),
    "stringifyPatch": (()=>stringifyPatch),
    "stringifyPatches": (()=>stringify),
    "xIndex": (()=>xIndex)
});
function cloneDiff(diff2) {
    const [type, patch] = diff2;
    return [
        type,
        patch
    ];
}
function getCommonOverlap(textA, textB) {
    let text1 = textA, text2 = textB;
    const text1Length = text1.length, text2Length = text2.length;
    if (text1Length === 0 || text2Length === 0) return 0;
    text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));
    const textLength = Math.min(text1Length, text2Length);
    if (text1 === text2) return textLength;
    let best = 0, length = 1;
    for(let found = 0; found !== -1;){
        const pattern = text1.substring(textLength - length);
        if (found = text2.indexOf(pattern), found === -1) return best;
        length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);
    }
    return best;
}
function getCommonPrefix(text1, text2) {
    if (!text1 || !text2 || text1[0] !== text2[0]) return 0;
    let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;
    for(; pointerMin < pointerMid;)text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
    return pointerMid;
}
function getCommonSuffix(text1, text2) {
    if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) return 0;
    let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;
    for(; pointerMin < pointerMid;)text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
    return pointerMid;
}
function isHighSurrogate(char) {
    const charCode = char.charCodeAt(0);
    return charCode >= 55296 && charCode <= 56319;
}
function isLowSurrogate(char) {
    const charCode = char.charCodeAt(0);
    return charCode >= 56320 && charCode <= 57343;
}
function bisect(text1, text2, deadline) {
    const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);
    for(let x = 0; x < vLength; x++)v1[x] = -1, v2[x] = -1;
    v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;
    const delta = text1Length - text2Length, front = delta % 2 !== 0;
    let k1start = 0, k1end = 0, k2start = 0, k2end = 0;
    for(let d = 0; d < maxD && !(Date.now() > deadline); d++){
        for(let k1 = -d + k1start; k1 <= d - k1end; k1 += 2){
            const k1Offset = vOffset + k1;
            let x1;
            k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;
            let y1 = x1 - k1;
            for(; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1);)x1++, y1++;
            if (v1[k1Offset] = x1, x1 > text1Length) k1end += 2;
            else if (y1 > text2Length) k1start += 2;
            else if (front) {
                const k2Offset = vOffset + delta - k1;
                if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
                    const x2 = text1Length - v2[k2Offset];
                    if (x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
                }
            }
        }
        for(let k2 = -d + k2start; k2 <= d - k2end; k2 += 2){
            const k2Offset = vOffset + k2;
            let x2;
            k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;
            let y2 = x2 - k2;
            for(; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1);)x2++, y2++;
            if (v2[k2Offset] = x2, x2 > text1Length) k2end += 2;
            else if (y2 > text2Length) k2start += 2;
            else if (!front) {
                const k1Offset = vOffset + delta - k2;
                if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
                    const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;
                    if (x2 = text1Length - x2, x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
                }
            }
        }
    }
    return [
        [
            DIFF_DELETE,
            text1
        ],
        [
            DIFF_INSERT,
            text2
        ]
    ];
}
function bisectSplit(text1, text2, x, y, deadline) {
    const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {
        checkLines: !1,
        deadline
    }), diffsb = doDiff(text1b, text2b, {
        checkLines: !1,
        deadline
    });
    return diffs.concat(diffsb);
}
function findHalfMatch(text1, text2, timeout = 1) {
    if (timeout <= 0) return null;
    const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;
    if (longText.length < 4 || shortText.length * 2 < longText.length) return null;
    const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));
    let halfMatch;
    if (halfMatch1 && halfMatch2) halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;
    else {
        if (!halfMatch1 && !halfMatch2) return null;
        halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;
    }
    if (!halfMatch) throw new Error("Unable to find a half match.");
    let text1A, text1B, text2A, text2B;
    text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);
    const midCommon = halfMatch[4];
    return [
        text1A,
        text1B,
        text2A,
        text2B,
        midCommon
    ];
}
function halfMatchI(longText, shortText, i) {
    const seed = longText.slice(i, i + Math.floor(longText.length / 4));
    let j = -1, bestCommon = "", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;
    for(; (j = shortText.indexOf(seed, j + 1)) !== -1;){
        const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));
        bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));
    }
    return bestCommon.length * 2 >= longText.length ? [
        bestLongTextA || "",
        bestLongTextB || "",
        bestShortTextA || "",
        bestShortTextB || "",
        bestCommon || ""
    ] : null;
}
function charsToLines(diffs, lineArray) {
    for(let x = 0; x < diffs.length; x++){
        const chars = diffs[x][1], text = [];
        for(let y = 0; y < chars.length; y++)text[y] = lineArray[chars.charCodeAt(y)];
        diffs[x][1] = text.join("");
    }
}
function linesToChars(textA, textB) {
    const lineArray = [], lineHash = {};
    lineArray[0] = "";
    function diffLinesToMunge(text) {
        let chars = "", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;
        for(; lineEnd < text.length - 1;){
            lineEnd = text.indexOf(`
`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);
            let line = text.slice(lineStart, lineEnd + 1);
            (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;
        }
        return chars;
    }
    let maxLines = 4e4;
    const chars1 = diffLinesToMunge(textA);
    maxLines = 65535;
    const chars2 = diffLinesToMunge(textB);
    return {
        chars1,
        chars2,
        lineArray
    };
}
function doLineModeDiff(textA, textB, opts) {
    let text1 = textA, text2 = textB;
    const a = linesToChars(text1, text2);
    text1 = a.chars1, text2 = a.chars2;
    const linearray = a.lineArray;
    let diffs = doDiff(text1, text2, {
        checkLines: !1,
        deadline: opts.deadline
    });
    charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([
        DIFF_EQUAL,
        ""
    ]);
    let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "";
    for(; pointer < diffs.length;){
        switch(diffs[pointer][0]){
            case DIFF_INSERT:
                countInsert++, textInsert += diffs[pointer][1];
                break;
            case DIFF_DELETE:
                countDelete++, textDelete += diffs[pointer][1];
                break;
            case DIFF_EQUAL:
                if (countDelete >= 1 && countInsert >= 1) {
                    diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;
                    const aa = doDiff(textDelete, textInsert, {
                        checkLines: !1,
                        deadline: opts.deadline
                    });
                    for(let j = aa.length - 1; j >= 0; j--)diffs.splice(pointer, 0, aa[j]);
                    pointer += aa.length;
                }
                countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
                break;
            default:
                throw new Error("Unknown diff operation.");
        }
        pointer++;
    }
    return diffs.pop(), diffs;
}
function computeDiff(text1, text2, opts) {
    let diffs;
    if (!text1) return [
        [
            DIFF_INSERT,
            text2
        ]
    ];
    if (!text2) return [
        [
            DIFF_DELETE,
            text1
        ]
    ];
    const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);
    if (i !== -1) return diffs = [
        [
            DIFF_INSERT,
            longtext.substring(0, i)
        ],
        [
            DIFF_EQUAL,
            shorttext
        ],
        [
            DIFF_INSERT,
            longtext.substring(i + shorttext.length)
        ]
    ], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;
    if (shorttext.length === 1) return [
        [
            DIFF_DELETE,
            text1
        ],
        [
            DIFF_INSERT,
            text2
        ]
    ];
    const halfMatch = findHalfMatch(text1, text2);
    if (halfMatch) {
        const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);
        return diffsA.concat([
            [
                DIFF_EQUAL,
                midCommon
            ]
        ], diffsB);
    }
    return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);
}
var __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value)=>key in obj ? __defProp$2(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value, __spreadValues$2 = (a, b)=>{
    for(var prop in b || (b = {}))__hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
    if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b))__propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
    return a;
};
const DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;
function diff(textA, textB, opts) {
    if (textA === null || textB === null) throw new Error("Null input. (diff)");
    const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));
    return adjustDiffForSurrogatePairs(diffs), diffs;
}
function doDiff(textA, textB, options) {
    let text1 = textA, text2 = textB;
    if (text1 === text2) return text1 ? [
        [
            DIFF_EQUAL,
            text1
        ]
    ] : [];
    let commonlength = getCommonPrefix(text1, text2);
    const commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);
    const commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);
    let diffs = computeDiff(text1, text2, options);
    return commonprefix && diffs.unshift([
        DIFF_EQUAL,
        commonprefix
    ]), commonsuffix && diffs.push([
        DIFF_EQUAL,
        commonsuffix
    ]), diffs = cleanupMerge(diffs), diffs;
}
function createDeadLine(timeout) {
    let t = 1;
    return typeof timeout < "u" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;
}
function createInternalOpts(opts) {
    return __spreadValues$2({
        checkLines: !0,
        deadline: createDeadLine(opts.timeout || 1)
    }, opts);
}
function combineChar(data, char, dir) {
    return dir === 1 ? data + char : char + data;
}
function splitChar(data, dir) {
    return dir === 1 ? [
        data.substring(0, data.length - 1),
        data[data.length - 1]
    ] : [
        data.substring(1),
        data[0]
    ];
}
function hasSharedChar(diffs, i, j, dir) {
    return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];
}
function deisolateChar(diffs, i, dir) {
    const inv = dir === 1 ? -1 : 1;
    let insertIdx = null, deleteIdx = null, j = i + dir;
    for(; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir){
        const [op, text2] = diffs[j];
        if (text2.length !== 0) {
            if (op === DIFF_INSERT) {
                insertIdx === null && (insertIdx = j);
                continue;
            } else if (op === DIFF_DELETE) {
                deleteIdx === null && (deleteIdx = j);
                continue;
            } else if (op === DIFF_EQUAL) {
                if (insertIdx === null && deleteIdx === null) {
                    const [rest, char2] = splitChar(diffs[i][1], dir);
                    diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);
                    return;
                }
                break;
            }
        }
    }
    if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {
        const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);
        diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);
        return;
    }
    const [text, char] = splitChar(diffs[i][1], dir);
    diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [
        DIFF_INSERT,
        char
    ]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [
        DIFF_DELETE,
        char
    ]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);
}
function adjustDiffForSurrogatePairs(diffs) {
    for(let i = 0; i < diffs.length; i++){
        const [diffType, diffText] = diffs[i];
        if (diffText.length === 0) continue;
        const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];
        isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);
    }
    for(let i = 0; i < diffs.length; i++)diffs[i][1].length === 0 && diffs.splice(i, 1);
}
function cleanupSemantic(rawDiffs) {
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2)), hasChanges = !1;
    const equalities = [];
    let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;
    for(; pointer < diffs.length;)diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [
        DIFF_DELETE,
        lastEquality
    ]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;
    for(hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length;){
        if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
            const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);
            overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                insertion.substring(0, overlapLength1)
            ]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                deletion.substring(0, overlapLength2)
            ]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;
        }
        pointer++;
    }
    return diffs;
}
const nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\s/, linebreakRegex = /[\r\n]/, blanklineEndRegex = /\n\r?\n$/, blanklineStartRegex = /^\r?\n\r?\n/;
function cleanupSemanticLossless(rawDiffs) {
    const diffs = rawDiffs.map((diff2)=>cloneDiff(diff2));
    function diffCleanupSemanticScore(one, two) {
        if (!one || !two) return 6;
        const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);
        return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
    }
    let pointer = 1;
    for(; pointer < diffs.length - 1;){
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
            let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];
            const commonOffset = getCommonSuffix(equality1, edit);
            if (commonOffset) {
                const commonString = edit.substring(edit.length - commonOffset);
                equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
            }
            let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
            for(; edit.charAt(0) === equality2.charAt(0);){
                equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
                const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
                score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
            }
            diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));
        }
        pointer++;
    }
    return diffs;
}
function cleanupMerge(rawDiffs) {
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2));
    diffs.push([
        DIFF_EQUAL,
        ""
    ]);
    let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "", commonlength;
    for(; pointer < diffs.length;)switch(diffs[pointer][0]){
        case DIFF_INSERT:
            countInsert++, textInsert += diffs[pointer][1], pointer++;
            break;
        case DIFF_DELETE:
            countDelete++, textDelete += diffs[pointer][1], pointer++;
            break;
        case DIFF_EQUAL:
            countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [
                DIFF_EQUAL,
                textInsert.substring(0, commonlength)
            ]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [
                DIFF_DELETE,
                textDelete
            ]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [
                DIFF_INSERT,
                textInsert
            ]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
            break;
        default:
            throw new Error("Unknown diff operation");
    }
    diffs[diffs.length - 1][1] === "" && diffs.pop();
    let hasChanges = !1;
    for(pointer = 1; pointer < diffs.length - 1;)diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;
    return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
function trueCount(...args) {
    return args.reduce((n, bool)=>n + (bool ? 1 : 0), 0);
}
function cleanupEfficiency(rawDiffs, editCost = 4) {
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2)), hasChanges = !1;
    const equalities = [];
    let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;
    for(; pointer < diffs.length;)diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [
        DIFF_DELETE,
        lastEquality
    ]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;
    return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
var __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value, __spreadValues$1 = (a, b)=>{
    for(var prop in b || (b = {}))__hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
    if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b))__propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
    return a;
};
const DEFAULT_OPTIONS = {
    /**
   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).
   */ threshold: 0.5,
    /**
   * How far to search for a match (0 = exact location, 1000+ = broad match).
   * A match this many characters away from the expected location will add
   * 1.0 to the score (0.0 is a perfect match).
   */ distance: 1e3
};
function applyDefaults(options) {
    return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);
}
const MAX_BITS$1 = 32;
function bitap(text, pattern, loc, opts = {}) {
    if (pattern.length > MAX_BITS$1) throw new Error("Pattern too long for this browser.");
    const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);
    function getBitapScore(e, x) {
        const accuracy = e / pattern.length, proximity = Math.abs(loc - x);
        return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;
    }
    let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);
    bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));
    const matchmask = 1 << pattern.length - 1;
    bestLoc = -1;
    let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];
    for(let d = 0; d < pattern.length; d++){
        for(binMin = 0, binMid = binMax; binMin < binMid;)getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);
        binMax = binMid;
        let start = Math.max(1, loc - binMid + 1);
        const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for(let j = finish; j >= start; j--){
            const charMatch = s[text.charAt(j - 1)];
            if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {
                const score = getBitapScore(d, j - 1);
                if (score <= scoreThreshold) if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc) start = Math.max(1, 2 * loc - bestLoc);
                else break;
            }
        }
        if (getBitapScore(d + 1, loc) > scoreThreshold) break;
        lastRd = rd;
    }
    return bestLoc;
}
function getAlphabetFromPattern(pattern) {
    const s = {};
    for(let i = 0; i < pattern.length; i++)s[pattern.charAt(i)] = 0;
    for(let i = 0; i < pattern.length; i++)s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
    return s;
}
function match(text, pattern, searchLocation, options = {}) {
    if (text === null || pattern === null || searchLocation === null) throw new Error("Null input. (match())");
    const loc = Math.max(0, Math.min(searchLocation, text.length));
    if (text === pattern) return 0;
    if (text.length) {
        if (text.substring(loc, loc + pattern.length) === pattern) return loc;
    } else return -1;
    return bitap(text, pattern, loc, options);
}
function diffText1(diffs) {
    const text = [];
    for(let x = 0; x < diffs.length; x++)diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);
    return text.join("");
}
function diffText2(diffs) {
    const text = [];
    for(let x = 0; x < diffs.length; x++)diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);
    return text.join("");
}
function levenshtein(diffs) {
    let leven = 0, insertions = 0, deletions = 0;
    for(let x = 0; x < diffs.length; x++){
        const op = diffs[x][0], data = diffs[x][1];
        switch(op){
            case DIFF_INSERT:
                insertions += data.length;
                break;
            case DIFF_DELETE:
                deletions += data.length;
                break;
            case DIFF_EQUAL:
                leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;
                break;
            default:
                throw new Error("Unknown diff operation.");
        }
    }
    return leven += Math.max(insertions, deletions), leven;
}
function xIndex(diffs, location) {
    let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;
    for(x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > location)); x++)lastChars1 = chars1, lastChars2 = chars2;
    return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (location - lastChars1);
}
function countUtf8Bytes(str) {
    let bytes = 0;
    for(let i = 0; i < str.length; i++){
        const codePoint = str.codePointAt(i);
        if (typeof codePoint > "u") throw new Error("Failed to get codepoint");
        bytes += utf8len(codePoint);
    }
    return bytes;
}
function adjustIndiciesToUcs2(patches, base, options = {}) {
    let byteOffset = 0, idx = 0;
    function advanceTo(target) {
        for(; byteOffset < target;){
            const codePoint = base.codePointAt(idx);
            if (typeof codePoint > "u") return idx;
            byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;
        }
        if (!options.allowExceedingIndices && byteOffset !== target) throw new Error("Failed to determine byte offset");
        return idx;
    }
    const adjusted = [];
    for (const patch of patches)adjusted.push({
        diffs: patch.diffs.map((diff2)=>cloneDiff(diff2)),
        start1: advanceTo(patch.start1),
        start2: advanceTo(patch.start2),
        utf8Start1: patch.utf8Start1,
        utf8Start2: patch.utf8Start2,
        length1: patch.length1,
        length2: patch.length2,
        utf8Length1: patch.utf8Length1,
        utf8Length2: patch.utf8Length2
    });
    return adjusted;
}
function utf8len(codePoint) {
    return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;
}
const MAX_BITS = 32, DEFAULT_MARGIN = 4;
function addPadding(patches, margin = DEFAULT_MARGIN) {
    const paddingLength = margin;
    let nullPadding = "";
    for(let x = 1; x <= paddingLength; x++)nullPadding += String.fromCharCode(x);
    for (const p of patches)p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;
    let patch = patches[0], diffs = patch.diffs;
    if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) diffs.unshift([
        DIFF_EQUAL,
        nullPadding
    ]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
    else if (paddingLength > diffs[0][1].length) {
        const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;
        diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
    }
    if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) diffs.push([
        DIFF_EQUAL,
        nullPadding
    ]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
    else if (paddingLength > diffs[diffs.length - 1][1].length) {
        const extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
    }
    return nullPadding;
}
function createPatchObject(start1, start2) {
    return {
        diffs: [],
        start1,
        start2,
        utf8Start1: start1,
        utf8Start2: start2,
        length1: 0,
        length2: 0,
        utf8Length1: 0,
        utf8Length2: 0
    };
}
function splitMax(patches, margin = DEFAULT_MARGIN) {
    const patchSize = MAX_BITS;
    for(let x = 0; x < patches.length; x++){
        if (patches[x].length1 <= patchSize) continue;
        const bigpatch = patches[x];
        patches.splice(x--, 1);
        let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = "";
        for(; bigpatch.diffs.length !== 0;){
            const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);
            let empty = !0;
            if (preContext !== "") {
                const precontextByteCount = countUtf8Bytes(preContext);
                patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([
                    DIFF_EQUAL,
                    preContext
                ]);
            }
            for(; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin;){
                const diffType = bigpatch.diffs[0][0];
                let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);
                if (diffType === DIFF_INSERT) {
                    patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;
                    const diff2 = bigpatch.diffs.shift();
                    diff2 && patch.diffs.push(diff2), empty = !1;
                } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([
                    diffType,
                    diffText
                ]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([
                    diffType,
                    diffText
                ]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));
            }
            preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);
            const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);
            postContext !== "" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([
                DIFF_EQUAL,
                postContext
            ])), empty || patches.splice(++x, 0, patch);
        }
    }
}
function apply(patches, originalText, opts = {}) {
    if (typeof patches == "string") throw new Error("Patches must be an array - pass the patch to `parsePatch()` first");
    let text = originalText;
    if (patches.length === 0) return [
        text,
        []
    ];
    const parsed = adjustIndiciesToUcs2(patches, text, {
        allowExceedingIndices: opts.allowExceedingIndices
    }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);
    text = nullPadding + text + nullPadding, splitMax(parsed, margin);
    let delta = 0;
    const results = [];
    for(let x = 0; x < parsed.length; x++){
        const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);
        let startLoc, endLoc = -1;
        if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1) results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;
        else {
            results[x] = !0, delta = startLoc - expectedLoc;
            let text2;
            if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2) text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);
            else {
                let diffs = diff(text1, text2, {
                    checkLines: !1
                });
                if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) results[x] = !1;
                else {
                    diffs = cleanupSemanticLossless(diffs);
                    let index1 = 0, index2 = 0;
                    for(let y = 0; y < parsed[x].diffs.length; y++){
                        const mod = parsed[x].diffs[y];
                        mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);
                    }
                }
            }
        }
    }
    return text = text.substring(nullPadding.length, text.length - nullPadding.length), [
        text,
        results
    ];
}
var __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value, __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))__hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b))__propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
    return a;
};
const DEFAULT_OPTS = {
    margin: 4
};
function getDefaultOpts(opts = {}) {
    return __spreadValues(__spreadValues({}, DEFAULT_OPTS), opts);
}
function make(a, b, options) {
    if (typeof a == "string" && typeof b == "string") {
        let diffs = diff(a, b, {
            checkLines: !0
        });
        return diffs.length > 2 && (diffs = cleanupSemantic(diffs), diffs = cleanupEfficiency(diffs)), _make(a, diffs, getDefaultOpts(options));
    }
    if (a && Array.isArray(a) && typeof b > "u") return _make(diffText1(a), a, getDefaultOpts(options));
    if (typeof a == "string" && b && Array.isArray(b)) return _make(a, b, getDefaultOpts(options));
    throw new Error("Unknown call format to make()");
}
function _make(textA, diffs, options) {
    if (diffs.length === 0) return [];
    const patches = [];
    let patch = createPatchObject(0, 0), patchDiffLength = 0, charCount1 = 0, charCount2 = 0, utf8Count1 = 0, utf8Count2 = 0, prepatchText = textA, postpatchText = textA;
    for(let x = 0; x < diffs.length; x++){
        const currentDiff = diffs[x], [diffType, diffText] = currentDiff, diffTextLength = diffText.length, diffByteLength = countUtf8Bytes(diffText);
        switch(!patchDiffLength && diffType !== DIFF_EQUAL && (patch.start1 = charCount1, patch.start2 = charCount2, patch.utf8Start1 = utf8Count1, patch.utf8Start2 = utf8Count2), diffType){
            case DIFF_INSERT:
                patch.diffs[patchDiffLength++] = currentDiff, patch.length2 += diffTextLength, patch.utf8Length2 += diffByteLength, postpatchText = postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2);
                break;
            case DIFF_DELETE:
                patch.length1 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.diffs[patchDiffLength++] = currentDiff, postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + diffTextLength);
                break;
            case DIFF_EQUAL:
                diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1 ? (patch.diffs[patchDiffLength++] = currentDiff, patch.length1 += diffTextLength, patch.length2 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.utf8Length2 += diffByteLength) : diffTextLength >= 2 * options.margin && patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch), patch = createPatchObject(-1, -1), patchDiffLength = 0, prepatchText = postpatchText, charCount1 = charCount2, utf8Count1 = utf8Count2);
                break;
            default:
                throw new Error("Unknown diff type");
        }
        diffType !== DIFF_INSERT && (charCount1 += diffTextLength, utf8Count1 += diffByteLength), diffType !== DIFF_DELETE && (charCount2 += diffTextLength, utf8Count2 += diffByteLength);
    }
    return patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch)), patches;
}
function addContext(patch, text, opts) {
    if (text.length === 0) return;
    let pattern = text.substring(patch.start2, patch.start2 + patch.length1), padding = 0;
    for(; text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < MAX_BITS - opts.margin - opts.margin;)padding += opts.margin, pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);
    padding += opts.margin;
    let prefixStart = patch.start2 - padding;
    prefixStart >= 1 && isLowSurrogate(text[prefixStart]) && prefixStart--;
    const prefix = text.substring(prefixStart, patch.start2);
    prefix && patch.diffs.unshift([
        DIFF_EQUAL,
        prefix
    ]);
    const prefixLength = prefix.length, prefixUtf8Length = countUtf8Bytes(prefix);
    let suffixEnd = patch.start2 + patch.length1 + padding;
    suffixEnd < text.length && isLowSurrogate(text[suffixEnd]) && suffixEnd++;
    const suffix = text.substring(patch.start2 + patch.length1, suffixEnd);
    suffix && patch.diffs.push([
        DIFF_EQUAL,
        suffix
    ]);
    const suffixLength = suffix.length, suffixUtf8Length = countUtf8Bytes(suffix);
    patch.start1 -= prefixLength, patch.start2 -= prefixLength, patch.utf8Start1 -= prefixUtf8Length, patch.utf8Start2 -= prefixUtf8Length, patch.length1 += prefixLength + suffixLength, patch.length2 += prefixLength + suffixLength, patch.utf8Length1 += prefixUtf8Length + suffixUtf8Length, patch.utf8Length2 += prefixUtf8Length + suffixUtf8Length;
}
const patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
function parse(textline) {
    if (!textline) return [];
    const patches = [], lines = textline.split(`
`);
    let textPointer = 0;
    for(; textPointer < lines.length;){
        const m = lines[textPointer].match(patchHeader);
        if (!m) throw new Error(`Invalid patch string: ${lines[textPointer]}`);
        const patch = createPatchObject(toInt(m[1]), toInt(m[3]));
        for(patches.push(patch), m[2] === "" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === "0" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === "" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === "0" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length;){
            const currentLine = lines[textPointer], sign = currentLine.charAt(0);
            if (sign === "@") break;
            if (sign === "") {
                textPointer++;
                continue;
            }
            let line;
            try {
                line = decodeURI(currentLine.slice(1));
            } catch (ex) {
                throw new Error(`Illegal escape in parse: ${currentLine}`);
            }
            const utf8Diff = countUtf8Bytes(line) - line.length;
            if (sign === "-") patch.diffs.push([
                DIFF_DELETE,
                line
            ]), patch.length1 -= utf8Diff;
            else if (sign === "+") patch.diffs.push([
                DIFF_INSERT,
                line
            ]), patch.length2 -= utf8Diff;
            else if (sign === " ") patch.diffs.push([
                DIFF_EQUAL,
                line
            ]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;
            else throw new Error(`Invalid patch mode "${sign}" in: ${line}`);
            textPointer++;
        }
    }
    return patches;
}
function toInt(num) {
    return parseInt(num, 10);
}
function stringify(patches) {
    return patches.map(stringifyPatch).join("");
}
function stringifyPatch(patch) {
    const { utf8Length1, utf8Length2, utf8Start1, utf8Start2, diffs } = patch;
    let coords1;
    utf8Length1 === 0 ? coords1 = `${utf8Start1},0` : utf8Length1 === 1 ? coords1 = `${utf8Start1 + 1}` : coords1 = `${utf8Start1 + 1},${utf8Length1}`;
    let coords2;
    utf8Length2 === 0 ? coords2 = `${utf8Start2},0` : utf8Length2 === 1 ? coords2 = `${utf8Start2 + 1}` : coords2 = `${utf8Start2 + 1},${utf8Length2}`;
    const text = [
        `@@ -${coords1} +${coords2} @@
`
    ];
    let op;
    for(let x = 0; x < diffs.length; x++){
        switch(diffs[x][0]){
            case DIFF_INSERT:
                op = "+";
                break;
            case DIFF_DELETE:
                op = "-";
                break;
            case DIFF_EQUAL:
                op = " ";
                break;
            default:
                throw new Error("Unknown patch operation.");
        }
        text[x + 1] = `${op + encodeURI(diffs[x][1])}
`;
    }
    return text.join("").replace(/%20/g, " ");
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/mutator/lib/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BufferedDocument": (()=>BufferedDocument),
    "Mutation": (()=>Mutation),
    "arrayToJSONMatchPath": (()=>arrayToJSONMatchPath),
    "extract": (()=>extract),
    "extractWithPath": (()=>extractWithPath)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isEqual.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/flatten.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/diff-match-patch/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/max.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__uuid$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as uuid>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$compact$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/compact.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("mutator-document");
class ImmutableAccessor {
    _value;
    path;
    constructor(value, path){
        this._value = value, this.path = path || [];
    }
    containerType() {
        return Array.isArray(this._value) ? "array" : this._value !== null && typeof this._value == "object" ? "object" : "primitive";
    }
    // Common reader, supported by all containers
    get() {
        return this._value;
    }
    // Array reader
    length() {
        if (!Array.isArray(this._value)) throw new Error("Won't return length of non-indexable _value");
        return this._value.length;
    }
    getIndex(i) {
        return Array.isArray(this._value) ? i >= this.length() ? null : new ImmutableAccessor(this._value[i], this.path.concat(i)) : !1;
    }
    // Object reader
    hasAttribute(key) {
        return isRecord$1(this._value) ? this._value.hasOwnProperty(key) : !1;
    }
    attributeKeys() {
        return isRecord$1(this._value) ? Object.keys(this._value) : [];
    }
    getAttribute(key) {
        if (!isRecord$1(this._value)) throw new Error("getAttribute only applies to plain objects");
        return this.hasAttribute(key) ? new ImmutableAccessor(this._value[key], this.path.concat(key)) : null;
    }
    // Common writer, supported by all containers
    set(value) {
        return value === this._value ? this : new ImmutableAccessor(value, this.path);
    }
    // array writer interface
    setIndex(i, value) {
        if (!Array.isArray(this._value)) throw new Error("setIndex only applies to arrays");
        if (Object.is(value, this._value[i])) return this;
        const nextValue = this._value.slice();
        return nextValue[i] = value, new ImmutableAccessor(nextValue, this.path);
    }
    setIndexAccessor(i, accessor) {
        return this.setIndex(i, accessor.get());
    }
    unsetIndices(indices) {
        if (!Array.isArray(this._value)) throw new Error("unsetIndices only applies to arrays");
        const length = this._value.length, nextValue = [];
        for(let i = 0; i < length; i++)indices.indexOf(i) === -1 && nextValue.push(this._value[i]);
        return new ImmutableAccessor(nextValue, this.path);
    }
    insertItemsAt(pos, items) {
        if (!Array.isArray(this._value)) throw new Error("insertItemsAt only applies to arrays");
        let nextValue;
        return this._value.length === 0 && pos === 0 ? nextValue = items : nextValue = this._value.slice(0, pos).concat(items).concat(this._value.slice(pos)), new ImmutableAccessor(nextValue, this.path);
    }
    // Object writer interface
    setAttribute(key, value) {
        if (!isRecord$1(this._value)) throw new Error("Unable to set attribute of non-object container");
        if (Object.is(value, this._value[key])) return this;
        const nextValue = Object.assign({}, this._value, {
            [key]: value
        });
        return new ImmutableAccessor(nextValue, this.path);
    }
    setAttributeAccessor(key, accessor) {
        return this.setAttribute(key, accessor.get());
    }
    unsetAttribute(key) {
        if (!isRecord$1(this._value)) throw new Error("Unable to unset attribute of non-object container");
        const nextValue = Object.assign({}, this._value);
        return delete nextValue[key], new ImmutableAccessor(nextValue, this.path);
    }
}
function isRecord$1(value) {
    return value !== null && typeof value == "object";
}
function isRecord(value) {
    return value !== null && typeof value == "object";
}
const IS_DOTTABLE = /^[a-z_$]+/;
function arrayToJSONMatchPath(pathArray) {
    let path = "";
    return pathArray.forEach((segment, index)=>{
        path += stringifySegment(segment, index === 0);
    }), path;
}
function stringifySegment(segment, hasLeading) {
    if (typeof segment == "number") return `[${segment}]`;
    if (isRecord(segment)) {
        const seg = segment;
        return Object.keys(segment).map((key)=>isPrimitiveValue(seg[key]) ? `[${key}=="${seg[key]}"]` : "").join("");
    }
    return typeof segment == "string" && IS_DOTTABLE.test(segment) ? hasLeading ? segment : `.${segment}` : `['${segment}']`;
}
function isPrimitiveValue(val) {
    switch(typeof val){
        case "number":
        case "string":
        case "boolean":
            return !0;
        default:
            return !1;
    }
}
function descend$1(tail) {
    const [head, newTail] = splitIfPath(tail);
    if (!head) throw new Error("Head cannot be null");
    return spreadIfUnionHead(head, newTail);
}
function splitIfPath(tail) {
    if (tail.type !== "path") return [
        tail,
        null
    ];
    const nodes = tail.nodes;
    return nodes.length === 0 ? [
        null,
        null
    ] : nodes.length === 1 ? [
        nodes[0],
        null
    ] : [
        nodes[0],
        {
            type: "path",
            nodes: nodes.slice(1)
        }
    ];
}
function concatPaths(path1, path2) {
    if (!path1 && !path2) return null;
    const nodes1 = path1 ? path1.nodes : [], nodes2 = path2 ? path2.nodes : [];
    return {
        type: "path",
        nodes: nodes1.concat(nodes2)
    };
}
function spreadIfUnionHead(head, tail) {
    return head.type !== "union" ? [
        [
            head,
            tail
        ]
    ] : head.nodes.map((node)=>{
        if (node.type === "path") {
            const [subHead, subTail] = splitIfPath(node);
            return [
                subHead,
                concatPaths(subTail, tail)
            ];
        }
        return [
            node,
            tail
        ];
    });
}
const digitChar = /[0-9]/, attributeCharMatcher = /^[a-zA-Z0-9_]$/, attributeFirstCharMatcher = /^[a-zA-Z_]$/, symbols = {
    // NOTE: These are compared against in order of definition,
    // thus '==' must come before '=', '>=' before '>', etc.
    operator: [
        "..",
        ".",
        ",",
        ":",
        "?"
    ],
    comparator: [
        ">=",
        "<=",
        "<",
        ">",
        "==",
        "!="
    ],
    keyword: [
        "$",
        "@"
    ],
    boolean: [
        "true",
        "false"
    ],
    paren: [
        "[",
        "]"
    ]
}, symbolClasses = Object.keys(symbols);
class Tokenizer {
    source;
    i;
    length;
    tokenizers;
    constructor(path){
        this.source = path, this.length = path.length, this.i = 0, this.tokenizers = [
            this.tokenizeSymbol,
            this.tokenizeIdentifier,
            this.tokenizeNumber,
            this.tokenizeQuoted
        ].map((fn)=>fn.bind(this));
    }
    tokenize() {
        const result = [];
        for(; !this.EOF();){
            this.chompWhitespace();
            let token = null;
            if (!this.tokenizers.some((tokenizer)=>(token = tokenizer(), !!token)) || !token) throw new Error(`Invalid tokens in jsonpath '${this.source}' @ ${this.i}`);
            result.push(token);
        }
        return result;
    }
    takeWhile(fn) {
        const start = this.i;
        let result = "";
        for(; !this.EOF();){
            const nextChar = fn(this.source[this.i]);
            if (nextChar === null) break;
            result += nextChar, this.i++;
        }
        return this.i === start ? null : result;
    }
    EOF() {
        return this.i >= this.length;
    }
    peek() {
        return this.EOF() ? null : this.source[this.i];
    }
    consume(str) {
        if (this.i + str.length > this.length) throw new Error(`Expected ${str} at end of jsonpath`);
        if (str === this.source.slice(this.i, this.i + str.length)) this.i += str.length;
        else throw new Error(`Expected "${str}", but source contained "${this.source.slice()}`);
    }
    // Tries to match the upcoming bit of string with the provided string. If it matches, returns
    // the string, then advances the read pointer to the next bit. If not, returns null and nothing
    // happens.
    tryConsume(str) {
        if (this.i + str.length > this.length) return null;
        if (str === this.source.slice(this.i, this.i + str.length)) {
            if (str[0].match(attributeCharMatcher) && this.length > this.i + str.length) {
                const nextChar = this.source[this.i + str.length];
                if (nextChar && nextChar.match(attributeCharMatcher)) return null;
            }
            return this.i += str.length, str;
        }
        return null;
    }
    chompWhitespace() {
        this.takeWhile((char)=>char === " " ? "" : null);
    }
    tokenizeQuoted() {
        const quote = this.peek();
        if (quote === "'" || quote === '"') {
            this.consume(quote);
            let escape = !1;
            const inner = this.takeWhile((char)=>escape ? (escape = !1, char) : char === "\\" ? (escape = !0, "") : char != quote ? char : null);
            return this.consume(quote), {
                type: "quoted",
                value: inner,
                quote: quote === '"' ? "double" : "single"
            };
        }
        return null;
    }
    tokenizeIdentifier() {
        let first = !0;
        const identifier = this.takeWhile((char)=>first ? (first = !1, char.match(attributeFirstCharMatcher) ? char : null) : char.match(attributeCharMatcher) ? char : null);
        return identifier !== null ? {
            type: "identifier",
            name: identifier
        } : null;
    }
    tokenizeNumber() {
        const start = this.i;
        let dotSeen = !1, digitSeen = !1, negative = !1;
        this.peek() === "-" && (negative = !0, this.consume("-"));
        const number = this.takeWhile((char)=>char === "." && !dotSeen && digitSeen ? (dotSeen = !0, char) : (digitSeen = !0, char.match(digitChar) ? char : null));
        return number !== null ? {
            type: "number",
            value: negative ? -number : +number,
            raw: negative ? `-${number}` : number
        } : (this.i = start, null);
    }
    tokenizeSymbol() {
        for (const symbolClass of symbolClasses){
            const symbol = symbols[symbolClass].find((pattern)=>this.tryConsume(pattern));
            if (symbol) return {
                type: symbolClass,
                symbol
            };
        }
        return null;
    }
}
function tokenize(jsonpath) {
    return new Tokenizer(jsonpath).tokenize();
}
class Parser {
    tokens;
    length;
    i;
    constructor(path){
        this.tokens = tokenize(path), this.length = this.tokens.length, this.i = 0;
    }
    parse() {
        return this.parsePath();
    }
    EOF() {
        return this.i >= this.length;
    }
    // Look at upcoming token
    peek() {
        return this.EOF() ? null : this.tokens[this.i];
    }
    consume() {
        const result = this.peek();
        return this.i += 1, result;
    }
    // Return next token if it matches the pattern
    probe(pattern) {
        const token = this.peek();
        if (!token) return null;
        const record = token;
        return Object.keys(pattern).every((key)=>key in token && pattern[key] === record[key]) ? token : null;
    }
    // Return and consume next token if it matches the pattern
    match(pattern) {
        return this.probe(pattern) ? this.consume() : null;
    }
    parseAttribute() {
        const token = this.match({
            type: "identifier"
        });
        if (token && token.type === "identifier") return {
            type: "attribute",
            name: token.name
        };
        const quoted = this.match({
            type: "quoted",
            quote: "single"
        });
        return quoted && quoted.type === "quoted" ? {
            type: "attribute",
            name: quoted.value || ""
        } : null;
    }
    parseAlias() {
        return this.match({
            type: "keyword",
            symbol: "@"
        }) || this.match({
            type: "keyword",
            symbol: "$"
        }) ? {
            type: "alias",
            target: "self"
        } : null;
    }
    parseNumber() {
        const token = this.match({
            type: "number"
        });
        return token && token.type === "number" ? {
            type: "number",
            value: token.value
        } : null;
    }
    parseNumberValue() {
        const expr = this.parseNumber();
        return expr ? expr.value : null;
    }
    parseSliceSelector() {
        const start = this.i, rangeStart = this.parseNumberValue();
        if (!this.match({
            type: "operator",
            symbol: ":"
        })) return rangeStart === null ? (this.i = start, null) : {
            type: "index",
            value: rangeStart
        };
        const result = {
            type: "range",
            start: rangeStart,
            end: this.parseNumberValue()
        };
        return this.match({
            type: "operator",
            symbol: ":"
        }) && (result.step = this.parseNumberValue()), result.start === null && result.end === null ? (this.i = start, null) : result;
    }
    parseValueReference() {
        return this.parseAttribute() || this.parseSliceSelector();
    }
    parseLiteralValue() {
        const literalString = this.match({
            type: "quoted",
            quote: "double"
        });
        if (literalString && literalString.type === "quoted") return {
            type: "string",
            value: literalString.value || ""
        };
        const literalBoolean = this.match({
            type: "boolean"
        });
        return literalBoolean && literalBoolean.type === "boolean" ? {
            type: "boolean",
            value: literalBoolean.symbol === "true"
        } : this.parseNumber();
    }
    // TODO: Reorder constraints so that literal value is always on rhs, and variable is always
    // on lhs.
    parseFilterExpression() {
        const start = this.i, expr = this.parseAttribute() || this.parseAlias();
        if (!expr) return null;
        if (this.match({
            type: "operator",
            symbol: "?"
        })) return {
            type: "constraint",
            operator: "?",
            lhs: expr
        };
        const binOp = this.match({
            type: "comparator"
        });
        if (!binOp || binOp.type !== "comparator") return this.i = start, null;
        const lhs = expr, rhs = this.parseLiteralValue();
        if (!rhs) throw new Error(`Operator ${binOp.symbol} needs a literal value at the right hand side`);
        return {
            type: "constraint",
            operator: binOp.symbol,
            lhs,
            rhs
        };
    }
    parseExpression() {
        return this.parseFilterExpression() || this.parseValueReference();
    }
    parseUnion() {
        if (!this.match({
            type: "paren",
            symbol: "["
        })) return null;
        const terms = [];
        let expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference();
        for(; expr && (terms.push(expr), !this.match({
            type: "paren",
            symbol: "]"
        }));){
            if (!this.match({
                type: "operator",
                symbol: ","
            })) throw new Error("Expected ]");
            if (expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference(), !expr) throw new Error("Expected expression following ','");
        }
        return {
            type: "union",
            nodes: terms
        };
    }
    parseRecursive() {
        if (!this.match({
            type: "operator",
            symbol: ".."
        })) return null;
        const subpath = this.parsePath();
        if (!subpath) throw new Error("Expected path following '..' operator");
        return {
            type: "recursive",
            term: subpath
        };
    }
    parsePath() {
        const nodes = [], expr = this.parseAttribute() || this.parseUnion() || this.parseRecursive();
        if (!expr) return null;
        for(nodes.push(expr); !this.EOF();)if (this.match({
            type: "operator",
            symbol: "."
        })) {
            const attr = this.parseAttribute();
            if (!attr) throw new Error("Expected attribute name following '.");
            nodes.push(attr);
            continue;
        } else if (this.probe({
            type: "paren",
            symbol: "["
        })) {
            const union = this.parseUnion();
            if (!union) throw new Error("Expected union following '['");
            nodes.push(union);
        } else {
            const recursive = this.parseRecursive();
            recursive && nodes.push(recursive);
            break;
        }
        return nodes.length === 1 ? nodes[0] : {
            type: "path",
            nodes
        };
    }
}
function parseJsonPath(path) {
    const parsed = new Parser(path).parse();
    if (!parsed) throw new Error(`Failed to parse JSON path "${path}"`);
    return parsed;
}
function toPath(expr) {
    return toPathInner(expr, !1);
}
function toPathInner(expr, inUnion) {
    switch(expr.type){
        case "attribute":
            return expr.name;
        case "alias":
            return expr.target === "self" ? "@" : "$";
        case "number":
            return `${expr.value}`;
        case "range":
            {
                const result = [];
                return inUnion || result.push("["), expr.start && result.push(`${expr.start}`), result.push(":"), expr.end && result.push(`${expr.end}`), expr.step && result.push(`:${expr.step}`), inUnion || result.push("]"), result.join("");
            }
        case "index":
            return inUnion ? `${expr.value}` : `[${expr.value}]`;
        case "constraint":
            {
                const rhs = expr.rhs ? ` ${toPathInner(expr.rhs, !1)}` : "", inner = `${toPathInner(expr.lhs, !1)} ${expr.operator}${rhs}`;
                return inUnion ? inner : `[${inner}]`;
            }
        case "string":
            return JSON.stringify(expr.value);
        case "path":
            {
                const result = [], nodes = expr.nodes.slice();
                for(; nodes.length > 0;){
                    const node = nodes.shift();
                    node && result.push(toPath(node));
                    const upcoming = nodes[0];
                    upcoming && toPathInner(upcoming, !1)[0] !== "[" && result.push(".");
                }
                return result.join("");
            }
        case "union":
            return `[${expr.nodes.map((e)=>toPathInner(e, !0)).join(",")}]`;
        default:
            throw new Error(`Unknown node type ${expr.type}`);
        case "recursive":
            return `..${toPathInner(expr.term, !1)}`;
    }
}
class Expression {
    expr;
    constructor(expr){
        if (!expr) throw new Error("Attempted to create Expression from null-value");
        if ("expr" in expr ? this.expr = expr.expr : this.expr = expr, !("type" in this.expr)) throw new Error("Attempt to create Expression for expression with no type");
    }
    isPath() {
        return this.expr.type === "path";
    }
    isUnion() {
        return this.expr.type === "union";
    }
    isCollection() {
        return this.isPath() || this.isUnion();
    }
    isConstraint() {
        return this.expr.type === "constraint";
    }
    isRecursive() {
        return this.expr.type === "recursive";
    }
    isExistenceConstraint() {
        return this.expr.type === "constraint" && this.expr.operator === "?";
    }
    isIndex() {
        return this.expr.type === "index";
    }
    isRange() {
        return this.expr.type === "range";
    }
    expandRange(probe) {
        const probeLength = ()=>{
            if (!probe) throw new Error("expandRange() required a probe that was not passed");
            return probe.length();
        };
        let start = "start" in this.expr && this.expr.start || 0;
        start = interpretNegativeIndex(start, probe);
        let end = "end" in this.expr && this.expr.end || probeLength();
        end = interpretNegativeIndex(end, probe);
        const step = "step" in this.expr && this.expr.step || 1;
        return {
            start,
            end,
            step
        };
    }
    isAttributeReference() {
        return this.expr.type === "attribute";
    }
    // Is a range or index -> something referencing indexes
    isIndexReference() {
        return this.isIndex() || this.isRange();
    }
    name() {
        return "name" in this.expr ? this.expr.name : "";
    }
    isSelfReference() {
        return this.expr.type === "alias" && this.expr.target === "self";
    }
    constraintTargetIsSelf() {
        return this.expr.type === "constraint" && this.expr.lhs.type === "alias" && this.expr.lhs.target === "self";
    }
    constraintTargetIsAttribute() {
        return this.expr.type === "constraint" && this.expr.lhs.type === "attribute";
    }
    testConstraint(probe) {
        const expr = this.expr;
        if (expr.type === "constraint" && expr.lhs.type === "alias" && expr.lhs.target === "self") {
            if (probe.containerType() !== "primitive") return !1;
            if (expr.type === "constraint" && expr.operator === "?") return !0;
            const lhs2 = probe.get(), rhs2 = expr.rhs && "value" in expr.rhs ? expr.rhs.value : void 0;
            return testBinaryOperator(lhs2, expr.operator, rhs2);
        }
        if (expr.type !== "constraint") return !1;
        const lhs = expr.lhs;
        if (!lhs) throw new Error("No LHS of expression");
        if (lhs.type !== "attribute") throw new Error(`Constraint target ${lhs.type} not supported`);
        if (probe.containerType() !== "object") return !1;
        const lhsValue = probe.getAttribute(lhs.name);
        if (lhsValue == null || lhsValue.containerType() !== "primitive") return !1;
        if (this.isExistenceConstraint()) return !0;
        const rhs = expr.rhs && "value" in expr.rhs ? expr.rhs.value : void 0;
        return testBinaryOperator(lhsValue.get(), expr.operator, rhs);
    }
    pathNodes() {
        return this.expr.type === "path" ? this.expr.nodes : [
            this.expr
        ];
    }
    prepend(node) {
        return node ? new Expression({
            type: "path",
            nodes: node.pathNodes().concat(this.pathNodes())
        }) : this;
    }
    concat(other) {
        return other ? other.prepend(this) : this;
    }
    descend() {
        return descend$1(this.expr).map((headTail)=>{
            const [head, tail] = headTail;
            return {
                head: head ? new Expression(head) : null,
                tail: tail ? new Expression(tail) : null
            };
        });
    }
    unwrapRecursive() {
        if (this.expr.type !== "recursive") throw new Error(`Attempt to unwrap recursive on type ${this.expr.type}`);
        return new Expression(this.expr.term);
    }
    toIndicies(probe) {
        if (this.expr.type !== "index" && this.expr.type !== "range") throw new Error("Node cannot be converted to indexes");
        if (this.expr.type === "index") return [
            interpretNegativeIndex(this.expr.value, probe)
        ];
        const result = [], range = this.expandRange(probe);
        let { start, end } = range;
        range.step < 0 && ([start, end] = [
            end,
            start
        ]);
        for(let i = start; i < end; i++)result.push(i);
        return result;
    }
    toFieldReferences() {
        if (this.isIndexReference()) return this.toIndicies();
        if (this.expr.type === "attribute") return [
            this.expr.name
        ];
        throw new Error(`Can't convert ${this.expr.type} to field references`);
    }
    toString() {
        return toPath(this.expr);
    }
    static fromPath(path) {
        const parsed = parseJsonPath(path);
        if (!parsed) throw new Error(`Failed to parse path "${path}"`);
        return new Expression(parsed);
    }
    static attributeReference(name) {
        return new Expression({
            type: "attribute",
            name
        });
    }
    static indexReference(i) {
        return new Expression({
            type: "index",
            value: i
        });
    }
}
function testBinaryOperator(lhsValue, operator, rhsValue) {
    switch(operator){
        case ">":
            return lhsValue > rhsValue;
        case ">=":
            return lhsValue >= rhsValue;
        case "<":
            return lhsValue < rhsValue;
        case "<=":
            return lhsValue <= rhsValue;
        case "==":
            return lhsValue === rhsValue;
        case "!=":
            return lhsValue !== rhsValue;
        default:
            throw new Error(`Unsupported binary operator ${operator}`);
    }
}
function interpretNegativeIndex(index, probe) {
    if (index >= 0) return index;
    if (!probe) throw new Error("interpretNegativeIndex() must have a probe when < 0");
    return index + probe.length();
}
class Descender {
    head;
    tail;
    constructor(head, tail){
        this.head = head, this.tail = tail;
    }
    // Iterate this descender once processing any constraints that are
    // resolvable on the current value. Returns an array of new descenders
    // that are guaranteed to be without constraints in the head
    iterate(probe) {
        let result = [
            this
        ];
        if (this.head && this.head.isConstraint()) {
            let anyConstraints = !0;
            for(; anyConstraints;)result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result.map((descender)=>descender.iterateConstraints(probe))), anyConstraints = result.some((descender)=>descender.head && descender.head.isConstraint());
        }
        return result;
    }
    isRecursive() {
        return !!(this.head && this.head.isRecursive());
    }
    hasArrived() {
        return this.head === null && this.tail === null;
    }
    extractRecursives() {
        if (this.head && this.head.isRecursive()) {
            const term = this.head.unwrapRecursive();
            return new Descender(null, term.concat(this.tail)).descend();
        }
        return [];
    }
    iterateConstraints(probe) {
        const head = this.head;
        if (head === null || !head.isConstraint()) return [
            this
        ];
        const result = [];
        if (probe.containerType() === "primitive" && head.constraintTargetIsSelf()) return head.testConstraint(probe) && result.push(...this.descend()), result;
        if (probe.containerType() === "array") {
            const length = probe.length();
            for(let i = 0; i < length; i++){
                const constraint = probe.getIndex(i);
                constraint && head.testConstraint(constraint) && result.push(new Descender(new Expression({
                    type: "index",
                    value: i
                }), this.tail));
            }
            return result;
        }
        return probe.containerType() === "object" ? head.constraintTargetIsSelf() ? [] : head.testConstraint(probe) ? this.descend() : result : result;
    }
    descend() {
        return this.tail ? this.tail.descend().map((ht)=>new Descender(ht.head, ht.tail)) : [
            new Descender(null, null)
        ];
    }
    toString() {
        const result = [
            "<"
        ];
        return this.head && result.push(this.head.toString()), result.push("|"), this.tail && result.push(this.tail.toString()), result.push(">"), result.join("");
    }
}
class Matcher {
    active;
    recursives;
    payload;
    constructor(active, parent){
        this.active = active || [], parent ? (this.recursives = parent.recursives, this.payload = parent.payload) : this.recursives = [], this.extractRecursives();
    }
    setPayload(payload) {
        return this.payload = payload, this;
    }
    // Moves any recursive descenders onto the recursive track, removing them from
    // the active set
    extractRecursives() {
        this.active = this.active.filter((descender)=>descender.isRecursive() ? (this.recursives.push(...descender.extractRecursives()), !1) : !0);
    }
    // Find recursives that are relevant now and should be considered part of the active set
    activeRecursives(probe) {
        return this.recursives.filter((descender)=>{
            const head = descender.head;
            return head ? head.isConstraint() || probe.containerType() === "array" && head.isIndexReference() ? !0 : probe.containerType() === "object" ? head.isAttributeReference() && probe.hasAttribute(head.name()) : !1 : !1;
        });
    }
    match(probe) {
        return this.iterate(probe).extractMatches(probe);
    }
    iterate(probe) {
        const newActiveSet = [];
        return this.active.concat(this.activeRecursives(probe)).forEach((descender)=>{
            newActiveSet.push(...descender.iterate(probe));
        }), new Matcher(newActiveSet, this);
    }
    // Returns true if any of the descenders in the active or recursive set
    // consider the current state a final destination
    isDestination() {
        return this.active.some((descender)=>descender.hasArrived());
    }
    hasRecursives() {
        return this.recursives.length > 0;
    }
    // Returns any payload delivieries and leads that needs to be followed to complete
    // the process.
    extractMatches(probe) {
        const leads = [], targets = [];
        if (this.active.forEach((descender)=>{
            if (descender.hasArrived()) {
                targets.push(new Expression({
                    type: "alias",
                    target: "self"
                }));
                return;
            }
            const descenderHead = descender.head;
            if (descenderHead && !(probe.containerType() === "array" && !descenderHead.isIndexReference()) && !(probe.containerType() === "object" && !descenderHead.isAttributeReference())) if (descender.tail) {
                const matcher = new Matcher(descender.descend(), this);
                descenderHead.toFieldReferences().forEach(()=>{
                    leads.push({
                        target: descenderHead,
                        matcher
                    });
                });
            } else targets.push(descenderHead);
        }), this.hasRecursives()) {
            const recursivesMatcher = new Matcher([], this);
            if (probe.containerType() === "array") {
                const length = probe.length();
                for(let i = 0; i < length; i++)leads.push({
                    target: Expression.indexReference(i),
                    matcher: recursivesMatcher
                });
            } else probe.containerType() === "object" && probe.attributeKeys().forEach((name)=>{
                leads.push({
                    target: Expression.attributeReference(name),
                    matcher: recursivesMatcher
                });
            });
        }
        return targets.length > 0 ? {
            leads,
            delivery: {
                targets,
                payload: this.payload
            }
        } : {
            leads
        };
    }
    static fromPath(jsonpath) {
        const path = parseJsonPath(jsonpath);
        if (!path) throw new Error(`Failed to parse path from "${jsonpath}"`);
        const descender = new Descender(null, new Expression(path));
        return new Matcher(descender.descend());
    }
}
class PlainProbe {
    _value;
    path;
    constructor(value, path){
        this._value = value, this.path = path || [];
    }
    containerType() {
        return Array.isArray(this._value) ? "array" : this._value !== null && typeof this._value == "object" ? "object" : "primitive";
    }
    length() {
        if (!Array.isArray(this._value)) throw new Error("Won't return length of non-indexable _value");
        return this._value.length;
    }
    getIndex(i) {
        return Array.isArray(this._value) ? i >= this.length() ? null : new PlainProbe(this._value[i], this.path.concat(i)) : !1;
    }
    hasAttribute(key) {
        return isRecord(this._value) ? this._value.hasOwnProperty(key) : !1;
    }
    attributeKeys() {
        return isRecord(this._value) ? Object.keys(this._value) : [];
    }
    getAttribute(key) {
        if (!isRecord(this._value)) throw new Error("getAttribute only applies to plain objects");
        return this.hasAttribute(key) ? new PlainProbe(this._value[key], this.path.concat(key)) : null;
    }
    get() {
        return this._value;
    }
}
function extractAccessors(path, value) {
    const result = [], matcher = Matcher.fromPath(path).setPayload(function(values) {
        result.push(...values);
    }), accessor = new PlainProbe(value);
    return descend(matcher, accessor), result;
}
function descend(matcher, accessor) {
    const { leads, delivery } = matcher.match(accessor);
    leads.forEach((lead)=>{
        accessorsFromTarget(lead.target, accessor).forEach((childAccessor)=>{
            descend(lead.matcher, childAccessor);
        });
    }), delivery && delivery.targets.forEach((target)=>{
        typeof delivery.payload == "function" && delivery.payload(accessorsFromTarget(target, accessor));
    });
}
function accessorsFromTarget(target, accessor) {
    const result = [];
    if (target.isIndexReference()) target.toIndicies(accessor).forEach((i)=>{
        result.push(accessor.getIndex(i));
    });
    else if (target.isAttributeReference()) result.push(accessor.getAttribute(target.name()));
    else if (target.isSelfReference()) result.push(accessor);
    else throw new Error(`Unable to derive accessor for target ${target.toString()}`);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$compact$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result);
}
function extract(path, value) {
    return extractAccessors(path, value).map((acc)=>acc.get());
}
function extractWithPath(path, value) {
    return extractAccessors(path, value).map((acc)=>({
            path: acc.path,
            value: acc.get()
        }));
}
function applyPatch(patch, oldValue) {
    if (typeof oldValue != "string") return oldValue;
    const [result] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPatches"])(patch, oldValue, {
        allowExceedingIndices: !0
    });
    return result;
}
class DiffMatchPatch {
    path;
    dmpPatch;
    id;
    constructor(id, path, dmpPatchSrc){
        this.id = id, this.path = path, this.dmpPatch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parsePatch"])(dmpPatchSrc);
    }
    apply(targets, accessor) {
        let result = accessor;
        if (result.containerType() === "primitive") return result;
        for (const target of targets){
            if (target.isIndexReference()) {
                for (const index of target.toIndicies(accessor)){
                    const item = result.getIndex(index);
                    if (!item) continue;
                    const oldValue = item.get(), nextValue = applyPatch(this.dmpPatch, oldValue);
                    result = result.setIndex(index, nextValue);
                }
                continue;
            }
            if (target.isAttributeReference() && result.hasAttribute(target.name())) {
                const attribute = result.getAttribute(target.name());
                if (!attribute) continue;
                const oldValue = attribute.get(), nextValue = applyPatch(this.dmpPatch, oldValue);
                result = result.setAttribute(target.name(), nextValue);
                continue;
            }
            throw new Error(`Unable to apply diffMatchPatch to target ${target.toString()}`);
        }
        return result;
    }
}
function performIncrement(previousValue, delta) {
    return typeof previousValue != "number" || !Number.isFinite(previousValue) ? previousValue : previousValue + delta;
}
class IncPatch {
    path;
    value;
    id;
    constructor(id, path, value){
        this.path = path, this.value = value, this.id = id;
    }
    apply(targets, accessor) {
        let result = accessor;
        if (result.containerType() === "primitive") return result;
        for (const target of targets){
            if (target.isIndexReference()) {
                for (const index of target.toIndicies(accessor)){
                    const item = result.getIndex(index);
                    if (!item) continue;
                    const previousValue = item.get();
                    result = result.setIndex(index, performIncrement(previousValue, this.value));
                }
                continue;
            }
            if (target.isAttributeReference()) {
                const attribute = result.getAttribute(target.name());
                if (!attribute) continue;
                const previousValue = attribute.get();
                result = result.setAttribute(target.name(), performIncrement(previousValue, this.value));
                continue;
            }
            throw new Error(`Unable to apply to target ${target.toString()}`);
        }
        return result;
    }
}
function targetsToIndicies(targets, accessor) {
    const result = [];
    return targets.forEach((target)=>{
        target.isIndexReference() && result.push(...target.toIndicies(accessor));
    }), result.sort();
}
class InsertPatch {
    location;
    path;
    items;
    id;
    constructor(id, location, path, items){
        this.id = id, this.location = location, this.path = path, this.items = items;
    }
    apply(targets, accessor) {
        let result = accessor;
        if (accessor.containerType() !== "array") throw new Error("Attempt to apply insert patch to non-array value");
        switch(this.location){
            case "before":
                {
                    const pos = minIndex(targets, accessor);
                    result = result.insertItemsAt(pos, this.items);
                    break;
                }
            case "after":
                {
                    const pos = maxIndex(targets, accessor);
                    result = result.insertItemsAt(pos + 1, this.items);
                    break;
                }
            case "replace":
                {
                    const indicies = targetsToIndicies(targets, accessor);
                    result = result.unsetIndices(indicies), result = result.insertItemsAt(indicies[0], this.items);
                    break;
                }
            default:
                throw new Error(`Unsupported location atm: ${this.location}`);
        }
        return result;
    }
}
function minIndex(targets, accessor) {
    let result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(targetsToIndicies(targets, accessor)) || 0;
    return targets.forEach((target)=>{
        if (target.isRange()) {
            const { start } = target.expandRange();
            start < result && (result = start);
        }
    }), result;
}
function maxIndex(targets, accessor) {
    let result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(targetsToIndicies(targets, accessor)) || 0;
    return targets.forEach((target)=>{
        if (target.isRange()) {
            const { end } = target.expandRange();
            end > result && (result = end);
        }
    }), result;
}
class SetIfMissingPatch {
    id;
    path;
    value;
    constructor(id, path, value){
        this.id = id, this.path = path, this.value = value;
    }
    apply(targets, accessor) {
        let result = accessor;
        return targets.forEach((target)=>{
            if (!target.isIndexReference()) if (target.isAttributeReference()) result.containerType() === "primitive" ? result = result.set({
                [target.name()]: this.value
            }) : result.hasAttribute(target.name()) || (result = accessor.setAttribute(target.name(), this.value));
            else throw new Error(`Unable to apply to target ${target.toString()}`);
        }), result;
    }
}
class SetPatch {
    id;
    path;
    value;
    constructor(id, path, value){
        this.id = id, this.path = path, this.value = value;
    }
    apply(targets, accessor) {
        let result = accessor;
        return targets.forEach((target)=>{
            if (target.isSelfReference()) result = result.set(this.value);
            else if (target.isIndexReference()) target.toIndicies(accessor).forEach((i)=>{
                result = result.setIndex(i, this.value);
            });
            else if (target.isAttributeReference()) result.containerType() === "primitive" ? result = result.set({
                [target.name()]: this.value
            }) : result = result.setAttribute(target.name(), this.value);
            else throw new Error(`Unable to apply to target ${target.toString()}`);
        }), result;
    }
}
class UnsetPatch {
    id;
    path;
    value;
    constructor(id, path){
        this.id = id, this.path = path;
    }
    // eslint-disable-next-line class-methods-use-this
    apply(targets, accessor) {
        let result = accessor;
        switch(accessor.containerType()){
            case "array":
                result = result.unsetIndices(targetsToIndicies(targets, accessor));
                break;
            case "object":
                targets.forEach((target)=>{
                    result = result.unsetAttribute(target.name());
                });
                break;
            default:
                throw new Error("Target value is neither indexable or an object. This error should potentially just be silently ignored?");
        }
        return result;
    }
}
function parsePatch(patch) {
    const result = [];
    if (Array.isArray(patch)) return patch.reduce((r, p)=>r.concat(parsePatch(p)), result);
    const { set, setIfMissing, unset, diffMatchPatch, inc, dec, insert } = patch;
    if (setIfMissing && Object.keys(setIfMissing).forEach((path)=>{
        result.push(new SetIfMissingPatch(patch.id, path, setIfMissing[path]));
    }), set && Object.keys(set).forEach((path)=>{
        result.push(new SetPatch(patch.id, path, set[path]));
    }), unset && unset.forEach((path)=>{
        result.push(new UnsetPatch(patch.id, path));
    }), diffMatchPatch && Object.keys(diffMatchPatch).forEach((path)=>{
        result.push(new DiffMatchPatch(patch.id, path, diffMatchPatch[path]));
    }), inc && Object.keys(inc).forEach((path)=>{
        result.push(new IncPatch(patch.id, path, inc[path]));
    }), dec && Object.keys(dec).forEach((path)=>{
        result.push(new IncPatch(patch.id, path, -dec[path]));
    }), insert) {
        let location, path;
        const spec = insert;
        if ("before" in spec) location = "before", path = spec.before;
        else if ("after" in spec) location = "after", path = spec.after;
        else if ("replace" in spec) location = "replace", path = spec.replace;
        else throw new Error("Invalid insert patch");
        result.push(new InsertPatch(patch.id, location, path, spec.items));
    }
    return result;
}
class Patcher {
    patches;
    constructor(patch){
        this.patches = parsePatch(patch);
    }
    apply(value) {
        const accessor = new ImmutableAccessor(value);
        return this.applyViaAccessor(accessor).get();
    }
    // If you want to use your own accessor implementation, you can use this method
    // to invoke the patcher. Since all subsequent accessors for children of this accessor
    // are obtained through the methods in the accessors, you retain full control of the
    // implementation throguhgout the application. Have a look in ImmutableAccessor
    // to see an example of how accessors are implemented.
    applyViaAccessor(accessor) {
        let result = accessor;
        const idAccessor = accessor.getAttribute("_id");
        if (!idAccessor) throw new Error("Cannot apply patch to document with no _id");
        const id = idAccessor.get();
        for (const patch of this.patches){
            if (patch.id !== id) continue;
            const matcher = Matcher.fromPath(patch.path).setPayload(patch);
            result = process(matcher, result);
        }
        return result;
    }
}
function process(matcher, accessor) {
    const isSetPatch = matcher.payload instanceof SetPatch || matcher.payload instanceof SetIfMissingPatch;
    let result = accessor;
    const { leads, delivery } = matcher.match(accessor);
    return leads.forEach((lead)=>{
        if (lead.target.isIndexReference()) lead.target.toIndicies().forEach((i)=>{
            const item = result.getIndex(i);
            if (!item) throw new Error("Index out of bounds");
            result = result.setIndexAccessor(i, process(lead.matcher, item));
        });
        else if (lead.target.isAttributeReference()) {
            isSetPatch && result.containerType() === "primitive" && (result = result.set({}));
            let oldValueAccessor = result.getAttribute(lead.target.name());
            if (!oldValueAccessor && isSetPatch && (result = result.setAttribute(lead.target.name(), {}), oldValueAccessor = result.getAttribute(lead.target.name())), !oldValueAccessor) return;
            const newValueAccessor = process(lead.matcher, oldValueAccessor);
            oldValueAccessor !== newValueAccessor && (result = result.setAttributeAccessor(lead.target.name(), newValueAccessor));
        } else throw new Error(`Unable to handle target ${lead.target.toString()}`);
    }), delivery && isPatcher(delivery.payload) && (result = delivery.payload.apply(delivery.targets, result)), result;
}
function isPatcher(payload) {
    return !!(payload && typeof payload == "object" && payload !== null && "apply" in payload && typeof payload.apply == "function");
}
const luid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__uuid$3e$__["uuid"];
class Mutation {
    params;
    compiled;
    _appliesToMissingDocument;
    constructor(options){
        this.params = options;
    }
    get transactionId() {
        return this.params.transactionId;
    }
    get transition() {
        return this.params.transition;
    }
    get identity() {
        return this.params.identity;
    }
    get previousRev() {
        return this.params.previousRev;
    }
    get resultRev() {
        return this.params.resultRev;
    }
    get mutations() {
        return this.params.mutations;
    }
    get timestamp() {
        if (typeof this.params.timestamp == "string") return new Date(this.params.timestamp);
    }
    get effects() {
        return this.params.effects;
    }
    assignRandomTransactionId() {
        this.params.transactionId = luid(), this.params.resultRev = this.params.transactionId;
    }
    appliesToMissingDocument() {
        if (typeof this._appliesToMissingDocument < "u") return this._appliesToMissingDocument;
        const firstMut = this.mutations[0];
        return firstMut ? this._appliesToMissingDocument = !!(firstMut.create || firstMut.createIfNotExists || firstMut.createOrReplace) : this._appliesToMissingDocument = !0, this._appliesToMissingDocument;
    }
    // Compiles all mutations into a handy function
    compile() {
        const operations = [], getGuaranteedCreatedAt = (doc)=>doc?._createdAt || this.params.timestamp || /* @__PURE__ */ new Date().toISOString();
        this.mutations.forEach((mutation)=>{
            if (mutation.create) {
                const create = mutation.create || {};
                operations.push((doc)=>doc || Object.assign(create, {
                        _createdAt: getGuaranteedCreatedAt(create)
                    }));
                return;
            }
            if (mutation.createIfNotExists) {
                const createIfNotExists = mutation.createIfNotExists || {};
                operations.push((doc)=>doc === null ? Object.assign(createIfNotExists, {
                        _createdAt: getGuaranteedCreatedAt(createIfNotExists)
                    }) : doc);
                return;
            }
            if (mutation.createOrReplace) {
                const createOrReplace = mutation.createOrReplace || {};
                operations.push(()=>Object.assign(createOrReplace, {
                        _createdAt: getGuaranteedCreatedAt(createOrReplace)
                    }));
                return;
            }
            if (mutation.delete) {
                operations.push(()=>null);
                return;
            }
            if (mutation.patch) {
                if ("query" in mutation.patch) return;
                const patch = new Patcher(mutation.patch);
                operations.push((doc)=>patch.apply(doc));
                return;
            }
            throw new Error(`Unsupported mutation ${JSON.stringify(mutation, null, 2)}`);
        }), typeof this.params.timestamp == "string" && operations.push((doc)=>doc ? Object.assign(doc, {
                _updatedAt: this.params.timestamp
            }) : null);
        const prevRev = this.previousRev, rev = this.resultRev || this.transactionId;
        this.compiled = (doc)=>{
            if (prevRev && doc && prevRev !== doc._rev) throw new Error(`Previous revision for this mutation was ${prevRev}, but the document revision is ${doc._rev}`);
            let result = doc;
            for (const operation of operations)result = operation(result);
            return result && rev && (result === doc && (result = Object.assign({}, doc)), result._rev = rev), result;
        };
    }
    apply(document) {
        debug("Applying mutation %O to document %O", this.mutations, document), this.compiled || this.compile();
        const result = this.compiled(document);
        return debug("  => %O", result), result;
    }
    static applyAll(document, mutations) {
        return mutations.reduce((doc, mutation)=>mutation.apply(doc), document);
    }
    // Given a number of yet-to-be-committed mutation objects, collects them into one big mutation
    // any metadata like transactionId is ignored and must be submitted by the client. It is assumed
    // that all mutations are on the same document.
    // TOOO: Optimize mutations, eliminating mutations that overwrite themselves!
    static squash(document, mutations) {
        const squashed = mutations.reduce((result, mutation)=>result.concat(...mutation.mutations), []);
        return new Mutation({
            mutations: squashed
        });
    }
}
class Document {
    /**
   * Incoming patches from the server waiting to be applied to HEAD
   */ incoming = [];
    /**
   * Patches we know has been subitted to the server, but has not been seen yet in the return channel
   * so we can't be sure about the ordering yet (someone else might have slipped something between them)
   */ submitted = [];
    /**
   * Pending mutations
   */ pending = [];
    /**
   * Our model of the document according to the incoming patches from the server
   */ HEAD;
    /**
   * Our optimistic model of what the document will probably look like as soon as all our patches
   * have been processed. Updated every time we stage a new mutation, but also might revert back
   * to previous states if our mutations fail, or could change if unexpected mutations arrive
   * between our own. The `onRebase` callback will be called when EDGE changes in this manner.
   */ EDGE;
    /**
   * Called with the EDGE document when that document changes for a reason other than us staging
   * a new patch or receiving a mutation from the server while our EDGE is in sync with HEAD:
   * I.e. when EDGE changes because the order of mutations has changed in relation to our
   * optimistic predictions.
   */ onRebase;
    /**
   * Called when we receive a patch in the normal order of things, but the mutation is not ours
   */ onMutation;
    /**
   * Called when consistency state changes with the boolean value of the current consistency state
   */ onConsistencyChanged;
    /**
   * Called whenever a new incoming mutation comes in. These are always ordered correctly.
   */ onRemoteMutation;
    /**
   * We are consistent when there are no unresolved mutations of our own, and no un-applicable
   * incoming mutations. When this has been going on for too long, and there has been a while
   * since we staged a new mutation, it is time to reset your state.
   */ inconsistentAt = null;
    /**
   * The last time we staged a patch of our own. If we have been inconsistent for a while, but it
   * hasn't been long since we staged a new mutation, the reason is probably just because the user
   * is typing or something.
   *
   * Should be used as a guard against resetting state for inconsistency reasons.
   */ lastStagedAt = null;
    constructor(doc){
        this.reset(doc), this.HEAD = doc, this.EDGE = doc;
    }
    // Reset the state of the Document, used to recover from unsavory states by reloading the document
    reset(doc) {
        this.incoming = [], this.submitted = [], this.pending = [], this.inconsistentAt = null, this.HEAD = doc, this.EDGE = doc, this.considerIncoming(), this.updateConsistencyFlag();
    }
    // Call when a mutation arrives from Sanity
    arrive(mutation) {
        this.incoming.push(mutation), this.considerIncoming(), this.updateConsistencyFlag();
    }
    // Call to signal that we are submitting a mutation. Returns a callback object with a
    // success and failure handler that must be called according to the outcome of our
    // submission.
    stage(mutation, silent) {
        if (!mutation.transactionId) throw new Error("Mutations _must_ have transactionId when submitted");
        this.lastStagedAt = /* @__PURE__ */ new Date(), debug("Staging mutation %s (pushed to pending)", mutation.transactionId), this.pending.push(mutation), this.EDGE = mutation.apply(this.EDGE), this.onMutation && !silent && this.onMutation({
            mutation,
            document: this.EDGE,
            remote: !1
        });
        const txnId = mutation.transactionId;
        return this.updateConsistencyFlag(), {
            success: ()=>{
                this.pendingSuccessfullySubmitted(txnId), this.updateConsistencyFlag();
            },
            failure: ()=>{
                this.pendingFailed(txnId), this.updateConsistencyFlag();
            }
        };
    }
    // Call to check if everything is nice and quiet and there are no unresolved mutations.
    // Means this model thinks both HEAD and EDGE is up to date with what the server sees.
    isConsistent() {
        return !this.inconsistentAt;
    }
    // Private
    // Attempts to apply any resolvable incoming patches to HEAD. Will keep patching as long as there
    // are applicable patches to be applied
    considerIncoming() {
        let mustRebase = !1, nextMut;
        const rebaseMutations = [];
        if (this.HEAD && this.HEAD._updatedAt) {
            const updatedAt = new Date(this.HEAD._updatedAt);
            this.incoming.find((mut)=>mut.timestamp && mut.timestamp < updatedAt) && (this.incoming = this.incoming.filter((mut)=>mut.timestamp && mut.timestamp < updatedAt));
        }
        let protect = 0;
        do {
            if (this.HEAD) {
                const HEAD = this.HEAD;
                nextMut = HEAD._rev ? this.incoming.find((mut)=>mut.previousRev === HEAD._rev) : void 0;
            } else nextMut = this.incoming.find((mut)=>mut.appliesToMissingDocument());
            if (nextMut) {
                const applied = this.applyIncoming(nextMut);
                if (mustRebase = mustRebase || applied, mustRebase && rebaseMutations.push(nextMut), protect++ > 10) throw new Error(`Mutator stuck flushing incoming mutations. Probably stuck here: ${JSON.stringify(nextMut)}`);
            }
        }while (nextMut)
        this.incoming.length > 0 && debug.enabled && debug("Unable to apply mutations %s", this.incoming.map((mut)=>mut.transactionId).join(", ")), mustRebase && this.rebase(rebaseMutations);
    }
    // check current consistency state, update flag and invoke callback if needed
    updateConsistencyFlag() {
        const wasConsistent = this.isConsistent(), isConsistent = this.pending.length === 0 && this.submitted.length === 0 && this.incoming.length === 0;
        isConsistent ? this.inconsistentAt = null : this.inconsistentAt || (this.inconsistentAt = /* @__PURE__ */ new Date()), wasConsistent != isConsistent && this.onConsistencyChanged && (debug(isConsistent ? "Buffered document is inconsistent" : "Buffered document is consistent"), this.onConsistencyChanged(isConsistent));
    }
    // apply an incoming patch that has been prequalified as the next in line for this document
    applyIncoming(mut) {
        if (!mut) return !1;
        if (!mut.transactionId) throw new Error("Received incoming mutation without a transaction ID");
        if (debug("Applying mutation %s -> %s to rev %s", mut.previousRev, mut.resultRev, this.HEAD && this.HEAD._rev), this.HEAD = mut.apply(this.HEAD), this.onRemoteMutation && this.onRemoteMutation(mut), this.incoming = this.incoming.filter((m)=>m.transactionId !== mut.transactionId), this.hasUnresolvedMutations()) {
            const needRebase = this.consumeUnresolved(mut.transactionId);
            return debug.enabled && (debug(`Incoming mutation ${mut.transactionId} appeared while there were pending or submitted local mutations`), debug(`Submitted txnIds: ${this.submitted.map((m)=>m.transactionId).join(", ")}`), debug(`Pending txnIds: ${this.pending.map((m)=>m.transactionId).join(", ")}`), debug("needRebase === %s", needRebase)), needRebase;
        }
        return debug("Remote mutation %s arrived w/o any pending or submitted local mutations", mut.transactionId), this.EDGE = this.HEAD, this.onMutation && this.onMutation({
            mutation: mut,
            document: this.EDGE,
            remote: !0
        }), !1;
    }
    /**
   * Returns true if there are unresolved mutations between HEAD and EDGE, meaning we have
   * mutations that are still waiting to be either submitted, or to be confirmed by the server.
   *
   * @returns true if there are unresolved mutations between HEAD and EDGE, false otherwise
   */ hasUnresolvedMutations() {
        return this.submitted.length > 0 || this.pending.length > 0;
    }
    /**
   * When an incoming mutation is applied to HEAD, this is called to remove the mutation from
   * the unresolved state. If the newly applied patch is the next upcoming unresolved mutation,
   * no rebase is needed, but we might have the wrong idea about the ordering of mutations, so in
   * that case we are given the flag `needRebase` to tell us that this mutation arrived out of
   * order in terms of our optimistic version, so a rebase is needed.
   *
   * @param txnId - Transaction ID of the remote mutation
   * @returns true if rebase is needed, false otherwise
   */ consumeUnresolved(txnId) {
        if (this.submitted.length === 0 && this.pending.length === 0) return !1;
        if (this.submitted.length !== 0) {
            if (this.submitted[0].transactionId === txnId) return debug("Remote mutation %s matches upcoming submitted mutation, consumed from 'submitted' buffer", txnId), this.submitted.shift(), !1;
        } else if (this.pending.length > 0 && this.pending[0].transactionId === txnId) return debug("Remote mutation %s matches upcoming pending mutation, consumed from 'pending' buffer", txnId), this.pending.shift(), !1;
        return debug("The mutation was not the upcoming mutation, scrubbing. Pending: %d, Submitted: %d", this.pending.length, this.submitted.length), this.submitted = this.submitted.filter((mut)=>mut.transactionId !== txnId), this.pending = this.pending.filter((mut)=>mut.transactionId !== txnId), debug("After scrubbing: Pending: %d, Submitted: %d", this.pending.length, this.submitted.length), !0;
    }
    pendingSuccessfullySubmitted(pendingTxnId) {
        if (this.pending.length === 0) return;
        const first = this.pending[0];
        if (first.transactionId === pendingTxnId) {
            this.pending.shift(), this.submitted.push(first);
            return;
        }
        let justSubmitted;
        const stillPending = [];
        this.pending.forEach((mutation)=>{
            if (mutation.transactionId === pendingTxnId) {
                justSubmitted = mutation;
                return;
            }
            stillPending.push(mutation);
        }), justSubmitted && this.submitted.push(justSubmitted), this.pending = stillPending, this.rebase([]);
    }
    pendingFailed(pendingTxnId) {
        this.pending = this.pending.filter((mutation)=>mutation.transactionId !== pendingTxnId), this.rebase([]);
    }
    rebase(incomingMutations) {
        const oldEdge = this.EDGE;
        this.EDGE = Mutation.applyAll(this.HEAD, this.submitted.concat(this.pending)), oldEdge !== null && this.EDGE !== null && (oldEdge._rev = this.EDGE._rev), !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.EDGE, oldEdge) && this.onRebase && this.onRebase(this.EDGE, incomingMutations, this.pending);
    }
}
class SquashingBuffer {
    /**
   * The document forming the basis of this squash
   */ BASIS;
    /**
   * The document after the out-Mutation has been applied, but before the staged
   * operations are committed.
   */ PRESTAGE;
    /**
   * setOperations contain the latest set operation by path. If the set-operations are
   * updating strings to new strings, they are rewritten as diffMatchPatch operations,
   * any new set operations on the same paths overwrites any older set operations.
   * Only set-operations assigning plain values to plain values gets optimized like this.
   */ setOperations;
    /**
   * `documentPresent` is true whenever we know that the document must be present due
   * to preceeding mutations. `false` implies that it may or may not already exist.
   */ documentPresent;
    /**
   * The operations in the out-Mutation are not able to be optimized any further
   */ out = [];
    /**
   * Staged mutation operations
   */ staged;
    constructor(doc){
        doc ? debug("Reset mutation buffer to rev %s", doc._rev) : debug("Reset mutation buffer state to document being deleted"), this.staged = [], this.setOperations = {}, this.documentPresent = !1, this.BASIS = doc, this.PRESTAGE = doc;
    }
    add(mut) {
        mut.mutations.forEach((op)=>this.addOperation(op));
    }
    hasChanges() {
        return this.out.length > 0 || Object.keys(this.setOperations).length > 0;
    }
    /**
   * Extracts the mutations in this buffer.
   * After this is done, the buffer lifecycle is over and the client should
   * create an new one with the new, updated BASIS.
   *
   * @param txnId - Transaction ID
   * @returns A `Mutation` instance if we had outgoing mutations pending, null otherwise
   */ purge(txnId) {
        this.stashStagedOperations();
        let result = null;
        return this.out.length > 0 && (debug("Purged mutation buffer"), result = new Mutation({
            mutations: this.out,
            resultRev: txnId,
            transactionId: txnId
        })), this.out = [], this.documentPresent = !1, result;
    }
    addOperation(op) {
        if (op.patch && op.patch.set && "id" in op.patch && op.patch.id === this.PRESTAGE?._id && Object.keys(op.patch).length === 2) {
            const setPatch = op.patch.set, unoptimizable = {};
            for (const path of Object.keys(setPatch))setPatch.hasOwnProperty(path) && (this.optimiseSetOperation(path, setPatch[path]) || (unoptimizable[path] = setPatch[path]));
            Object.keys(unoptimizable).length > 0 && (debug("Unoptimizable set-operation detected, purging optimization buffer"), this.staged.push({
                patch: {
                    id: this.PRESTAGE._id,
                    set: unoptimizable
                }
            }), this.stashStagedOperations());
            return;
        }
        if (op.createIfNotExists && this.PRESTAGE && op.createIfNotExists._id === this.PRESTAGE._id) {
            this.documentPresent || (this.staged.push(op), this.documentPresent = !0, this.stashStagedOperations());
            return;
        }
        debug("Unoptimizable mutation detected, purging optimization buffer"), this.staged.push(op), this.stashStagedOperations();
    }
    /**
     * Attempt to perform one single set operation in an optimised manner, return value
     * reflects whether or not the operation could be performed.
  
     * @param path - The JSONPath to the set operation in question
     * @param nextValue - The value to be set
     * @returns True of optimized, false otherwise
     */ optimiseSetOperation(path, nextValue) {
        if (typeof nextValue == "object") return !1;
        const matches = extractWithPath(path, this.PRESTAGE);
        if (matches.length !== 1) return !1;
        const match = matches[0];
        if (typeof match.value == "object" || !this.PRESTAGE) return !1;
        let op = null;
        if (match.value === nextValue) op = null;
        else if (typeof match.value == "string" && typeof nextValue == "string") try {
            const patch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyPatches"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePatches"])(match.value, nextValue));
            op = {
                patch: {
                    id: this.PRESTAGE._id,
                    diffMatchPatch: {
                        [path]: patch
                    }
                }
            };
        } catch  {
            return !1;
        }
        else op = {
            patch: {
                id: this.PRESTAGE._id,
                set: {
                    [path]: nextValue
                }
            }
        };
        const canonicalPath = arrayToJSONMatchPath(match.path);
        return op ? this.setOperations[canonicalPath] = op : delete this.setOperations[canonicalPath], !0;
    }
    stashStagedOperations() {
        const nextOps = [];
        Object.keys(this.setOperations).forEach((key)=>{
            const op = this.setOperations[key];
            op && nextOps.push(op);
        }), nextOps.push(...this.staged), nextOps.length > 0 && (this.PRESTAGE = new Mutation({
            mutations: nextOps
        }).apply(this.PRESTAGE), this.staged = [], this.setOperations = {}), this.out.push(...nextOps);
    }
    /**
   * Rebases given the new base-document
   *
   * @param newBasis - New base document to rebase on
   * @returns New "edge" document with buffered changes integrated
   */ rebase(newBasis) {
        return this.stashStagedOperations(), newBasis === null ? (this.out = [], this.BASIS = newBasis, this.PRESTAGE = newBasis, this.documentPresent = !1) : (this.BASIS = newBasis, this.out ? this.PRESTAGE = new Mutation({
            mutations: this.out
        }).apply(this.BASIS) : this.PRESTAGE = this.BASIS), this.PRESTAGE;
    }
}
const ONE_MINUTE = 1e3 * 60;
class Commit {
    mutations;
    tries;
    resolve;
    reject;
    constructor(mutations, { resolve, reject }){
        this.mutations = mutations, this.tries = 0, this.resolve = resolve, this.reject = reject;
    }
    apply(doc) {
        return Mutation.applyAll(doc, this.mutations);
    }
    squash(doc) {
        const result = Mutation.squash(doc, this.mutations);
        return result.assignRandomTransactionId(), result;
    }
}
const mutReducerFn = (acc, mut)=>acc.concat(mut.mutations);
class BufferedDocument {
    mutations;
    /**
   * The Document we are wrapping
   */ document;
    /**
   * The Document with local changes applied
   */ LOCAL;
    /**
   * Commits that are waiting to be delivered to the server
   */ commits;
    /**
   * Local mutations that are not scheduled to be committed yet
   */ buffer;
    /**
   * Assignable event handler for when the buffered document applies a mutation
   */ onMutation;
    /**
   * Assignable event handler for when a remote mutation happened
   */ onRemoteMutation;
    /**
   * Assignable event handler for when the buffered document rebased
   */ onRebase;
    /**
   * Assignable event handler for when the document is deleted
   */ onDelete;
    /**
   * Assignable event handler for when the state of consistency changed
   */ onConsistencyChanged;
    /**
   * Assignable event handler for when the buffered document should commit changes
   */ commitHandler;
    /**
   * Whether or not we are currently commiting
   */ committerRunning = !1;
    constructor(doc){
        this.buffer = new SquashingBuffer(doc), this.document = new Document(doc), this.document.onMutation = (msg)=>this.handleDocMutation(msg), this.document.onRemoteMutation = (mut)=>this.onRemoteMutation && this.onRemoteMutation(mut), this.document.onRebase = (edge, remoteMutations, localMutations)=>this.handleDocRebase(edge, remoteMutations, localMutations), this.document.onConsistencyChanged = (msg)=>this.handleDocConsistencyChanged(msg), this.LOCAL = doc, this.mutations = [], this.commits = [];
    }
    // Used to reset the state of the local document model. If the model has been inconsistent
    // for too long, it has probably missed a notification, and should reload the document from the server
    reset(doc) {
        doc ? debug("Document state reset to revision %s", doc._rev) : debug("Document state reset to being deleted"), this.document.reset(doc), this.rebase([], []), this.handleDocConsistencyChanged(this.document.isConsistent());
    }
    // Add a change to the buffer
    add(mutation) {
        this.onConsistencyChanged && this.onConsistencyChanged(!1), debug("Staged local mutation"), this.buffer.add(mutation);
        const oldLocal = this.LOCAL;
        this.LOCAL = mutation.apply(this.LOCAL), this.onMutation && oldLocal !== this.LOCAL && (debug("onMutation fired"), this.onMutation({
            mutation,
            document: this.LOCAL,
            remote: !1
        }), this.LOCAL === null && this.onDelete && this.onDelete(this.LOCAL));
    }
    // Call when a mutation arrives from Sanity
    arrive(mutation) {
        if (debug("Remote mutation arrived %s -> %s", mutation.previousRev, mutation.resultRev), mutation.previousRev === mutation.resultRev) throw new Error(`Mutation ${mutation.transactionId} has previousRev === resultRev (${mutation.previousRev})`);
        return this.document.arrive(mutation);
    }
    // Submit all mutations in the buffer to be committed
    commit() {
        return new Promise((resolve, reject)=>{
            if (!this.buffer.hasChanges()) {
                resolve();
                return;
            }
            debug("Committing local changes");
            const pendingMutations = this.buffer.purge();
            this.commits.push(new Commit(pendingMutations ? [
                pendingMutations
            ] : [], {
                resolve,
                reject
            })), this.buffer = new SquashingBuffer(this.LOCAL), this.performCommits();
        });
    }
    // Starts the committer that will try to committ all staged commits to the database
    // by calling the commitHandler. Will keep running until all commits are successfully
    // committed.
    performCommits() {
        if (!this.commitHandler) throw new Error("No commitHandler configured for this BufferedDocument");
        this.committerRunning || this._cycleCommitter();
    }
    // TODO: Error handling, right now retries after every error
    _cycleCommitter() {
        const commit = this.commits.shift();
        if (!commit) {
            this.committerRunning = !1;
            return;
        }
        this.committerRunning = !0;
        const squashed = commit.squash(this.LOCAL), docResponder = this.document.stage(squashed, !0), responder = {
            success: ()=>{
                debug("Commit succeeded"), docResponder.success(), commit.resolve(), this._cycleCommitter();
            },
            failure: ()=>{
                debug("Commit failed"), commit.tries += 1, this.LOCAL !== null && this.commits.unshift(commit), docResponder.failure(), commit.tries < 200 && setTimeout(()=>this._cycleCommitter(), Math.min(commit.tries * 1e3, ONE_MINUTE));
            },
            cancel: (error)=>{
                this.commits.forEach((comm)=>comm.reject(error)), this.commits = [], this.reset(this.document.HEAD), this.buffer = new SquashingBuffer(this.LOCAL), this.committerRunning = !1;
            }
        };
        debug("Posting commit"), this.commitHandler && this.commitHandler({
            mutation: squashed,
            success: responder.success,
            failure: responder.failure,
            cancel: responder.cancel
        });
    }
    handleDocRebase(edge, remoteMutations, localMutations) {
        this.rebase(remoteMutations, localMutations);
    }
    handleDocumentDeleted() {
        debug("Document deleted"), this.LOCAL !== null && this.onDelete && this.onDelete(this.LOCAL), this.commits = [], this.mutations = [];
    }
    handleDocMutation(msg) {
        if (this.commits.length === 0 && !this.buffer.hasChanges()) {
            debug("Document mutated from remote with no local changes"), this.LOCAL = this.document.EDGE, this.buffer = new SquashingBuffer(this.LOCAL), this.onMutation && this.onMutation(msg);
            return;
        }
        debug("Document mutated from remote with local changes"), this.document.EDGE === null && this.handleDocumentDeleted(), this.rebase([
            msg.mutation
        ], []);
    }
    rebase(remoteMutations, localMutations) {
        debug("Rebasing document"), this.document.EDGE === null && this.handleDocumentDeleted();
        const oldLocal = this.LOCAL;
        this.LOCAL = this.commits.reduce((doc, commit)=>commit.apply(doc), this.document.EDGE), this.LOCAL = this.buffer.rebase(this.LOCAL), oldLocal !== null && this.LOCAL !== null && (oldLocal._rev = this.LOCAL._rev), !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.LOCAL, oldLocal) && this.onRebase && this.onRebase(this.LOCAL, remoteMutations.reduce(mutReducerFn, []), localMutations.reduce(mutReducerFn, []));
    }
    handleDocConsistencyChanged(isConsistent) {
        if (!this.onConsistencyChanged) return;
        const hasLocalChanges = this.commits.length > 0 || this.buffer.hasChanges();
        isConsistent && !hasLocalChanges && this.onConsistencyChanged(!0), isConsistent || this.onConsistencyChanged(!1);
    }
}
;
 //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/@sanity/bifur-client/dist/esm/createClient.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createClient": (()=>createClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$distinctUntilChanged$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/filter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$finalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/finalize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mapTo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/mapTo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$share$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/share.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$switchMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/switchMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/take.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$combineLatest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$defer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/defer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/empty.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/merge.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$partition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/partition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/nanoid/index.browser.js [app-client] (ecmascript) <locals>");
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
;
;
;
// at 1000 IDs per second ~4 million years needed in order to have a 1% probability of at least one collision.
// => https://zelark.github.io/nano-id-cc/
var defaultGetNextRequestId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["customAlphabet"])('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-', 20);
var HEARTBEAT = '♥';
function formatRequest(method, params, id) {
    return JSON.stringify({
        jsonrpc: '2.0',
        method: method,
        params: addApiVersion(params, 'v1'),
        id: id
    });
}
function tryParse(input) {
    try {
        return [
            null,
            JSON.parse(input)
        ];
    } catch (error) {
        return error instanceof Error ? [
            error
        ] : [
            new Error("".concat(error))
        ];
    }
}
function addApiVersion(params, v) {
    return __assign(__assign({}, params), {
        apiVersion: v
    });
}
var createClient = function(connection$, options) {
    if (options === void 0) {
        options = {};
    }
    var token$ = options.token$, _a = options.getNextRequestId, getNextRequestId = _a === void 0 ? defaultGetNextRequestId : _a;
    var _b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$partition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["partition"])(connection$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$switchMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["switchMap"])(function(connection) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromEvent"])(connection, 'message');
    })), function(event) {
        return event.data === HEARTBEAT;
    }), heartbeats$ = _b[0], responses$ = _b[1];
    var parsedResponses$ = responses$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(function(response) {
        var _a = tryParse(response.data), err = _a[0], msg = _a[1];
        if (err) {
            console.warn('Unable to parse message: %s', err.message);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
        }
        if (!msg || !msg.jsonrpc) {
            console.warn('Received empty or non-jsonrpc message: %s', msg);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])(msg);
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$share$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["share"])());
    var authedConnection$ = token$ ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$combineLatest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combineLatest"])([
        token$,
        connection$
    ]).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$distinctUntilChanged$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distinctUntilChanged"])(function(_a, _b) {
        var oldToken = _a[0], oldSocket = _a[1];
        var newToken = _b[0], newSocket = _b[1];
        return oldToken === newToken && oldSocket === newSocket;
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$switchMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["switchMap"])(function(_a) {
        var token = _a[0], ws = _a[1];
        return token ? call(ws, 'authorization', {
            authorization: "Bearer ".concat(token)
        }).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mapTo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapTo"])(ws)) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])(ws);
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shareReplay"])({
        refCount: true,
        bufferSize: 1
    })) : connection$;
    function call(ws, method, params) {
        if (params === void 0) {
            params = {};
        }
        var requestId = getNextRequestId();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])(parsedResponses$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])(function(rpcResult) {
            return rpcResult.id === requestId;
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(function(rpcResult) {
            return rpcResult.result;
        })), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$defer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defer"])(function() {
            ws.send(formatRequest(method, params, requestId));
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
        }));
    }
    // Will call the rpc method and return an observable that emits the first reply and then ends
    function requestMethod(method, params) {
        return authedConnection$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(function(ws) {
            return call(ws, method, params).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(1));
        }));
    }
    // Will call the rpc method with the '_subscribe' suffix and return an observable of all received messages and
    // keeps the subscription open forever/until unsubscribe
    function requestSubscribe(method, params) {
        return authedConnection$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(function(ws) {
            return call(ws, "".concat(method, "_subscribe"), params).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(function(subscriptionId) {
                return parsedResponses$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])(function(message) {
                    return message.method === "".concat(method, "_subscription") && message.params.subscription === subscriptionId;
                }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(function(message) {
                    return message.params.result;
                }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$finalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finalize"])(function() {
                    if (ws.readyState !== ws.CLOSED && ws.readyState !== ws.CLOSING) {
                        ws.send(formatRequest("".concat(method, "_unsubscribe"), {
                            subscriptionId: subscriptionId
                        }, getNextRequestId()));
                    }
                }));
            }));
        }));
    }
    return {
        // heartbeat$ is a stream of date objects representing when the "last message was received"
        // it will keep the connection open until it is unsubscribed and can therefore be used to keep connection alive
        // between requests
        heartbeats: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])(authedConnection$, heartbeats$, responses$).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(function() {
            return new Date();
        })),
        listen: function(method, params) {
            return requestSubscribe(method, params);
        },
        request: function(method, params) {
            return requestMethod(method, params);
        }
    };
};
}}),
"[project]/node_modules/@sanity/bifur-client/dist/esm/createConnect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "WebSocketError": (()=>WebSocketError),
    "createConnect": (()=>createConnect)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/Observable.js [app-client] (ecmascript)");
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
;
var WebSocketError = function(_super) {
    __extends(WebSocketError, _super);
    function WebSocketError(message, type, code, reason) {
        var _this = _super.call(this, message) || this;
        _this.type = type;
        _this.code = code;
        _this.reason = reason;
        return _this;
    }
    return WebSocketError;
}(Error);
;
function createConnect(getWebsocketInstance) {
    return function(url) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"](function(subscriber) {
            var ws = getWebsocketInstance(url);
            var didUnsubscribe = false;
            var onOpen = function() {
                subscriber.next(ws);
            };
            var onError = function() {
                subscriber.error(new WebSocketError('WebSocket connection error', 'CONNECTION_ERROR'));
            };
            var onClose = function(ev) {
                if (!didUnsubscribe) {
                    subscriber.error(new WebSocketError('WebSocket connection error', 'CONNECTION_CLOSED', ev.code, ev.reason));
                } else {
                    subscriber.complete();
                }
            };
            ws.onopen = onOpen;
            ws.onclose = onClose;
            ws.onerror = onError;
            return function() {
                didUnsubscribe = true;
                ws.close(1000, 'WebSockets connection closed by client');
            };
        });
    };
}
}}),
"[project]/node_modules/@sanity/bifur-client/dist/esm/operators.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "timeoutFirstWith": (()=>timeoutFirstWith)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$timer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/timer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$race$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/race.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js [app-client] (ecmascript)");
;
;
var timeoutFirstWith = function(due, withObservable) {
    return function(input$) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$race$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["race"])(input$, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$timer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timer"])(due).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(function() {
            return withObservable;
        })));
    };
};
}}),
"[project]/node_modules/@sanity/bifur-client/dist/esm/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "fromSanityClient": (()=>fromSanityClient),
    "fromUrl": (()=>fromUrl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$createClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/bifur-client/dist/esm/createClient.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$createConnect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/bifur-client/dist/esm/createConnect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$operators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/bifur-client/dist/esm/operators.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$takeUntil$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$throwError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/throwError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/of.js [app-client] (ecmascript)");
;
;
;
;
;
var id = function(arg) {
    return arg;
};
;
;
function fromUrl(url, options) {
    if (options === void 0) {
        options = {};
    }
    var timeout = options.timeout, token$ = options.token$;
    var connect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$createConnect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createConnect"])(function(url, protocols) {
        return new window.WebSocket(url, protocols);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$createClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createClient"])(connect(url).pipe(timeout ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$operators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeoutFirstWith"])(timeout, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$throwError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwError"])(function() {
        return new Error("Timeout after ".concat(timeout, " while establishing WebSockets connection"));
    })) : id, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shareReplay"])({
        refCount: true
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$takeUntil$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["takeUntil"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromEvent"])(window, 'beforeunload'))), {
        token$: token$
    });
}
function fromSanityClient(client) {
    var _a = client.config(), dataset = _a.dataset, token = _a.token;
    return fromUrl(client.getUrl("/socket/".concat(dataset)).replace(/^http/, 'ws'), token ? {
        token$: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])(token)
    } : {});
}
}}),
"[project]/node_modules/@sanity/logos/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GroqLogo": (()=>GroqLogo),
    "GroqMonogram": (()=>GroqMonogram),
    "SanityLogo": (()=>SanityLogo),
    "SanityMonogram": (()=>SanityMonogram)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/color/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
;
const GroqLogo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(function(props, ref) {
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        "data-sanity-icon": "groq-logo",
        height: "1em",
        viewBox: "0 0 304 64",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        ref,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M32 0L0 32H32V0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].magenta[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M32 32H0L32 64V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M64 32H32V64L64 32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].purple[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M112 0L80 32H112V0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M112 0H80V32L112 0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].purple[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M112 32H80L112 64V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].yellow[200].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M144 64L112 32V64H144Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].blue[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M80 32V64H112L80 32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].orange[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M112 0V32H144L112 0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].magenta[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M192 0L160 32H192V0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].yellow[200].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M192 32H160L192 64V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].orange[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M224 32H192V64L224 32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M192 0V32H224L192 0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].blue[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M272 0L240 32H272V0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].purple[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M304 32L272 64H304V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].magenta[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M272 32H240L272 64V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].blue[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M304 32H272V64L304 32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].yellow[200].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M272 0V32H304L272 0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[300].hex
            })
        ]
    });
});
GroqLogo.displayName = "ForwardRef(GroqLogo)";
const GroqMonogram = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(function(props, ref) {
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        "data-sanity-icon": "groq-monogram",
        width: "1em",
        height: "1em",
        viewBox: "0 0 128 128",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        ref,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                width: "128",
                height: "128",
                rx: "8",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[950].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                y: "32",
                width: "64",
                height: "64",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[800].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M64 32L32 64H64V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].magenta[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M64 64H32L64 96V64Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M96 64H64V96L96 64Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].purple[300].hex
            })
        ]
    });
});
GroqMonogram.displayName = "ForwardRef(GroqMonogram)";
const schemes = {
    light: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].red[200].hex,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].red[300].hex,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].red[500].hex
    ],
    dark: [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].gray[500].hex,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].gray[300].hex,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["white"].hex
    ]
}, SanityLogo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(function(props, ref) {
    const { dark, ...svgProps } = props, scheme = schemes[dark ? "dark" : "light"];
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        "data-sanity-icon": "sanity-logo",
        height: "1em",
        viewBox: "0 0 352 100",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...svgProps,
        ref,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M311.14 57.234V80.0016H298.499V57.234",
                fill: scheme[1]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M298.499 57.2341L319.889 20.0017H333.316L311.14 57.2341H298.499Z",
                fill: scheme[2]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M298.499 57.2341L276.515 20.0017H290.345L305.239 45.5161L298.499 57.2341Z",
                fill: scheme[1]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M253.839 40.9625V80.0017H241.007V47.6275L253.839 40.9625Z",
                fill: scheme[1]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M241.007 47.5944L273.538 30.9469L268.042 21.6519L241.007 34.8633V47.5944Z",
                fill: scheme[0]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M241.007 30.9469H221.404V20.0017H267.064L273.538 30.9469H253.839H241.007Z",
                fill: scheme[2]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M214.047 20.0017H201.311V80.0121H214.047V20.0017Z",
                fill: scheme[2]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M149.39 37.8712V80.0017H137.153V20.0017L149.39 37.8712Z",
                fill: scheme[1]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M151.282 20.0017L178.231 60.9939V80.0017L137.153 20.0017H151.282Z",
                fill: scheme[2]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M178.231 57.9129V20.0017H190.467V80.0017H178.231V57.9129Z",
                fill: scheme[1]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M82.1168 80.9834L112.102 65.3053L108.405 55.7303L88.6644 64.9362L82.1168 80.9834Z",
                fill: scheme[0]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M100.657 35.5422L82.1167 80.9834L72.5807 72.7745L94.6719 20.0017L100.657 35.5422Z",
                fill: scheme[1]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M94.672 20.0017H107.312L130.69 80.0017H117.752L94.672 20.0017Z",
                fill: scheme[2]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M25.1347 26.926C25.1347 35.2811 30.3864 40.2524 40.9004 42.8738L52.0417 45.4117C61.9923 47.6571 68.0519 53.2341 68.0519 62.3203C68.1293 66.2787 66.8194 70.1429 64.3417 73.2654C64.3417 64.2002 59.5684 59.302 48.0551 56.3568L37.1158 53.913C28.3559 51.9495 21.5946 47.3647 21.5946 37.4952C21.5485 33.6839 22.7939 29.9658 25.1347 26.926",
                fill: scheme[2]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M57.4954 60.0957C62.2475 63.0827 64.3311 67.2602 64.3311 73.255C60.3977 78.2054 53.4875 80.9834 45.3655 80.9834C31.6941 80.9834 22.1262 74.3725 20 62.8842H33.1292C34.8196 68.1584 39.2952 70.6022 45.2698 70.6022C52.5626 70.6022 57.4104 66.7798 57.506 60.0748",
                fill: scheme[1]
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M31.9598 39.3124C29.7898 38.0455 28.0095 36.225 26.8079 34.0442C25.6062 31.8634 25.028 29.4036 25.1347 26.926C28.93 22.0174 35.5318 19.02 43.5794 19.02C57.506 19.02 65.5643 26.2472 67.5523 36.4195H54.9227C53.53 32.409 50.0431 29.2863 43.6858 29.2863C36.8926 29.2863 32.2575 33.1715 31.9917 39.3124",
                fill: scheme[1]
            })
        ]
    });
});
SanityLogo.displayName = "ForwardRef(SanityLogo)";
const SANITY_MONOGRAM_COLOR = {
    bg1: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].red[500].hex,
    bg2: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].red[200].hex,
    fg: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["white"].hex
}, SanityMonogram = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(function(props, ref) {
    const { color = SANITY_MONOGRAM_COLOR, ...restProps } = props;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        "data-sanity-icon": "sanity-monogram",
        width: "1em",
        height: "1em",
        viewBox: "0 0 128 128",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...restProps,
        ref,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                width: "128",
                height: "128",
                rx: "8",
                fill: color.bg1
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M39.423 33.163C39.423 44.1615 46.3363 50.7056 60.1768 54.1564L74.843 57.4972C87.9418 60.453 95.9186 67.7945 95.9186 79.7554C96.0205 84.9662 94.2961 90.0531 91.0345 94.1635C91.0345 82.2301 84.751 75.7822 69.595 71.9052L55.1948 68.6882C43.6633 66.1035 34.7629 60.0681 34.7629 47.0761C34.7022 42.0589 36.3416 37.1644 39.423 33.163",
                fill: color.fg
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M82.0221 76.827C88.2776 80.759 91.0206 86.2582 91.0206 94.1497C85.8426 100.666 76.7462 104.323 66.0545 104.323C48.0576 104.323 35.4626 95.6207 32.6637 80.4977H49.9468C52.172 87.4406 58.0636 90.6576 65.9285 90.6576C75.5287 90.6576 81.9102 85.6258 82.0361 76.7995",
                fill: color.bg2
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M48.4075 49.4682C45.551 47.8004 43.2074 45.404 41.6256 42.5332C40.0437 39.6624 39.2826 36.4244 39.4231 33.1629C44.4191 26.7013 53.1096 22.7556 63.7034 22.7556C82.0362 22.7556 92.6439 32.2693 95.2609 45.66H78.6355C76.8022 40.3807 72.2121 36.27 63.8434 36.27C54.9009 36.27 48.7993 41.3843 48.4495 49.4682",
                fill: color.bg2
            })
        ]
    });
});
SanityMonogram.displayName = "ForwardRef(SanityMonogram)";
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/insert-menu/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InsertMenu": (()=>InsertMenu)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/icons/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/ui/dist/_chunks-es/_visual-editing.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/startCase.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$is$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-is/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
function getSchemaTypeIcon(schemaType) {
    const referenceIcon = isReferenceSchemaType(schemaType) && (schemaType.to ?? []).length === 1 ? schemaType.to[0].icon : void 0;
    return schemaType.icon ?? schemaType.type?.icon ?? referenceIcon;
}
function isReferenceSchemaType(type) {
    return isRecord(type) && (type.name === "reference" || isReferenceSchemaType(type.type));
}
function isRecord(value) {
    return !!value && (typeof value == "object" || typeof value == "function");
}
function fullInsertMenuReducer(state, event) {
    return {
        query: event.type === "change query" ? event.query : state.query,
        groups: event.type === "select group" ? state.groups.map((group)=>({
                ...group,
                selected: event.name === group.name
            })) : state.groups,
        views: event.type === "toggle view" ? state.views.map((view)=>({
                ...view,
                selected: event.name === view.name
            })) : state.views
    };
}
const ALL_ITEMS_GROUP_NAME = "all-items", gridStyle = {
    gridTemplateColumns: "repeat(auto-fill, minmax(118px, 1fr))"
};
function InsertMenu(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(54), showIcons = props.showIcons === void 0 ? !0 : props.showIcons, showFilter = props.filter === void 0 || props.filter === "auto" ? props.schemaTypes.length > 5 : props.filter;
    let t0;
    $[0] !== props.groups || $[1] !== props.labels ? (t0 = props.groups ? [
        {
            name: ALL_ITEMS_GROUP_NAME,
            title: props.labels["insert-menu.filter.all-items"],
            selected: !0
        },
        ...props.groups.map(_temp)
    ] : [], $[0] = props.groups, $[1] = props.labels, $[2] = t0) : t0 = $[2];
    let t1;
    $[3] !== props.views ? (t1 = props.views ?? [
        {
            name: "list"
        }
    ], $[3] = props.views, $[4] = t1) : t1 = $[4];
    let t2;
    $[5] !== t1 ? (t2 = t1.map(_temp2), $[5] = t1, $[6] = t2) : t2 = $[6];
    let t3;
    $[7] !== t0 || $[8] !== t2 ? (t3 = {
        query: "",
        groups: t0,
        views: t2
    }, $[7] = t0, $[8] = t2, $[9] = t3) : t3 = $[9];
    const [state, send] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useReducer"])(fullInsertMenuReducer, t3);
    let T0, T1, T2, t4, t5, t6, t7, t8, t9;
    if ($[10] !== props || $[11] !== showFilter || $[12] !== showIcons || $[13] !== state.groups || $[14] !== state.query || $[15] !== state.views) {
        const filteredSchemaTypes = filterSchemaTypes(props.schemaTypes, state.query, state.groups), selectedView = state.views.find(_temp3), showingFilterOrViews = showFilter || state.views.length > 1, showingTabs = state.groups && state.groups.length > 0, showingAnyOptions = showingFilterOrViews || showingTabs;
        T2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Menu"], t9 = 0, T1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Flex"], t6 = "column", t7 = "fill";
        let t102;
        $[25] !== showingAnyOptions ? (t102 = showingAnyOptions ? {
            style: {
                borderBottom: "1px solid var(--card-border-color)"
            },
            paddingBottom: 1
        } : {}, $[25] = showingAnyOptions, $[26] = t102) : t102 = $[26];
        let t112;
        $[27] !== props.labels || $[28] !== showFilter || $[29] !== showingFilterOrViews || $[30] !== state.query || $[31] !== state.views ? (t112 = showingFilterOrViews ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Flex"], {
            flex: "none",
            align: "center",
            paddingTop: 1,
            paddingX: 1,
            gap: 1,
            children: [
                showFilter ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
                    flex: 1,
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextInput"], {
                        autoFocus: !0,
                        border: !1,
                        fontSize: 1,
                        icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SearchIcon"],
                        onChange: (event)=>{
                            send({
                                type: "change query",
                                query: event.target.value
                            });
                        },
                        placeholder: props.labels["insert-menu.search.placeholder"],
                        value: state.query
                    })
                }) : null,
                state.views.length > 1 ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
                    flex: "none",
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(ViewToggle, {
                        views: state.views,
                        onToggle: (name)=>{
                            send({
                                type: "toggle view",
                                name
                            });
                        },
                        labels: props.labels
                    })
                }) : null
            ]
        }) : null, $[27] = props.labels, $[28] = showFilter, $[29] = showingFilterOrViews, $[30] = state.query, $[31] = state.views, $[32] = t112) : t112 = $[32];
        let t122;
        $[33] !== showingTabs || $[34] !== state.groups ? (t122 = showingTabs ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
            paddingTop: 1,
            paddingX: 1,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TabList"], {
                space: 1,
                children: state.groups.map((group_0)=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tab"], {
                        id: `${group_0.name}-tab`,
                        "aria-controls": `${group_0.name}-panel`,
                        label: group_0.title ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(group_0.name),
                        selected: group_0.selected,
                        onClick: ()=>{
                            send({
                                type: "select group",
                                name: group_0.name
                            });
                        }
                    }, group_0.name))
            })
        }) : null, $[33] = showingTabs, $[34] = state.groups, $[35] = t122) : t122 = $[35], $[36] !== t102 || $[37] !== t112 || $[38] !== t122 ? (t8 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
            ...t102,
            children: [
                t112,
                t122
            ]
        }), $[36] = t102, $[37] = t112, $[38] = t122, $[39] = t8) : t8 = $[39], T0 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], t4 = 1, t5 = filteredSchemaTypes.length === 0 ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
            padding: 2,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"], {
                muted: !0,
                size: 1,
                children: props.labels["insert-menu.search.no-results"]
            })
        }) : selectedView ? selectedView.name === "grid" ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Grid"], {
            autoRows: "auto",
            flex: 1,
            gap: 1,
            style: gridStyle,
            children: filteredSchemaTypes.map((schemaType)=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(GridMenuItem, {
                    icon: showIcons ? getSchemaTypeIcon(schemaType) : void 0,
                    onClick: ()=>{
                        props.onSelect(schemaType);
                    },
                    previewImageUrl: selectedView.previewImageUrl?.(schemaType.name),
                    schemaType
                }, schemaType.name))
        }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Stack"], {
            flex: 1,
            space: 1,
            children: filteredSchemaTypes.map((schemaType_0)=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuItem"], {
                    icon: showIcons ? getSchemaTypeIcon(schemaType_0) : void 0,
                    onClick: ()=>{
                        props.onSelect(schemaType_0);
                    },
                    text: schemaType_0.title ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(schemaType_0.name)
                }, schemaType_0.name))
        }) : null, $[10] = props, $[11] = showFilter, $[12] = showIcons, $[13] = state.groups, $[14] = state.query, $[15] = state.views, $[16] = T0, $[17] = T1, $[18] = T2, $[19] = t4, $[20] = t5, $[21] = t6, $[22] = t7, $[23] = t8, $[24] = t9;
    } else T0 = $[16], T1 = $[17], T2 = $[18], t4 = $[19], t5 = $[20], t6 = $[21], t7 = $[22], t8 = $[23], t9 = $[24];
    let t10;
    $[40] !== T0 || $[41] !== t4 || $[42] !== t5 ? (t10 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(T0, {
        padding: t4,
        children: t5
    }), $[40] = T0, $[41] = t4, $[42] = t5, $[43] = t10) : t10 = $[43];
    let t11;
    $[44] !== T1 || $[45] !== t10 || $[46] !== t6 || $[47] !== t7 || $[48] !== t8 ? (t11 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(T1, {
        direction: t6,
        height: t7,
        children: [
            t8,
            t10
        ]
    }), $[44] = T1, $[45] = t10, $[46] = t6, $[47] = t7, $[48] = t8, $[49] = t11) : t11 = $[49];
    let t12;
    return $[50] !== T2 || $[51] !== t11 || $[52] !== t9 ? (t12 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(T2, {
        padding: t9,
        children: t11
    }), $[50] = T2, $[51] = t11, $[52] = t9, $[53] = t12) : t12 = $[53], t12;
}
function _temp3(view_0) {
    return view_0.selected;
}
function _temp2(view, index) {
    return {
        ...view,
        selected: index === 0
    };
}
function _temp(group) {
    return {
        ...group,
        selected: !1
    };
}
const viewToggleIcon = {
    grid: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ThLargeIcon"],
    list: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UlistIcon"]
}, viewToggleTooltip = {
    grid: "insert-menu.toggle-grid-view.tooltip",
    list: "insert-menu.toggle-list-view.tooltip"
};
function ViewToggle(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(11), viewIndex = props.views.findIndex(_temp4), nextView = props.views[viewIndex + 1] ?? props.views[0], t0 = props.labels[viewToggleTooltip[nextView.name]];
    let t1;
    $[0] !== t0 ? (t1 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"], {
        size: 1,
        children: t0
    }), $[0] = t0, $[1] = t1) : t1 = $[1];
    const t2 = viewToggleIcon[nextView.name];
    let t3;
    $[2] !== nextView.name || $[3] !== props ? (t3 = ()=>{
        props.onToggle(nextView.name);
    }, $[2] = nextView.name, $[3] = props, $[4] = t3) : t3 = $[4];
    let t4;
    $[5] !== t2 || $[6] !== t3 ? (t4 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Button"], {
        mode: "bleed",
        icon: t2,
        onClick: t3
    }), $[5] = t2, $[6] = t3, $[7] = t4) : t4 = $[7];
    let t5;
    return $[8] !== t1 || $[9] !== t4 ? (t5 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tooltip"], {
        content: t1,
        placement: "top",
        portal: !0,
        children: t4
    }), $[8] = t1, $[9] = t4, $[10] = t5) : t5 = $[10], t5;
}
function _temp4(view) {
    return view.selected;
}
function GridMenuItem(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(19), [failedToLoad, setFailedToLoad] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(!1), Icon = props.icon;
    let t0;
    $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
        overflow: "hidden"
    }, $[0] = t0) : t0 = $[0];
    let t1;
    $[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = {
        backgroundColor: "var(--card-muted-bg-color)",
        paddingBottom: "66.6%",
        position: "relative"
    }, $[1] = t1) : t1 = $[1];
    let t2;
    $[2] !== Icon ? (t2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$is$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidElementType"])(Icon) ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Flex"], {
        align: "center",
        justify: "center",
        style: {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%"
        },
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"], {
            size: 1,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Icon, {})
        })
    }) : null, $[2] = Icon, $[3] = t2) : t2 = $[3];
    let t3;
    $[4] !== failedToLoad || $[5] !== props.previewImageUrl ? (t3 = !props.previewImageUrl || failedToLoad ? null : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("img", {
        src: props.previewImageUrl,
        style: {
            objectFit: "contain",
            width: "100%",
            height: "100%",
            position: "absolute",
            inset: 0
        },
        onError: ()=>{
            setFailedToLoad(!0);
        }
    }), $[4] = failedToLoad, $[5] = props.previewImageUrl, $[6] = t3) : t3 = $[6];
    let t4;
    $[7] === Symbol.for("react.memo_cache_sentinel") ? (t4 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
        style: {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            boxShadow: "inset 0 0 0 0.5px var(--card-fg-color)",
            opacity: 0.1
        }
    }), $[7] = t4) : t4 = $[7];
    let t5;
    $[8] !== t2 || $[9] !== t3 ? (t5 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
        flex: "none",
        style: t1,
        children: [
            t2,
            t3,
            t4
        ]
    }), $[8] = t2, $[9] = t3, $[10] = t5) : t5 = $[10];
    const t6 = props.schemaType.title ?? props.schemaType.name;
    let t7;
    $[11] !== t6 ? (t7 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
        flex: 1,
        padding: 2,
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"], {
            size: 1,
            weight: "medium",
            children: t6
        })
    }), $[11] = t6, $[12] = t7) : t7 = $[12];
    let t8;
    $[13] !== t5 || $[14] !== t7 ? (t8 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Flex"], {
        direction: "column",
        gap: 1,
        padding: 1,
        children: [
            t5,
            t7
        ]
    }), $[13] = t5, $[14] = t7, $[15] = t8) : t8 = $[15];
    let t9;
    return $[16] !== props.onClick || $[17] !== t8 ? (t9 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuItem"], {
        padding: 0,
        radius: 2,
        onClick: props.onClick,
        style: t0,
        children: t8
    }), $[16] = props.onClick, $[17] = t8, $[18] = t9) : t9 = $[18], t9;
}
function filterSchemaTypes(schemaTypes, query, groups) {
    return schemaTypes.filter((schemaType)=>passesGroupFilter(schemaType, groups) && passesQueryFilter(schemaType, query));
}
function passesQueryFilter(schemaType, query) {
    const sanitizedQuery = query.trim().toLowerCase();
    return schemaType.title ? schemaType.title?.toLowerCase().includes(sanitizedQuery) : schemaType.name.includes(sanitizedQuery);
}
function passesGroupFilter(schemaType, groups) {
    const selectedGroup = groups.find((group)=>group.selected);
    return selectedGroup ? selectedGroup.name === ALL_ITEMS_GROUP_NAME ? !0 : selectedGroup.of?.includes(schemaType.name) : !0;
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/diff-patch/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DiffError": (()=>DiffError),
    "diffItem": (()=>diffItem),
    "diffPatch": (()=>diffPatch)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/diff-match-patch/dist/index.js [app-client] (ecmascript)");
;
const IS_DOTTABLE_RE = /^[A-Za-z_][A-Za-z0-9_]*$/;
function pathToString(path) {
    return path.reduce((target, segment, i)=>{
        if (Array.isArray(segment)) return `${target}[${segment.join(":")}]`;
        if (isKeyedObject(segment)) return `${target}[_key=="${segment._key}"]`;
        if (typeof segment == "number") return `${target}[${segment}]`;
        if (typeof segment == "string" && !IS_DOTTABLE_RE.test(segment)) return `${target}['${segment}']`;
        if (typeof segment == "string") return `${target}${i === 0 ? "" : "."}${segment}`;
        throw new Error(`Unsupported path segment "${segment}"`);
    }, "");
}
function isKeyedObject(obj) {
    return typeof obj == "object" && typeof obj._key == "string";
}
class DiffError extends Error {
    path;
    value;
    serializedPath;
    constructor(message, path, value){
        const serializedPath = pathToString(path);
        super(`${message} (at '${serializedPath}')`), this.path = path, this.serializedPath = serializedPath, this.value = value;
    }
}
const idPattern = /^[a-z0-9][a-z0-9_.-]+$/i, propPattern = /^[a-zA-Z_][a-zA-Z0-9_-]*$/, propStartPattern = /^[a-z_]/i;
function validateProperty(property, value, path) {
    if (!propStartPattern.test(property)) throw new DiffError("Keys must start with a letter (a-z)", path.concat(property), value);
    if (!propPattern.test(property)) throw new DiffError("Keys can only contain letters, numbers and underscores", path.concat(property), value);
    if (property === "_key" || property === "_ref" || property === "_type") {
        if (typeof value != "string") throw new DiffError("Keys must be strings", path.concat(property), value);
        if (!idPattern.test(value)) throw new DiffError("Invalid key - use less exotic characters", path.concat(property), value);
    }
    return property;
}
const ignoredKeys = [
    "_id",
    "_type",
    "_createdAt",
    "_updatedAt",
    "_rev"
], defaultOptions = {
    hideWarnings: !1,
    diffMatchPatch: {
        enabled: !0,
        // Only use diff-match-patch if target string is longer than this threshold
        lengthThresholdAbsolute: 30,
        // Only use generated diff-match-patch if the patch length is less than or equal to
        // (targetString * relative). Example: A 100 character target with a relative factor
        // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,
        // it will fall back to a regular `set` patch.
        lengthThresholdRelative: 1.2
    }
};
function mergeOptions(options) {
    return {
        ...defaultOptions,
        ...options,
        diffMatchPatch: {
            ...defaultOptions.diffMatchPatch,
            ...options.diffMatchPatch || {}
        }
    };
}
function diffPatch(itemA, itemB, opts) {
    const options = mergeOptions(opts || {}), id = options.id || itemA._id === itemB._id && itemA._id, revisionLocked = options.ifRevisionID, ifRevisionID = typeof revisionLocked == "boolean" ? itemA._rev : revisionLocked, basePath = options.basePath || [];
    if (!id) throw new Error("_id on itemA and itemB not present or differs, specify document id the mutations should be applied to");
    if (revisionLocked === !0 && !ifRevisionID) throw new Error("`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.");
    if (basePath.length === 0 && itemA._type !== itemB._type) throw new Error(`_type is immutable and cannot be changed (${itemA._type} => ${itemB._type})`);
    const operations = diffItem(itemA, itemB, options, basePath, []);
    return serializePatches(operations, {
        id,
        ifRevisionID: revisionLocked ? ifRevisionID : void 0
    });
}
function diffItem(itemA, itemB, opts = defaultOptions, path = [], patches = []) {
    if (itemA === itemB) return patches;
    const aType = Array.isArray(itemA) ? "array" : typeof itemA, bType = Array.isArray(itemB) ? "array" : typeof itemB, aIsUndefined = aType === "undefined", bIsUndefined = bType === "undefined";
    if (aIsUndefined && !bIsUndefined) return patches.push({
        op: "set",
        path,
        value: itemB
    }), patches;
    if (!aIsUndefined && bIsUndefined) return patches.push({
        op: "unset",
        path
    }), patches;
    const options = mergeOptions(opts), dataType = aIsUndefined ? bType : aType;
    return dataType === "object" || dataType === "array" ? aType !== bType ? (patches.push({
        op: "set",
        path,
        value: itemB
    }), patches) : dataType === "array" ? diffArray(itemA, itemB, options, path, patches) : diffObject(itemA, itemB, options, path, patches) : diffPrimitive(itemA, itemB, options, path, patches);
}
function diffObject(itemA, itemB, options, path, patches) {
    const atRoot = path.length === 0, aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map((key)=>validateProperty(key, itemA[key], path)), aKeysLength = aKeys.length, bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map((key)=>validateProperty(key, itemB[key], path)), bKeysLength = bKeys.length;
    for(let i = 0; i < aKeysLength; i++){
        const key = aKeys[i];
        key in itemB || patches.push({
            op: "unset",
            path: path.concat(key)
        });
    }
    for(let i = 0; i < bKeysLength; i++){
        const key = bKeys[i];
        diffItem(itemA[key], itemB[key], options, path.concat([
            key
        ]), patches);
    }
    return patches;
}
function diffArray(itemA, itemB, options, path, patches) {
    if (itemB.length > itemA.length && patches.push({
        op: "insert",
        after: path.concat([
            -1
        ]),
        items: itemB.slice(itemA.length).map((item, i)=>nullifyUndefined(item, path, i, options))
    }), itemB.length < itemA.length) {
        const isSingle = itemA.length - itemB.length === 1, unsetItems = itemA.slice(itemB.length);
        isRevisionLocked(options) || !isUniquelyKeyed(unsetItems) ? patches.push({
            op: "unset",
            path: path.concat([
                isSingle ? itemB.length : [
                    itemB.length,
                    ""
                ]
            ])
        }) : patches.push(...unsetItems.map((item)=>({
                op: "unset",
                path: path.concat({
                    _key: item._key
                })
            })));
    }
    for(let i = 0; i < itemB.length; i++)if (Array.isArray(itemB[i])) throw new DiffError("Multi-dimensional arrays not supported", path.concat(i), itemB[i]);
    const overlapping = Math.min(itemA.length, itemB.length), segmentA = itemA.slice(0, overlapping), segmentB = itemB.slice(0, overlapping);
    return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path, patches) : diffArrayByIndex(segmentA, segmentB, options, path, patches);
}
function diffArrayByIndex(itemA, itemB, options, path, patches) {
    for(let i = 0; i < itemA.length; i++)diffItem(itemA[i], nullifyUndefined(itemB[i], path, i, options), options, path.concat(i), patches);
    return patches;
}
function diffArrayByKey(itemA, itemB, options, path, patches) {
    const keyedA = indexByKey(itemA), keyedB = indexByKey(itemB);
    if (!arrayIsEqual(keyedA.keys, keyedB.keys)) return diffArrayByIndex(itemA, itemB, options, path, patches);
    for(let i = 0; i < keyedB.keys.length; i++){
        const key = keyedB.keys[i], valueA = keyedA.index[key], valueB = nullifyUndefined(keyedB.index[key], path, i, options);
        diffItem(valueA, valueB, options, path.concat({
            _key: key
        }), patches);
    }
    return patches;
}
function getDiffMatchPatch(itemA, itemB, options, path) {
    const { enabled, lengthThresholdRelative, lengthThresholdAbsolute } = options.diffMatchPatch, segment = path[path.length - 1];
    if (!enabled || // Don't use for anything but strings
    typeof itemA != "string" || typeof itemB != "string" || // Don't use for `_key`, `_ref` etc
    typeof segment == "string" && segment[0] === "_" || // Don't use on short strings
    itemB.length < lengthThresholdAbsolute) return;
    let strPatch = "";
    try {
        const patch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeDiff"])(itemA, itemB), diff = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cleanupEfficiency"])(patch);
        strPatch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyPatches"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePatches"])(diff));
    } catch  {
        return;
    }
    return strPatch.length > itemB.length * lengthThresholdRelative ? void 0 : {
        op: "diffMatchPatch",
        path,
        value: strPatch
    };
}
function diffPrimitive(itemA, itemB, options, path, patches) {
    const dmp = getDiffMatchPatch(itemA, itemB, options, path);
    return patches.push(dmp || {
        op: "set",
        path,
        value: itemB
    }), patches;
}
function isNotIgnoredKey(key) {
    return ignoredKeys.indexOf(key) === -1;
}
function serializePatches(patches, options) {
    if (patches.length === 0) return [];
    const { id, ifRevisionID } = options, set = patches.filter((patch)=>patch.op === "set"), unset = patches.filter((patch)=>patch.op === "unset"), insert = patches.filter((patch)=>patch.op === "insert"), dmp = patches.filter((patch)=>patch.op === "diffMatchPatch"), withSet = set.length > 0 && set.reduce((patch, item)=>{
        const path = pathToString(item.path);
        return patch.set[path] = item.value, patch;
    }, {
        id,
        set: {}
    }), withUnset = unset.length > 0 && unset.reduce((patch, item)=>{
        const path = pathToString(item.path);
        return patch.unset.push(path), patch;
    }, {
        id,
        unset: []
    }), withInsert = insert.reduce((acc, item)=>{
        const after = pathToString(item.after);
        return acc.concat({
            id,
            insert: {
                after,
                items: item.items
            }
        });
    }, []), withDmp = dmp.length > 0 && dmp.reduce((patch, item)=>{
        const path = pathToString(item.path);
        return patch.diffMatchPatch[path] = item.value, patch;
    }, {
        id,
        diffMatchPatch: {}
    });
    return [
        withUnset,
        withSet,
        withDmp,
        ...withInsert
    ].filter((item)=>item !== !1).map((patch, i)=>({
            patch: ifRevisionID && i === 0 ? {
                ...patch,
                ifRevisionID
            } : patch
        }));
}
function isUniquelyKeyed(arr) {
    const keys = [];
    for(let i = 0; i < arr.length; i++){
        const key = getKey(arr[i]);
        if (!key || keys.indexOf(key) !== -1) return !1;
        keys.push(key);
    }
    return !0;
}
function getKey(obj) {
    return typeof obj == "object" && obj !== null && obj._key;
}
function indexByKey(arr) {
    return arr.reduce((acc, item)=>(acc.keys.push(item._key), acc.index[item._key] = item, acc), {
        keys: [],
        index: {}
    });
}
function arrayIsEqual(itemA, itemB) {
    return itemA.length === itemB.length && itemA.every((item, i)=>itemB[i] === item);
}
function nullifyUndefined(item, path, index, options) {
    if (typeof item < "u") return item;
    if (!options.hideWarnings) {
        const serializedPath = pathToString(path.concat(index));
        console.warn(`undefined value in array converted to null (at '${serializedPath}')`);
    }
    return null;
}
function isRevisionLocked(options) {
    return !!options.ifRevisionID;
}
function yes(_) {
    return !0;
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/diff/lib/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "diffInput": (()=>diffInput),
    "wrap": (()=>wrap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/diff-match-patch/dist/index.js [app-client] (ecmascript)");
;
function replaceProperty(parent, prop, value) {
    return delete parent[prop], parent[prop] = value, value;
}
function getLongestCommonSubsequence(previous, next) {
    const matrix = getLengthMatrix(previous, next);
    return backtrack(matrix, previous, next);
}
function getLengthMatrix(previous, next) {
    const len1 = previous.length, len2 = next.length;
    let x = 0, y = 0;
    const matrix = new Array(len1 + 1);
    for(x = 0; x < len1 + 1; x++)for(matrix[x] = [
        len2 + 1
    ], y = 0; y < len2 + 1; y++)matrix[x][y] = 0;
    for(x = 1; x < len1 + 1; x++)for(y = 1; y < len2 + 1; y++)previous[x - 1] === next[y - 1] ? matrix[x][y] = matrix[x - 1][y - 1] + 1 : matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
    return matrix;
}
function backtrack(matrix, previous, next) {
    let prevIndex = previous.length, nextIndex = next.length;
    const subsequence = {
        sequence: [],
        prevIndices: [],
        nextIndices: []
    };
    for(; prevIndex !== 0 && nextIndex !== 0;)if (previous[prevIndex - 1] === next[nextIndex - 1]) subsequence.sequence.unshift(previous[prevIndex - 1]), subsequence.prevIndices.unshift(prevIndex - 1), subsequence.nextIndices.unshift(nextIndex - 1), --prevIndex, --nextIndex;
    else {
        const valueAtMatrixAbove = matrix[prevIndex][nextIndex - 1], valueAtMatrixLeft = matrix[prevIndex - 1][nextIndex];
        valueAtMatrixAbove > valueAtMatrixLeft ? --nextIndex : --prevIndex;
    }
    return subsequence;
}
function diffArray(fromInput, toInput, options) {
    if (fromInput === toInput) {
        const fromValue = fromInput.value, toValue = toInput.value;
        return {
            type: "array",
            action: "unchanged",
            isChanged: !1,
            fromValue,
            toValue,
            get items () {
                const items2 = diffExactByPosition(fromInput, toInput, options);
                if (!items2) throw new Error("invariant broken: equivalent input, but diff detected");
                return replaceProperty(this, "items", items2);
            }
        };
    }
    const keyedA = indexByKey(fromInput), keyedB = indexByKey(toInput);
    if (keyedA && keyedB) return diffArrayByKey(fromInput, keyedA, toInput, keyedB);
    const items = diffExactByPosition(fromInput, toInput, options);
    return items ? buildArrayDiff(fromInput, toInput, items, !1) : diffArrayByReinsert(fromInput, toInput);
}
function buildArrayDiff(fromInput, toInput, items, isChanged) {
    const fromValue = fromInput.value, toValue = toInput.value;
    return isChanged ? {
        type: "array",
        action: "changed",
        isChanged: !0,
        fromValue,
        toValue,
        items,
        annotation: toInput.annotation
    } : {
        type: "array",
        action: "unchanged",
        isChanged: !1,
        fromValue,
        toValue,
        items
    };
}
function diffExactByPosition(fromInput, toInput, options) {
    if (fromInput.length !== toInput.length) return;
    const items = [];
    for(let idx = 0; idx < fromInput.length; idx++){
        const diff = diffInput(fromInput.at(idx), toInput.at(idx), options);
        if (diff.isChanged) return;
        items.push({
            fromIndex: idx,
            toIndex: idx,
            hasMoved: !1,
            diff,
            annotation: toInput.annotationAt(idx)
        });
    }
    return items;
}
function diffArrayByReinsert(fromInput, toInput, options) {
    const items = [];
    for(let idx = 0; idx < toInput.length; idx++){
        const input = toInput.at(idx);
        items.push({
            fromIndex: void 0,
            toIndex: idx,
            hasMoved: !1,
            diff: addedInput(input, void 0),
            annotation: input.annotation
        });
    }
    for(let idx = 0; idx < fromInput.length; idx++){
        const input = fromInput.at(idx);
        items.push({
            fromIndex: idx,
            toIndex: void 0,
            hasMoved: !1,
            diff: removedInput(input, void 0),
            annotation: input.annotation
        });
    }
    return buildArrayDiff(fromInput, toInput, items, !0);
}
function diffArrayByKey(fromArray, fromKeyIndex, toArray, toKeyIndex, options) {
    const items = [];
    let isChanged = !1;
    function diffCommon(key, fromIndex, toIndex, hasMoved) {
        deletePositionInIndex(fromKeyIndex.index, key, fromIndex), deletePositionInIndex(toKeyIndex.index, key, toIndex);
        const fromInput = fromArray.at(fromIndex), toInput = toArray.at(toIndex), diff = diffInput(fromInput, toInput);
        items.push({
            fromIndex,
            toIndex,
            hasMoved,
            diff,
            annotation: toArray.annotationAt(toIndex)
        }), (diff.isChanged || fromIndex !== toIndex) && (isChanged = !0);
    }
    const lcs = getLongestCommonSubsequence(fromKeyIndex.keys, toKeyIndex.keys);
    for(let fromIndex = 0; fromIndex < fromKeyIndex.keys.length; fromIndex++){
        const key = fromKeyIndex.keys[fromIndex], subsequenceIdx = lcs.prevIndices.indexOf(fromIndex);
        if (subsequenceIdx !== -1) {
            diffCommon(key, fromIndex, lcs.nextIndices[subsequenceIdx], !1);
            continue;
        }
        const toIndexes = toKeyIndex.index.get(key), toIndex = toIndexes && toIndexes.find((idx)=>!lcs.nextIndices.includes(idx));
        if (toIndex !== void 0) {
            diffCommon(key, fromIndex, toIndex, !0);
            continue;
        }
        const input = fromArray.at(fromIndex);
        items.push({
            fromIndex,
            toIndex: void 0,
            hasMoved: !1,
            diff: removedInput(input, void 0),
            annotation: fromArray.annotationAt(fromIndex)
        }), isChanged = !0;
    }
    for (const positions of toKeyIndex.index.values()){
        for (const toIndex of positions){
            const input = toArray.at(toIndex);
            items.push({
                fromIndex: void 0,
                toIndex,
                hasMoved: !1,
                diff: addedInput(input, void 0),
                annotation: toArray.annotationAt(toIndex)
            });
        }
        isChanged = !0;
    }
    return items.sort(compareItemDiff), buildArrayDiff(fromArray, toArray, items, isChanged);
}
function compareItemDiff(a, b) {
    if (a.toIndex !== void 0 && b.toIndex !== void 0) return a.toIndex - b.toIndex;
    if (a.fromIndex !== void 0 && b.fromIndex !== void 0) return a.fromIndex - b.fromIndex;
    if (a.fromIndex !== void 0 && b.toIndex !== void 0) return -1;
    if (a.toIndex !== void 0 && b.fromIndex !== void 0) return 1;
    throw new Error("invalid item diff comparison");
}
function deletePositionInIndex(index, key, pos) {
    const positions = index.get(key);
    deleteArrayValue(positions, pos), positions.length === 0 && index.delete(key);
}
function deleteArrayValue(arr, value) {
    const idx = arr.indexOf(value);
    if (idx === -1) throw new Error("value not found");
    arr.splice(idx, 1);
}
function indexByKey(arr) {
    const index = /* @__PURE__ */ new Map(), keys = [], length = arr.length;
    for(let i = 0; i < length; i++){
        const item = arr.at(i);
        let key = null;
        switch(item.type){
            case "string":
                key = `s${item.value}`;
                break;
            case "number":
                key = item.value;
                break;
            case "boolean":
                key = item.value;
                break;
            case "null":
                key = "n";
                break;
            case "object":
                {
                    const keyField = item.get("_key");
                    if (keyField && keyField.type === "string" && (key = `k${keyField.value}`, index.has(key))) return;
                }
                break;
        }
        if (key === null) return;
        keys.push(key);
        let positions = index.get(key);
        positions || (positions = [], index.set(key, positions)), positions.push(i);
    }
    return {
        keys,
        index
    };
}
function removedArray(input, toValue, options) {
    return {
        type: "array",
        action: "removed",
        isChanged: !0,
        fromValue: input.value,
        toValue,
        annotation: input.annotation,
        get items () {
            const items = [];
            for(let i = 0; i < input.length; i++){
                const item = input.at(i);
                items.push({
                    fromIndex: i,
                    toIndex: void 0,
                    hasMoved: !1,
                    diff: removedInput(item, void 0),
                    annotation: input.annotationAt(i)
                });
            }
            return replaceProperty(this, "items", items);
        }
    };
}
function addedArray(input, fromValue, options) {
    return {
        type: "array",
        action: "added",
        isChanged: !0,
        fromValue,
        toValue: input.value,
        annotation: input.annotation,
        get items () {
            const items = [];
            for(let i = 0; i < input.length; i++){
                const item = input.at(i);
                items.push({
                    fromIndex: void 0,
                    toIndex: i,
                    hasMoved: !1,
                    diff: addedInput(item, void 0),
                    annotation: input.annotationAt(i)
                });
            }
            return replaceProperty(this, "items", items);
        }
    };
}
const ignoredFields = /* @__PURE__ */ new Set([
    "_id",
    "_type",
    "_createdAt",
    "_updatedAt",
    "_rev",
    "_weak"
]);
function diffObject(fromInput, toInput, options) {
    const fields = {};
    let isChanged = !1;
    for (const key of fromInput.keys){
        if (ignoredFields.has(key)) continue;
        const fromField = fromInput.get(key), toField = toInput.get(key);
        if (toField) {
            const fieldDiff = diffInput(fromField, toField, options);
            fields[key] = fieldDiff, fieldDiff.isChanged && (isChanged = !0);
        } else fields[key] = removedInput(fromField, void 0), isChanged = !0;
    }
    for (const key of toInput.keys){
        if (ignoredFields.has(key) || fromInput.get(key)) continue;
        const toField = toInput.get(key);
        fields[key] = addedInput(toField, void 0), isChanged = !0;
    }
    const fromValue = fromInput.value, toValue = toInput.value;
    return isChanged ? {
        type: "object",
        action: "changed",
        isChanged: !0,
        fromValue,
        toValue,
        fields,
        annotation: toInput.annotation
    } : {
        type: "object",
        action: "unchanged",
        isChanged: !1,
        fromValue,
        toValue,
        fields
    };
}
function removedObject(input, toValue, options) {
    return {
        type: "object",
        action: "removed",
        isChanged: !0,
        fromValue: input.value,
        toValue,
        annotation: input.annotation,
        get fields () {
            const fields = {};
            for (const key of input.keys){
                const value = input.get(key);
                fields[key] = removedInput(value, void 0);
            }
            return replaceProperty(this, "fields", fields);
        }
    };
}
function addedObject(input, fromValue, options) {
    return {
        type: "object",
        action: "added",
        isChanged: !0,
        fromValue,
        toValue: input.value,
        annotation: input.annotation,
        get fields () {
            const fields = {};
            for (const key of input.keys){
                const value = input.get(key);
                fields[key] = addedInput(value, void 0);
            }
            return replaceProperty(this, "fields", fields);
        }
    };
}
function diffNumber(fromInput, toInput, options) {
    const fromValue = fromInput.value, toValue = toInput.value, type = fromInput.type;
    return fromValue === toValue ? {
        type,
        action: "unchanged",
        fromValue,
        toValue,
        isChanged: !1
    } : {
        type: fromInput.type,
        action: "changed",
        isChanged: !0,
        fromValue,
        toValue,
        annotation: toInput.annotation
    };
}
function diffBoolean(fromInput, toInput, options) {
    const fromValue = fromInput.value, toValue = toInput.value, type = fromInput.type;
    return fromValue === toValue ? {
        type,
        action: "unchanged",
        fromValue,
        toValue,
        isChanged: !1
    } : {
        type: fromInput.type,
        action: "changed",
        isChanged: !0,
        fromValue,
        toValue,
        annotation: toInput.annotation
    };
}
function diffString(fromInput, toInput, options) {
    const fromValue = fromInput.value, toValue = toInput.value;
    return fromValue === toValue ? {
        type: "string",
        action: "unchanged",
        isChanged: !1,
        fromValue,
        toValue,
        segments: [
            {
                type: "stringSegment",
                action: "unchanged",
                text: fromValue
            }
        ]
    } : {
        type: "string",
        action: "changed",
        isChanged: !0,
        fromValue,
        toValue,
        annotation: toInput.annotation,
        // Compute and memoize string segments only when accessed
        get segments () {
            const segments = buildSegments(fromInput, toInput);
            return replaceProperty(this, "segments", segments);
        }
    };
}
function buildSegments(fromInput, toInput) {
    const segments = [], dmpDiffs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cleanupSemantic"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeDiff"])(fromInput.value, toInput.value));
    let fromIdx = 0, toIdx = 0;
    for (const [op, text] of dmpDiffs)switch(op){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIFF_EQUAL"]:
            segments.push({
                type: "stringSegment",
                action: "unchanged",
                text
            }), fromIdx += text.length, toIdx += text.length;
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIFF_DELETE"]:
            for (const segment of fromInput.sliceAnnotation(fromIdx, fromIdx + text.length))segments.push({
                type: "stringSegment",
                action: "removed",
                text: segment.text,
                annotation: segment.annotation
            });
            fromIdx += text.length;
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIFF_INSERT"]:
            for (const segment of toInput.sliceAnnotation(toIdx, toIdx + text.length))segments.push({
                type: "stringSegment",
                action: "added",
                text: segment.text,
                annotation: segment.annotation
            });
            toIdx += text.length;
            break;
        default:
            throw new Error(`Unhandled diff-match-patch operation "${op}"`);
    }
    return segments;
}
function removedString(input, toValue, options) {
    return {
        type: "string",
        action: "removed",
        isChanged: !0,
        fromValue: input.value,
        toValue,
        annotation: input.annotation,
        get segments () {
            const segments = input.sliceAnnotation(0, input.value.length).map((segment)=>({
                    type: "stringSegment",
                    action: "removed",
                    ...segment
                }));
            return replaceProperty(this, "segments", segments);
        }
    };
}
function addedString(input, fromValue, options) {
    return {
        type: "string",
        action: "added",
        isChanged: !0,
        fromValue,
        toValue: input.value,
        annotation: input.annotation,
        get segments () {
            const segments = input.sliceAnnotation(0, input.value.length).map((segment)=>({
                    type: "stringSegment",
                    action: "added",
                    ...segment
                }));
            return replaceProperty(this, "segments", segments);
        }
    };
}
function diffTypeChange(fromInput, toInput, options) {
    return {
        type: "typeChange",
        action: "changed",
        isChanged: !0,
        fromType: fromInput.type,
        fromValue: fromInput.value,
        fromDiff: removedInput(fromInput, void 0),
        toType: toInput.type,
        toValue: toInput.value,
        toDiff: addedInput(toInput, void 0),
        annotation: toInput.annotation
    };
}
function diffInput(fromInput, toInput, options = {}) {
    return fromInput.type !== toInput.type ? fromInput.type === "null" ? addedInput(toInput, null) : toInput.type === "null" ? removedInput(fromInput, null) : diffTypeChange(fromInput, toInput) : diffWithType(fromInput.type, fromInput, toInput, options);
}
function diffWithType(type, fromInput, toInput, options) {
    switch(type){
        case "null":
            return {
                type: "null",
                action: "unchanged",
                isChanged: !1,
                toValue: null,
                fromValue: null
            };
        case "boolean":
            return diffBoolean(fromInput, toInput);
        case "number":
            return diffNumber(fromInput, toInput);
        case "string":
            return diffString(fromInput, toInput);
        case "array":
            return diffArray(fromInput, toInput, options);
        case "object":
            return diffObject(fromInput, toInput, options);
        default:
            throw new Error(`Unhandled diff type "${type}"`);
    }
}
function removedInput(input, toValue, options) {
    switch(input.type){
        case "null":
            return {
                type: "null",
                action: "removed",
                isChanged: !0,
                fromValue: null,
                toValue,
                annotation: input.annotation
            };
        case "boolean":
            return {
                type: "boolean",
                action: "removed",
                isChanged: !0,
                fromValue: input.value,
                toValue,
                annotation: input.annotation
            };
        case "number":
            return {
                type: "number",
                action: "removed",
                isChanged: !0,
                fromValue: input.value,
                toValue,
                annotation: input.annotation
            };
        case "string":
            return removedString(input, toValue);
        case "array":
            return removedArray(input, toValue);
        case "object":
            return removedObject(input, toValue);
        default:
            throw new Error("Unhandled diff type");
    }
}
function addedInput(input, fromValue, options) {
    switch(input.type){
        case "null":
            return {
                type: "null",
                action: "added",
                isChanged: !0,
                fromValue,
                toValue: null,
                annotation: input.annotation
            };
        case "boolean":
            return {
                type: "boolean",
                action: "added",
                isChanged: !0,
                fromValue,
                toValue: input.value,
                annotation: input.annotation
            };
        case "number":
            return {
                type: "number",
                action: "added",
                isChanged: !0,
                fromValue,
                toValue: input.value,
                annotation: input.annotation
            };
        case "string":
            return addedString(input, fromValue);
        case "array":
            return addedArray(input, fromValue);
        case "object":
            return addedObject(input, fromValue);
        default:
            throw new Error("Unhandled diff type");
    }
}
class ArrayWrapper {
    type = "array";
    length;
    value;
    annotation;
    elements = [];
    constructor(value, annotation){
        this.annotation = annotation, this.value = value, this.length = value.length;
    }
    at(idx) {
        if (idx >= this.length) throw new Error("out of bounds");
        return this.elements[idx] || (this.elements[idx] = wrap(this.value[idx], this.annotation));
    }
    annotationAt() {
        return this.annotation;
    }
}
class BasicWrapper {
    type;
    value;
    annotation;
    constructor(type, value, annotation){
        this.type = type, this.value = value, this.annotation = annotation;
    }
}
class ObjectWrapper {
    type = "object";
    value;
    keys;
    annotation;
    fields = {};
    constructor(value, annotation){
        this.value = value, this.annotation = annotation, this.keys = Object.keys(value);
    }
    get(key) {
        const input = this.fields[key];
        if (input) return input;
        if (!this.value.hasOwnProperty(key)) return;
        const raw = this.value[key];
        return this.fields[key] = wrap(raw, this.annotation);
    }
}
class StringWrapper {
    type = "string";
    value;
    annotation;
    constructor(value, annotation){
        this.value = value, this.annotation = annotation;
    }
    sliceAnnotation(start, end) {
        return [
            {
                text: this.value.slice(start, end),
                annotation: this.annotation
            }
        ];
    }
}
function wrap(input, annotation) {
    if (Array.isArray(input)) return new ArrayWrapper(input, annotation);
    if (input === null) return new BasicWrapper("null", input, annotation);
    const type = typeof input;
    switch(type){
        case "number":
            return new BasicWrapper(type, input, annotation);
        case "boolean":
            return new BasicWrapper(type, input, annotation);
        case "object":
            return new ObjectWrapper(input, annotation);
        case "string":
            return new StringWrapper(input, annotation);
        default:
            throw new Error(`cannot wrap value of type: ${type}`);
    }
}
;
 //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/@sanity/vision/lib/_chunks-es/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "visionLocaleNamespace": (()=>visionLocaleNamespace),
    "visionTool": (()=>visionTool)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/icons/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/sanity/lib/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$router$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/sanity/lib/router.mjs [app-client] (ecmascript) <locals>");
;
;
;
;
const visionLocaleNamespace = "vision", visionUsEnglishLocaleBundle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["defineLocaleResourceBundle"])({
    locale: "en-US",
    namespace: visionLocaleNamespace,
    resources: ()=>__turbopack_context__.r("[project]/node_modules/@sanity/vision/lib/_chunks-es/resources.mjs [app-client] (ecmascript, async loader)")(__turbopack_context__.i)
}), visionTool = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["definePlugin"])((options)=>{
    const { name, title, icon, ...config } = options || {};
    return {
        name: "@sanity/vision",
        tools: [
            {
                name: name || "vision",
                title: title || "Vision",
                icon: icon || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EyeOpenIcon"],
                component: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lazy"])(()=>__turbopack_context__.r("[project]/node_modules/@sanity/vision/lib/_chunks-es/SanityVision.mjs [app-client] (ecmascript, async loader)")(__turbopack_context__.i)),
                options: config,
                router: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$router$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["route"].create("/*"),
                __internalApplicationType: "sanity/vision"
            }
        ],
        i18n: {
            bundles: [
                visionUsEnglishLocaleBundle
            ]
        }
    };
});
;
 //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/@sanity/preview-url-secret/dist/constants.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "SECRET_TTL": (()=>SECRET_TTL),
    "apiVersion": (()=>apiVersion),
    "deleteExpiredSecretsQuery": (()=>deleteExpiredSecretsQuery),
    "fetchSecretQuery": (()=>fetchSecretQuery),
    "fetchSharedAccessQuery": (()=>fetchSharedAccessQuery),
    "fetchSharedAccessSecretQuery": (()=>fetchSharedAccessSecretQuery),
    "fetchVercelProtectionBypassSecret": (()=>fetchVercelProtectionBypassSecret),
    "isDev": (()=>isDev),
    "perspectiveCookieName": (()=>perspectiveCookieName),
    "schemaIdPrefix": (()=>schemaIdPrefix),
    "schemaIdSingleton": (()=>schemaIdSingleton),
    "schemaType": (()=>schemaType),
    "schemaTypeSingleton": (()=>schemaTypeSingleton),
    "tag": (()=>tag),
    "urlSearchParamPreviewPathname": (()=>urlSearchParamPreviewPathname),
    "urlSearchParamPreviewPerspective": (()=>urlSearchParamPreviewPerspective),
    "urlSearchParamPreviewSecret": (()=>urlSearchParamPreviewSecret),
    "urlSearchParamVercelProtectionBypass": (()=>urlSearchParamVercelProtectionBypass),
    "urlSearchParamVercelSetBypassCookie": (()=>urlSearchParamVercelSetBypassCookie),
    "vercelProtectionBypassSchemaId": (()=>vercelProtectionBypassSchemaId),
    "vercelProtectionBypassSchemaType": (()=>vercelProtectionBypassSchemaType)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
const schemaType = "sanity.previewUrlSecret", schemaIdPrefix = "sanity-preview-url-secret", schemaIdSingleton = `${schemaIdPrefix}.share-access`, schemaTypeSingleton = "sanity.previewUrlShareAccess", apiVersion = "2025-02-19", urlSearchParamPreviewSecret = "sanity-preview-secret", urlSearchParamPreviewPathname = "sanity-preview-pathname", urlSearchParamPreviewPerspective = "sanity-preview-perspective", urlSearchParamVercelProtectionBypass = "x-vercel-protection-bypass", urlSearchParamVercelSetBypassCookie = "x-vercel-set-bypass-cookie", isDev = ("TURBOPACK compile-time value", "development") === "development", SECRET_TTL = 60 * 60, fetchSecretQuery = /* groq */ `*[_type == "${schemaType}" && secret == $secret && dateTime(_updatedAt) > dateTime(now()) - ${SECRET_TTL}][0]{
    _id,
    _updatedAt,
    secret,
    studioUrl,
  }`, fetchSharedAccessQuery = /* groq */ `*[_id == "${schemaIdSingleton}" && _type == "${schemaTypeSingleton}"][0].secret`, fetchSharedAccessSecretQuery = /* groq */ `*[_id == "${schemaIdSingleton}" && _type == "${schemaTypeSingleton}" && secret == $secret][0]{
  secret,
  studioUrl,
}`, deleteExpiredSecretsQuery = /* groq */ `*[_type == "${schemaType}" && dateTime(_updatedAt) <= dateTime(now()) - ${SECRET_TTL}]`, vercelProtectionBypassSchemaType = "sanity.vercelProtectionBypass", vercelProtectionBypassSchemaId = `${schemaIdPrefix}.vercel-protection-bypass`, fetchVercelProtectionBypassSecret = /* groq */ `*[_id == "${vercelProtectionBypassSchemaId}" && _type == "${vercelProtectionBypassSchemaType}"][0].secret`, tag = "sanity.preview-url-secret", perspectiveCookieName = "sanity-preview-perspective";
;
 //# sourceMappingURL=constants.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40sanity_532ef3cf._.js.map